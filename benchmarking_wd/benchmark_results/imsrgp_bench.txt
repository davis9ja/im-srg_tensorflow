--- BENCHMARK FOR imsrg_pairing ---
Executing NP on n_holes=2 ---------------------------
-0.25
Wrote profile results to imsrg_pairing_bench.py.lprof
Timer unit: 1e-06 s

Total time: 3.5e-05 s
File: imsrg_pairing_bench.py
Function: construct_basis_2B at line 30

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    30                                           @profile
    31                                           def construct_basis_2B(holes, particles):
    32         1          0.0      0.0      0.0    basis = []
    33         3          2.0      0.7      5.7    for i in holes:
    34         6          7.0      1.2     20.0      for j in holes:
    35         4          1.0      0.2      2.9        basis.append((i, j)) # hole, hole
    36                                           
    37         3          1.0      0.3      2.9    for i in holes:
    38         6          5.0      0.8     14.3      for a in particles:
    39         4          3.0      0.8      8.6        basis.append((i, a)) # hole, particle
    40                                           
    41         3          2.0      0.7      5.7    for a in particles:
    42         6          4.0      0.7     11.4      for i in holes:
    43         4          2.0      0.5      5.7        basis.append((a, i)) # particle, hole
    44                                           
    45         3          2.0      0.7      5.7    for a in particles:
    46         6          4.0      0.7     11.4      for b in particles:
    47         4          2.0      0.5      5.7        basis.append((a, b)) # particle, particle
    48                                           
    49         1          0.0      0.0      0.0    return basis

Total time: 2.9e-05 s
File: imsrg_pairing_bench.py
Function: construct_basis_ph2B at line 52

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    52                                           @profile
    53                                           def construct_basis_ph2B(holes, particles):
    54         1          0.0      0.0      0.0    basis = []
    55         3          2.0      0.7      6.9    for i in holes:
    56         6          4.0      0.7     13.8      for j in holes:
    57         4          3.0      0.8     10.3        basis.append((i, j))
    58                                           
    59         3          1.0      0.3      3.4    for i in holes:
    60         6          3.0      0.5     10.3      for a in particles:
    61         4          2.0      0.5      6.9        basis.append((i, a))
    62                                           
    63         3          2.0      0.7      6.9    for a in particles:
    64         6          3.0      0.5     10.3      for i in holes:
    65         4          1.0      0.2      3.4        basis.append((a, i))
    66                                           
    67         3          3.0      1.0     10.3    for a in particles:
    68         6          4.0      0.7     13.8      for b in particles:
    69         4          1.0      0.2      3.4        basis.append((a, b))
    70                                           
    71         1          0.0      0.0      0.0    return basis

Total time: 2.7e-05 s
File: imsrg_pairing_bench.py
Function: construct_index_2B at line 77

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    77                                           @profile
    78                                           def construct_index_2B(bas2B):
    79         2          1.0      0.5      3.7    index = { }
    80        34         13.0      0.4     48.1    for i, state in enumerate(bas2B):
    81        32         13.0      0.4     48.1      index[state] = i
    82                                           
    83         2          0.0      0.0      0.0    return index

Total time: 0.001724 s
File: imsrg_pairing_bench.py
Function: ph_transform_2B at line 90

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    90                                           @profile
    91                                           def ph_transform_2B(Gamma, bas2B, idx2B, basph2B, idxph2B):
    92         4          5.0      1.2      0.3    dim = len(basph2B)
    93         4         11.0      2.8      0.6    Gamma_ph = np.zeros((dim, dim))
    94                                           
    95        68         36.0      0.5      2.1    for i1, (a,b) in enumerate(basph2B):
    96      1088        484.0      0.4     28.1      for i2, (c, d) in enumerate(basph2B):
    97      1024       1187.0      1.2     68.9        Gamma_ph[i1, i2] -= Gamma[idx2B[(a,d)], idx2B[(c,b)]]
    98                                           
    99         4          1.0      0.2      0.1    return Gamma_ph

Total time: 0.000858 s
File: imsrg_pairing_bench.py
Function: inverse_ph_transform_2B at line 101

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   101                                           @profile
   102                                           def inverse_ph_transform_2B(Gamma_ph, bas2B, idx2B, basph2B, idxph2B):
   103         2          1.0      0.5      0.1    dim = len(bas2B)
   104         2          2.0      1.0      0.2    Gamma = np.zeros((dim, dim))
   105                                           
   106        34         17.0      0.5      2.0    for i1, (a,b) in enumerate(bas2B):
   107       544        239.0      0.4     27.9      for i2, (c, d) in enumerate(bas2B):
   108       512        598.0      1.2     69.7        Gamma[i1, i2] -= Gamma_ph[idxph2B[(a,d)], idxph2B[(c,b)]]
   109                                             
   110         2          1.0      0.5      0.1    return Gamma

Total time: 4.4e-05 s
File: imsrg_pairing_bench.py
Function: commutator at line 115

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   115                                           @profile
   116                                           def commutator(a,b):
   117         2         44.0     22.0    100.0    return dot(a,b) - dot(b,a)

Total time: 1.1e-05 s
File: imsrg_pairing_bench.py
Function: construct_occupation_1B at line 150

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   150                                           @profile
   151                                           def construct_occupation_1B(bas1B, holes, particles):
   152         1          1.0      1.0      9.1    dim = len(bas1B)
   153         1          4.0      4.0     36.4    occ = np.zeros(dim)
   154                                           
   155         3          3.0      1.0     27.3    for i in holes:
   156         2          3.0      1.5     27.3      occ[i] = 1.
   157                                           
   158         1          0.0      0.0      0.0    return occ

Total time: 4.2e-05 s
File: imsrg_pairing_bench.py
Function: construct_occupationA_2B at line 161

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   161                                           @profile
   162                                           def construct_occupationA_2B(bas2B, occ1B):
   163         2          2.0      1.0      4.8    dim = len(bas2B)
   164         2          4.0      2.0      9.5    occ = np.zeros((dim,dim))
   165                                           
   166        34         10.0      0.3     23.8    for i1, (i,j) in enumerate(bas2B):
   167        32         26.0      0.8     61.9      occ[i1, i1] = occ1B[i] - occ1B[j]
   168                                           
   169         2          0.0      0.0      0.0    return occ

Total time: 3.7e-05 s
File: imsrg_pairing_bench.py
Function: construct_occupationB_2B at line 173

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   173                                           @profile
   174                                           def construct_occupationB_2B(bas2B, occ1B):
   175         1          1.0      1.0      2.7    dim = len(bas2B)
   176         1          2.0      2.0      5.4    occ = np.zeros((dim,dim))
   177                                           
   178        17         17.0      1.0     45.9    for i1, (i,j) in enumerate(bas2B):
   179        16         17.0      1.1     45.9      occ[i1, i1] = 1. - occ1B[i] - occ1B[j]
   180                                           
   181         1          0.0      0.0      0.0    return occ

Total time: 2.3e-05 s
File: imsrg_pairing_bench.py
Function: construct_occupationC_2B at line 184

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   184                                           @profile
   185                                           def construct_occupationC_2B(bas2B, occ1B):
   186         1          1.0      1.0      4.3    dim = len(bas2B)
   187         1          3.0      3.0     13.0    occ = np.zeros((dim,dim))
   188                                           
   189        17          6.0      0.4     26.1    for i1, (i,j) in enumerate(bas2B):
   190        16         12.0      0.8     52.2      occ[i1, i1] = occ1B[i] * occ1B[j]
   191                                           
   192         1          1.0      1.0      4.3    return occ

Total time: 0.018302 s
File: imsrg_pairing_bench.py
Function: eta_wegner at line 382

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   382                                           @profile
   383                                           def eta_wegner(f, Gamma, user_data):
   384                                           
   385         1          1.0      1.0      0.0    dim1B     = user_data["dim1B"]
   386         1          1.0      1.0      0.0    holes     = user_data["holes"]
   387         1          1.0      1.0      0.0    particles = user_data["particles"]
   388         1          1.0      1.0      0.0    bas2B     = user_data["bas2B"]
   389         1          0.0      0.0      0.0    basph2B   = user_data["basph2B"]
   390         1          1.0      1.0      0.0    idx2B     = user_data["idx2B"]
   391         1          1.0      1.0      0.0    idxph2B   = user_data["idxph2B"]
   392         1          1.0      1.0      0.0    occB_2B   = user_data["occB_2B"]
   393         1          1.0      1.0      0.0    occC_2B   = user_data["occC_2B"]
   394         1          0.0      0.0      0.0    occphA_2B = user_data["occphA_2B"]
   395                                           
   396                                           
   397                                             # split Hamiltonian in diagonal and off-diagonal parts
   398         1         23.0     23.0      0.1    fd      = np.zeros_like(f)
   399         1          7.0      7.0      0.0    fod     = np.zeros_like(f)
   400         1          5.0      5.0      0.0    Gammad  = np.zeros_like(Gamma)
   401         1          6.0      6.0      0.0    Gammaod = np.zeros_like(Gamma)
   402                                           
   403         3          3.0      1.0      0.0    for a in particles:
   404         6          8.0      1.3      0.0      for i in holes:
   405         4          5.0      1.2      0.0        fod[a, i] = f[a,i]
   406         4          5.0      1.2      0.0        fod[i, a] = f[i,a]
   407         1          7.0      7.0      0.0    fd = f - fod
   408                                           
   409         3          4.0      1.3      0.0    for a in particles:
   410         6          5.0      0.8      0.0      for b in particles:
   411        12         14.0      1.2      0.1        for i in holes:
   412        24         25.0      1.0      0.1          for j in holes:
   413        16         29.0      1.8      0.2            Gammaod[idx2B[(a,b)], idx2B[(i,j)]] = Gamma[idx2B[(a,b)], idx2B[(i,j)]]
   414        16         30.0      1.9      0.2            Gammaod[idx2B[(i,j)], idx2B[(a,b)]] = Gamma[idx2B[(i,j)], idx2B[(a,b)]]
   415         1          4.0      4.0      0.0    Gammad = Gamma - Gammaod
   416                                           
   417                                           
   418                                             #############################        
   419                                             # one-body flow equation  
   420         1          7.0      7.0      0.0    eta1B  = np.zeros_like(f)
   421                                           
   422                                             # 1B - 1B
   423         1         48.0     48.0      0.3    eta1B += commutator(fd, fod)
   424                                           
   425                                             # 1B - 2B
   426         5          3.0      0.6      0.0    for p in range(dim1B):
   427        20         17.0      0.8      0.1      for q in range(dim1B):
   428        48         56.0      1.2      0.3        for i in holes:
   429        96        106.0      1.1      0.6          for a in particles:
   430        64         61.0      1.0      0.3            eta1B[p,q] += (
   431                                                       fd[i,a]  * Gammaod[idx2B[(a, p)], idx2B[(i, q)]] 
   432                                                       - fd[a,i]  * Gammaod[idx2B[(i, p)], idx2B[(a, q)]] 
   433                                                       - fod[i,a] * Gammad[idx2B[(a, p)], idx2B[(i, q)]] 
   434        64        329.0      5.1      1.8              + fod[a,i] * Gammad[idx2B[(i, p)], idx2B[(a, q)]]
   435                                                     )
   436                                           
   437                                             # 2B - 2B
   438                                             # n_a n_b nn_c + nn_a nn_b n_c = n_a n_b + (1 - n_a - n_b) * n_c
   439         1         11.0     11.0      0.1    GammaGamma = dot(Gammad, dot(occB_2B, Gammaod))
   440         5          5.0      1.0      0.0    for p in range(dim1B):
   441        20         19.0      0.9      0.1      for q in range(dim1B):
   442        48         59.0      1.2      0.3        for i in holes:
   443        32         32.0      1.0      0.2          eta1B[p,q] += (
   444        32         48.0      1.5      0.3            0.5*GammaGamma[idx2B[(i,p)], idx2B[(i,q)]] 
   445        32        102.0      3.2      0.6            - transpose(GammaGamma)[idx2B[(i,p)], idx2B[(i,q)]]
   446                                                   )
   447                                           
   448         1          7.0      7.0      0.0    GammaGamma = dot(Gammad, dot(occC_2B, Gammaod))
   449         5          5.0      1.0      0.0    for p in range(dim1B):
   450        20         23.0      1.1      0.1      for q in range(dim1B):
   451        80         76.0      0.9      0.4        for r in range(dim1B):
   452        64         63.0      1.0      0.3          eta1B[p,q] += (
   453        64        118.0      1.8      0.6            0.5*GammaGamma[idx2B[(r,p)], idx2B[(r,q)]] 
   454        64        209.0      3.3      1.1            + transpose(GammaGamma)[idx2B[(r,p)], idx2B[(r,q)]] 
   455                                                   )
   456                                           
   457                                           
   458                                             #############################        
   459                                             # two-body flow equation  
   460         1         12.0     12.0      0.1    eta2B = np.zeros_like(Gamma)
   461                                           
   462                                             # 1B - 2B
   463         5          6.0      1.2      0.0    for p in range(dim1B):
   464        20         18.0      0.9      0.1      for q in range(dim1B):
   465        80         71.0      0.9      0.4        for r in range(dim1B):
   466       320        279.0      0.9      1.5          for s in range(dim1B):
   467      1280       1124.0      0.9      6.1            for t in range(dim1B):
   468      1024       1690.0      1.7      9.2              eta2B[idx2B[(p,q)],idx2B[(r,s)]] += (
   469                                                         fd[p,t] * Gammaod[idx2B[(t,q)],idx2B[(r,s)]] 
   470                                                         + fd[q,t] * Gammaod[idx2B[(p,t)],idx2B[(r,s)]] 
   471                                                         - fd[t,r] * Gammaod[idx2B[(p,q)],idx2B[(t,s)]] 
   472                                                         - fd[t,s] * Gammaod[idx2B[(p,q)],idx2B[(r,t)]]
   473                                                         - fod[p,t] * Gammad[idx2B[(t,q)],idx2B[(r,s)]] 
   474                                                         - fod[q,t] * Gammad[idx2B[(p,t)],idx2B[(r,s)]] 
   475                                                         + fod[t,r] * Gammad[idx2B[(p,q)],idx2B[(t,s)]] 
   476      1024      10411.0     10.2     56.9                + fod[t,s] * Gammad[idx2B[(p,q)],idx2B[(r,t)]]
   477                                                       )
   478                                           
   479                                             
   480                                             # 2B - 2B - particle and hole ladders
   481                                             # Gammad.occB.Gammaod
   482         1         13.0     13.0      0.1    GammaGamma = dot(Gammad, dot(occB_2B, Gammaod))
   483                                           
   484         1         28.0     28.0      0.2    eta2B += 0.5 * (GammaGamma - transpose(GammaGamma))
   485                                           
   486                                             # 2B - 2B - particle-hole chain
   487                                             
   488                                             # transform matrices to particle-hole representation and calculate 
   489                                             # Gammad_ph.occA_ph.Gammaod_ph
   490         1        641.0    641.0      3.5    Gammad_ph = ph_transform_2B(Gammad, bas2B, idx2B, basph2B, idxph2B)
   491         1        627.0    627.0      3.4    Gammaod_ph = ph_transform_2B(Gammaod, bas2B, idx2B, basph2B, idxph2B)
   492                                           
   493         1          8.0      8.0      0.0    GammaGamma_ph = dot(Gammad_ph, dot(occphA_2B, Gammaod_ph))
   494                                           
   495                                             # transform back to standard representation
   496         1        630.0    630.0      3.4    GammaGamma    = inverse_ph_transform_2B(GammaGamma_ph, bas2B, idx2B, basph2B, idxph2B)
   497                                           
   498                                             # commutator / antisymmetrization
   499         1         11.0     11.0      0.1    work = np.zeros_like(GammaGamma)
   500        17         17.0      1.0      0.1    for i1, (i,j) in enumerate(bas2B):
   501       272        244.0      0.9      1.3      for i2, (k,l) in enumerate(bas2B):
   502       256        238.0      0.9      1.3        work[i1, i2] -= (
   503                                                   GammaGamma[i1, i2] 
   504                                                   - GammaGamma[idx2B[(j,i)], i2] 
   505                                                   - GammaGamma[i1, idx2B[(l,k)]] 
   506       256        635.0      2.5      3.5          + GammaGamma[idx2B[(j,i)], idx2B[(l,k)]]
   507                                                 )
   508         1          1.0      1.0      0.0    GammaGamma = work
   509                                           
   510         1          5.0      5.0      0.0    eta2B += GammaGamma
   511                                           
   512                                           
   513         1          1.0      1.0      0.0    return eta1B, eta2B

Total time: 0.01865 s
File: imsrg_pairing_bench.py
Function: flow_imsrg2 at line 519

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   519                                           @profile
   520                                           def flow_imsrg2(eta1B, eta2B, f, Gamma, user_data):
   521                                           
   522         1          1.0      1.0      0.0    dim1B     = user_data["dim1B"]
   523         1          1.0      1.0      0.0    holes     = user_data["holes"]
   524         1          0.0      0.0      0.0    particles = user_data["particles"]
   525         1          1.0      1.0      0.0    bas2B     = user_data["bas2B"]
   526         1          1.0      1.0      0.0    idx2B     = user_data["idx2B"]
   527         1          1.0      1.0      0.0    basph2B   = user_data["basph2B"]
   528         1          1.0      1.0      0.0    idxph2B   = user_data["idxph2B"]
   529         1          1.0      1.0      0.0    occB_2B   = user_data["occB_2B"]
   530         1          1.0      1.0      0.0    occC_2B   = user_data["occC_2B"]
   531         1          1.0      1.0      0.0    occphA_2B = user_data["occphA_2B"]
   532                                           
   533                                             #############################        
   534                                             # zero-body flow equation
   535         1          1.0      1.0      0.0    dE = 0.0
   536                                           
   537         3          4.0      1.3      0.0    for i in holes:
   538         6          9.0      1.5      0.0      for a in particles:
   539         4          9.0      2.2      0.0        dE += eta1B[i,a] * f[a,i] - eta1B[a,i] * f[i,a]
   540                                           
   541         3          2.0      0.7      0.0    for i in holes:
   542         6          7.0      1.2      0.0      for j in holes:
   543        12         14.0      1.2      0.1        for a in particles:
   544        24         30.0      1.2      0.2          for b in particles:
   545        16         33.0      2.1      0.2            dE += 0.5 * eta2B[idx2B[(i,j)], idx2B[(a,b)]] * Gamma[idx2B[(a,b)], idx2B[(i,j)]]
   546                                           
   547                                           
   548                                             #############################        
   549                                             # one-body flow equation  
   550         1          9.0      9.0      0.0    df  = np.zeros_like(f)
   551                                           
   552                                             # 1B - 1B
   553         1         13.0     13.0      0.1    df += commutator(eta1B, f)
   554                                           
   555                                             # 1B - 2B
   556         5          6.0      1.2      0.0    for p in range(dim1B):
   557        20         20.0      1.0      0.1      for q in range(dim1B):
   558        48         53.0      1.1      0.3        for i in holes:
   559        96        121.0      1.3      0.6          for a in particles:
   560        64         62.0      1.0      0.3            df[p,q] += (
   561                                                       eta1B[i,a] * Gamma[idx2B[(a, p)], idx2B[(i, q)]] 
   562                                                       - eta1B[a,i] * Gamma[idx2B[(i, p)], idx2B[(a, q)]] 
   563                                                       - f[i,a] * eta2B[idx2B[(a, p)], idx2B[(i, q)]] 
   564        64        326.0      5.1      1.7              + f[a,i] * eta2B[idx2B[(i, p)], idx2B[(a, q)]]
   565                                                     )
   566                                           
   567                                             # 2B - 2B
   568                                             # n_a n_b nn_c + nn_a nn_b n_c = n_a n_b + (1 - n_a - n_b) * n_c
   569         1          8.0      8.0      0.0    etaGamma = dot(eta2B, dot(occB_2B, Gamma))
   570         5          4.0      0.8      0.0    for p in range(dim1B):
   571        20         18.0      0.9      0.1      for q in range(dim1B):
   572        48         61.0      1.3      0.3        for i in holes:
   573        32         33.0      1.0      0.2          df[p,q] += 0.5*(
   574        32         52.0      1.6      0.3            etaGamma[idx2B[(i,p)], idx2B[(i,q)]] 
   575        32        103.0      3.2      0.6            + transpose(etaGamma)[idx2B[(i,p)], idx2B[(i,q)]]
   576                                                   )
   577                                           
   578         1          6.0      6.0      0.0    etaGamma = dot(eta2B, dot(occC_2B, Gamma))
   579         5          7.0      1.4      0.0    for p in range(dim1B):
   580        20         19.0      0.9      0.1      for q in range(dim1B):
   581        80         77.0      1.0      0.4        for r in range(dim1B):
   582        64         65.0      1.0      0.3          df[p,q] += 0.5*(
   583        64        112.0      1.8      0.6            etaGamma[idx2B[(r,p)], idx2B[(r,q)]] 
   584        64        210.0      3.3      1.1            + transpose(etaGamma)[idx2B[(r,p)], idx2B[(r,q)]] 
   585                                                   )
   586                                           
   587                                           
   588                                             #############################        
   589                                             # two-body flow equation  
   590         1         12.0     12.0      0.1    dGamma = np.zeros_like(Gamma)
   591                                           
   592                                             # 1B - 2B
   593         5          4.0      0.8      0.0    for p in range(dim1B):
   594        20         20.0      1.0      0.1      for q in range(dim1B):
   595        80         76.0      0.9      0.4        for r in range(dim1B):
   596       320        297.0      0.9      1.6          for s in range(dim1B):
   597      1280       1201.0      0.9      6.4            for t in range(dim1B):
   598      1024       1762.0      1.7      9.4              dGamma[idx2B[(p,q)],idx2B[(r,s)]] += (
   599                                                         eta1B[p,t] * Gamma[idx2B[(t,q)],idx2B[(r,s)]] 
   600                                                         + eta1B[q,t] * Gamma[idx2B[(p,t)],idx2B[(r,s)]] 
   601                                                         - eta1B[t,r] * Gamma[idx2B[(p,q)],idx2B[(t,s)]] 
   602                                                         - eta1B[t,s] * Gamma[idx2B[(p,q)],idx2B[(r,t)]]
   603                                                         - f[p,t] * eta2B[idx2B[(t,q)],idx2B[(r,s)]] 
   604                                                         - f[q,t] * eta2B[idx2B[(p,t)],idx2B[(r,s)]] 
   605                                                         + f[t,r] * eta2B[idx2B[(p,q)],idx2B[(t,s)]] 
   606      1024      10516.0     10.3     56.4                + f[t,s] * eta2B[idx2B[(p,q)],idx2B[(r,t)]]
   607                                                       )
   608                                           
   609                                             
   610                                             # 2B - 2B - particle and hole ladders
   611                                             # eta2B.occB.Gamma
   612         1         13.0     13.0      0.1    etaGamma = dot(eta2B, dot(occB_2B, Gamma))
   613                                           
   614         1         26.0     26.0      0.1    dGamma += 0.5 * (etaGamma + transpose(etaGamma))
   615                                           
   616                                             # 2B - 2B - particle-hole chain
   617                                             
   618                                             # transform matrices to particle-hole representation and calculate 
   619                                             # eta2B_ph.occA_ph.Gamma_ph
   620         1        681.0    681.0      3.7    eta2B_ph = ph_transform_2B(eta2B, bas2B, idx2B, basph2B, idxph2B)
   621         1        668.0    668.0      3.6    Gamma_ph = ph_transform_2B(Gamma, bas2B, idx2B, basph2B, idxph2B)
   622                                           
   623         1          7.0      7.0      0.0    etaGamma_ph = dot(eta2B_ph, dot(occphA_2B, Gamma_ph))
   624                                           
   625                                             # transform back to standard representation
   626         1        652.0    652.0      3.5    etaGamma    = inverse_ph_transform_2B(etaGamma_ph, bas2B, idx2B, basph2B, idxph2B)
   627                                           
   628                                             # commutator / antisymmetrization
   629         1         20.0     20.0      0.1    work = np.zeros_like(etaGamma)
   630        17         15.0      0.9      0.1    for i1, (i,j) in enumerate(bas2B):
   631       272        262.0      1.0      1.4      for i2, (k,l) in enumerate(bas2B):
   632       256        253.0      1.0      1.4        work[i1, i2] -= (
   633                                                   etaGamma[i1, i2] 
   634                                                   - etaGamma[idx2B[(j,i)], i2] 
   635                                                   - etaGamma[i1, idx2B[(l,k)]] 
   636       256        654.0      2.6      3.5          + etaGamma[idx2B[(j,i)], idx2B[(l,k)]]
   637                                                 )
   638         1          1.0      1.0      0.0    etaGamma = work
   639                                           
   640         1          6.0      6.0      0.0    dGamma += etaGamma
   641                                           
   642                                           
   643         1          1.0      1.0      0.0    return dE, df, dGamma

Total time: 2.6e-05 s
File: imsrg_pairing_bench.py
Function: get_operator_from_y at line 649

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   649                                           @profile
   650                                           def get_operator_from_y(y, dim1B, dim2B):
   651                                             
   652                                             # reshape the solution vector into 0B, 1B, 2B pieces
   653         2          2.0      1.0      7.7    ptr = 0
   654         2          2.0      1.0      7.7    zero_body = y[ptr]
   655                                           
   656         2          1.0      0.5      3.8    ptr += 1
   657         2         11.0      5.5     42.3    one_body = reshape(y[ptr:ptr+dim1B*dim1B], (dim1B, dim1B))
   658                                           
   659         2          2.0      1.0      7.7    ptr += dim1B*dim1B
   660         2          6.0      3.0     23.1    two_body = reshape(y[ptr:ptr+dim2B*dim2B], (dim2B, dim2B))
   661                                           
   662         2          2.0      1.0      7.7    return zero_body,one_body,two_body

Total time: 0.000133 s
File: imsrg_pairing_bench.py
Function: pairing_hamiltonian at line 707

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   707                                           @profile
   708                                           def pairing_hamiltonian(delta, g, user_data):
   709         1          1.0      1.0      0.8    bas1B = user_data["bas1B"]
   710         1          0.0      0.0      0.0    bas2B = user_data["bas2B"]
   711         1          1.0      1.0      0.8    idx2B = user_data["idx2B"]
   712                                           
   713         1          1.0      1.0      0.8    dim = len(bas1B)
   714         1          2.0      2.0      1.5    H1B = np.zeros((dim,dim))
   715                                           
   716         5          3.0      0.6      2.3    for i in bas1B:
   717         4         24.0      6.0     18.0      H1B[i,i] = delta*np.floor_divide(i, 2)
   718                                           
   719         1          1.0      1.0      0.8    dim = len(bas2B)
   720         1          1.0      1.0      0.8    H2B = np.zeros((dim, dim))
   721                                           
   722                                             # spin up states have even indices, spin down the next odd index
   723        17         13.0      0.8      9.8    for (i, j) in bas2B:
   724        16         19.0      1.2     14.3      if (i % 2 == 0 and j == i+1):
   725        34         19.0      0.6     14.3        for (k, l) in bas2B:
   726        32         30.0      0.9     22.6          if (k % 2 == 0 and l == k+1):
   727         4          4.0      1.0      3.0            H2B[idx2B[(i,j)],idx2B[(k,l)]] = -0.5*g
   728         4          4.0      1.0      3.0            H2B[idx2B[(j,i)],idx2B[(k,l)]] = 0.5*g
   729         4          4.0      1.0      3.0            H2B[idx2B[(i,j)],idx2B[(l,k)]] = 0.5*g
   730         4          5.0      1.2      3.8            H2B[idx2B[(j,i)],idx2B[(l,k)]] = -0.5*g
   731                                             
   732         1          1.0      1.0      0.8    return H1B, H2B

Total time: 0.000124 s
File: imsrg_pairing_bench.py
Function: normal_order at line 737

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   737                                           @profile
   738                                           def normal_order(H1B, H2B, user_data):
   739         1          0.0      0.0      0.0    bas1B     = user_data["bas1B"]
   740         1          1.0      1.0      0.8    bas2B     = user_data["bas2B"]
   741         1          1.0      1.0      0.8    idx2B     = user_data["idx2B"]
   742         1          0.0      0.0      0.0    particles = user_data["particles"]
   743         1          0.0      0.0      0.0    holes     = user_data["holes"]
   744                                           
   745                                             # 0B part
   746         1          1.0      1.0      0.8    E = 0.0
   747         3          3.0      1.0      2.4    for i in holes:
   748         2          3.0      1.5      2.4      E += H1B[i,i]
   749                                           
   750         3          1.0      0.3      0.8    for i in holes:
   751         6          5.0      0.8      4.0      for j in holes:
   752         4          5.0      1.2      4.0        E += 0.5*H2B[idx2B[(i,j)],idx2B[(i,j)]]  
   753                                           
   754                                             # 1B part
   755         1          1.0      1.0      0.8    f = H1B
   756         5          4.0      0.8      3.2    for i in bas1B:
   757        20         11.0      0.6      8.9      for j in bas1B:
   758        48         38.0      0.8     30.6        for h in holes:
   759        32         49.0      1.5     39.5          f[i,j] += H2B[idx2B[(i,h)],idx2B[(j,h)]]  
   760                                           
   761                                             # 2B part
   762         1          0.0      0.0      0.0    Gamma = H2B
   763                                           
   764         1          1.0      1.0      0.8    return E, f, Gamma

Total time: 0.048708 s
File: imsrg_pairing_bench.py
Function: main at line 831

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   831                                           @profile
   832                                           def main(n_holes):
   833                                             # grab delta and g from the command line
   834                                             # delta      = float(argv[1])
   835                                             # g          = float(argv[2])
   836         1          2.0      2.0      0.0    delta = 1
   837         1          1.0      1.0      0.0    g = 0.5
   838                                             
   839         1          1.0      1.0      0.0    particles  = n_holes
   840                                           
   841                                             # setup shared data
   842         1          1.0      1.0      0.0    dim1B     = n_holes*2
   843                                           
   844                                             # this defines the reference state
   845                                             # 1st state
   846         1          6.0      6.0      0.0    holes = np.arange(particles)
   847         1          3.0      3.0      0.0    particles = np.arange(particles,dim1B)
   848                                           
   849                                             # 2nd state
   850                                             # holes     = [0,1,4,5]
   851                                             # particles = [2,3,6,7]
   852                                           
   853                                             # 3rd state
   854                                             # holes     = [0,1,6,7]
   855                                             # particles = [2,3,4,5]
   856                                           
   857                                             # basis definitions
   858         1          3.0      3.0      0.0    bas1B     = list(range(dim1B))
   859         1         58.0     58.0      0.1    bas2B     = construct_basis_2B(holes, particles)
   860         1         53.0     53.0      0.1    basph2B   = construct_basis_ph2B(holes, particles)
   861                                           
   862         1         27.0     27.0      0.1    idx2B     = construct_index_2B(bas2B)
   863         1         24.0     24.0      0.0    idxph2B   = construct_index_2B(basph2B)
   864                                           
   865                                             # occupation number matrices
   866         1         18.0     18.0      0.0    occ1B     = construct_occupation_1B(bas1B, holes, particles)
   867         1         41.0     41.0      0.1    occA_2B   = construct_occupationA_2B(bas2B, occ1B)
   868         1         45.0     45.0      0.1    occB_2B   = construct_occupationB_2B(bas2B, occ1B)
   869         1         37.0     37.0      0.1    occC_2B   = construct_occupationC_2B(bas2B, occ1B)
   870                                           
   871         1         35.0     35.0      0.1    occphA_2B = construct_occupationA_2B(basph2B, occ1B)
   872                                           
   873                                             # store shared data in a dictionary, so we can avoid passing the basis
   874                                             # lookups etc. as separate parameters all the time
   875                                             user_data  = {
   876         1          1.0      1.0      0.0      "dim1B":      dim1B, 
   877         1          1.0      1.0      0.0      "holes":      holes,
   878         1          1.0      1.0      0.0      "particles":  particles,
   879         1          1.0      1.0      0.0      "bas1B":      bas1B,
   880         1          1.0      1.0      0.0      "bas2B":      bas2B,
   881         1          1.0      1.0      0.0      "basph2B":    basph2B,
   882         1          1.0      1.0      0.0      "idx2B":      idx2B,
   883         1          1.0      1.0      0.0      "idxph2B":    idxph2B,
   884         1          1.0      1.0      0.0      "occ1B":      occ1B,
   885         1          1.0      1.0      0.0      "occA_2B":    occA_2B,
   886         1          1.0      1.0      0.0      "occB_2B":    occB_2B,
   887         1          1.0      1.0      0.0      "occC_2B":    occC_2B,
   888         1          1.0      1.0      0.0      "occphA_2B":  occphA_2B,
   889                                           
   890         1          1.0      1.0      0.0      "eta_norm":   0.0,                # variables for sharing data between ODE solver
   891         1          1.0      1.0      0.0      "dE":         0.0,                # and main routine
   892                                           
   893                                           
   894         1          1.0      1.0      0.0      "calc_eta":   eta_wegner,          # specify the generator (function object)
   895         1          2.0      2.0      0.0      "calc_rhs":   flow_imsrg2         # specify the right-hand side and truncation
   896                                             }
   897                                           
   898                                             # set up initial Hamiltonian
   899         1        211.0    211.0      0.4    H1B, H2B = pairing_hamiltonian(delta, g, user_data)
   900                                             
   901         1        221.0    221.0      0.5    E, f, Gamma = normal_order(H1B, H2B, user_data) 
   902                                           
   903                                             # reshape Hamiltonian into a linear array (initial ODE vector)
   904         1         54.0     54.0      0.1    y0   = np.append([E], np.append(reshape(f, -1), reshape(Gamma, -1)))
   905                                           
   906         1          1.0      1.0      0.0    t = 1
   907         1      47795.0  47795.0     98.1    dy = derivative_wrapper(t, y0, user_data)
   908         1         21.0     21.0      0.0    dE, df, dG = get_operator_from_y(dy, dim1B, dim1B*dim1B)
   909         1         32.0     32.0      0.1    print(dE)

-0.25
Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
    30   76.254 MiB   76.254 MiB   @profile
    31                             def construct_basis_2B(holes, particles):
    32   76.254 MiB    0.000 MiB     basis = []
    33   76.254 MiB    0.000 MiB     for i in holes:
    34   76.254 MiB    0.000 MiB       for j in holes:
    35   76.254 MiB    0.000 MiB         basis.append((i, j)) # hole, hole
    36                             
    37   76.254 MiB    0.000 MiB     for i in holes:
    38   76.254 MiB    0.000 MiB       for a in particles:
    39   76.254 MiB    0.000 MiB         basis.append((i, a)) # hole, particle
    40                             
    41   76.254 MiB    0.000 MiB     for a in particles:
    42   76.254 MiB    0.000 MiB       for i in holes:
    43   76.254 MiB    0.000 MiB         basis.append((a, i)) # particle, hole
    44                             
    45   76.254 MiB    0.000 MiB     for a in particles:
    46   76.254 MiB    0.000 MiB       for b in particles:
    47   76.254 MiB    0.000 MiB         basis.append((a, b)) # particle, particle
    48                             
    49   76.254 MiB    0.000 MiB     return basis


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
    52   76.254 MiB   76.254 MiB   @profile
    53                             def construct_basis_ph2B(holes, particles):
    54   76.254 MiB    0.000 MiB     basis = []
    55   76.254 MiB    0.000 MiB     for i in holes:
    56   76.254 MiB    0.000 MiB       for j in holes:
    57   76.254 MiB    0.000 MiB         basis.append((i, j))
    58                             
    59   76.254 MiB    0.000 MiB     for i in holes:
    60   76.254 MiB    0.000 MiB       for a in particles:
    61   76.254 MiB    0.000 MiB         basis.append((i, a))
    62                             
    63   76.254 MiB    0.000 MiB     for a in particles:
    64   76.254 MiB    0.000 MiB       for i in holes:
    65   76.254 MiB    0.000 MiB         basis.append((a, i))
    66                             
    67   76.254 MiB    0.000 MiB     for a in particles:
    68   76.254 MiB    0.000 MiB       for b in particles:
    69   76.254 MiB    0.000 MiB         basis.append((a, b))
    70                             
    71   76.254 MiB    0.000 MiB     return basis


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
    77   76.254 MiB   76.254 MiB   @profile
    78                             def construct_index_2B(bas2B):
    79   76.254 MiB    0.000 MiB     index = { }
    80   76.254 MiB    0.000 MiB     for i, state in enumerate(bas2B):
    81   76.254 MiB    0.000 MiB       index[state] = i
    82                             
    83   76.254 MiB    0.000 MiB     return index


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
    90   76.445 MiB   76.445 MiB   @profile
    91                             def ph_transform_2B(Gamma, bas2B, idx2B, basph2B, idxph2B):
    92   76.445 MiB    0.000 MiB     dim = len(basph2B)
    93   76.445 MiB    0.000 MiB     Gamma_ph = np.zeros((dim, dim))
    94                             
    95   76.445 MiB    0.000 MiB     for i1, (a,b) in enumerate(basph2B):
    96   76.445 MiB    0.000 MiB       for i2, (c, d) in enumerate(basph2B):
    97   76.445 MiB    0.000 MiB         Gamma_ph[i1, i2] -= Gamma[idx2B[(a,d)], idx2B[(c,b)]]
    98                             
    99   76.445 MiB    0.000 MiB     return Gamma_ph


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   101   76.445 MiB   76.445 MiB   @profile
   102                             def inverse_ph_transform_2B(Gamma_ph, bas2B, idx2B, basph2B, idxph2B):
   103   76.445 MiB    0.000 MiB     dim = len(bas2B)
   104   76.445 MiB    0.000 MiB     Gamma = np.zeros((dim, dim))
   105                             
   106   76.445 MiB    0.000 MiB     for i1, (a,b) in enumerate(bas2B):
   107   76.445 MiB    0.000 MiB       for i2, (c, d) in enumerate(bas2B):
   108   76.445 MiB    0.000 MiB         Gamma[i1, i2] -= Gamma_ph[idxph2B[(a,d)], idxph2B[(c,b)]]
   109                               
   110   76.445 MiB    0.000 MiB     return Gamma


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   115   76.445 MiB   76.445 MiB   @profile
   116                             def commutator(a,b):
   117   76.445 MiB    0.000 MiB     return dot(a,b) - dot(b,a)


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   150   76.254 MiB   76.254 MiB   @profile
   151                             def construct_occupation_1B(bas1B, holes, particles):
   152   76.254 MiB    0.000 MiB     dim = len(bas1B)
   153   76.254 MiB    0.000 MiB     occ = np.zeros(dim)
   154                             
   155   76.254 MiB    0.000 MiB     for i in holes:
   156   76.254 MiB    0.000 MiB       occ[i] = 1.
   157                             
   158   76.254 MiB    0.000 MiB     return occ


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   161   76.254 MiB   76.254 MiB   @profile
   162                             def construct_occupationA_2B(bas2B, occ1B):
   163   76.254 MiB    0.000 MiB     dim = len(bas2B)
   164   76.254 MiB    0.000 MiB     occ = np.zeros((dim,dim))
   165                             
   166   76.254 MiB    0.000 MiB     for i1, (i,j) in enumerate(bas2B):
   167   76.254 MiB    0.000 MiB       occ[i1, i1] = occ1B[i] - occ1B[j]
   168                             
   169   76.254 MiB    0.000 MiB     return occ


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   173   76.254 MiB   76.254 MiB   @profile
   174                             def construct_occupationB_2B(bas2B, occ1B):
   175   76.254 MiB    0.000 MiB     dim = len(bas2B)
   176   76.254 MiB    0.000 MiB     occ = np.zeros((dim,dim))
   177                             
   178   76.254 MiB    0.000 MiB     for i1, (i,j) in enumerate(bas2B):
   179   76.254 MiB    0.000 MiB       occ[i1, i1] = 1. - occ1B[i] - occ1B[j]
   180                             
   181   76.254 MiB    0.000 MiB     return occ


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   184   76.254 MiB   76.254 MiB   @profile
   185                             def construct_occupationC_2B(bas2B, occ1B):
   186   76.254 MiB    0.000 MiB     dim = len(bas2B)
   187   76.254 MiB    0.000 MiB     occ = np.zeros((dim,dim))
   188                             
   189   76.254 MiB    0.000 MiB     for i1, (i,j) in enumerate(bas2B):
   190   76.254 MiB    0.000 MiB       occ[i1, i1] = occ1B[i] * occ1B[j]
   191                             
   192   76.254 MiB    0.000 MiB     return occ


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   382   76.254 MiB   76.254 MiB   @profile
   383                             def eta_wegner(f, Gamma, user_data):
   384                             
   385   76.254 MiB    0.000 MiB     dim1B     = user_data["dim1B"]
   386   76.254 MiB    0.000 MiB     holes     = user_data["holes"]
   387   76.254 MiB    0.000 MiB     particles = user_data["particles"]
   388   76.254 MiB    0.000 MiB     bas2B     = user_data["bas2B"]
   389   76.254 MiB    0.000 MiB     basph2B   = user_data["basph2B"]
   390   76.254 MiB    0.000 MiB     idx2B     = user_data["idx2B"]
   391   76.254 MiB    0.000 MiB     idxph2B   = user_data["idxph2B"]
   392   76.254 MiB    0.000 MiB     occB_2B   = user_data["occB_2B"]
   393   76.254 MiB    0.000 MiB     occC_2B   = user_data["occC_2B"]
   394   76.254 MiB    0.000 MiB     occphA_2B = user_data["occphA_2B"]
   395                             
   396                             
   397                               # split Hamiltonian in diagonal and off-diagonal parts
   398   76.254 MiB    0.000 MiB     fd      = np.zeros_like(f)
   399   76.254 MiB    0.000 MiB     fod     = np.zeros_like(f)
   400   76.254 MiB    0.000 MiB     Gammad  = np.zeros_like(Gamma)
   401   76.254 MiB    0.000 MiB     Gammaod = np.zeros_like(Gamma)
   402                             
   403   76.254 MiB    0.000 MiB     for a in particles:
   404   76.254 MiB    0.000 MiB       for i in holes:
   405   76.254 MiB    0.000 MiB         fod[a, i] = f[a,i]
   406   76.254 MiB    0.000 MiB         fod[i, a] = f[i,a]
   407   76.445 MiB    0.191 MiB     fd = f - fod
   408                             
   409   76.445 MiB    0.000 MiB     for a in particles:
   410   76.445 MiB    0.000 MiB       for b in particles:
   411   76.445 MiB    0.000 MiB         for i in holes:
   412   76.445 MiB    0.000 MiB           for j in holes:
   413   76.445 MiB    0.000 MiB             Gammaod[idx2B[(a,b)], idx2B[(i,j)]] = Gamma[idx2B[(a,b)], idx2B[(i,j)]]
   414   76.445 MiB    0.000 MiB             Gammaod[idx2B[(i,j)], idx2B[(a,b)]] = Gamma[idx2B[(i,j)], idx2B[(a,b)]]
   415   76.445 MiB    0.000 MiB     Gammad = Gamma - Gammaod
   416                             
   417                             
   418                               #############################        
   419                               # one-body flow equation  
   420   76.445 MiB    0.000 MiB     eta1B  = np.zeros_like(f)
   421                             
   422                               # 1B - 1B
   423   76.445 MiB   76.445 MiB     eta1B += commutator(fd, fod)
   424                             
   425                               # 1B - 2B
   426   76.445 MiB    0.000 MiB     for p in range(dim1B):
   427   76.445 MiB    0.000 MiB       for q in range(dim1B):
   428   76.445 MiB    0.000 MiB         for i in holes:
   429   76.445 MiB    0.000 MiB           for a in particles:
   430   76.445 MiB    0.000 MiB             eta1B[p,q] += (
   431                                         fd[i,a]  * Gammaod[idx2B[(a, p)], idx2B[(i, q)]] 
   432                                         - fd[a,i]  * Gammaod[idx2B[(i, p)], idx2B[(a, q)]] 
   433                                         - fod[i,a] * Gammad[idx2B[(a, p)], idx2B[(i, q)]] 
   434   76.445 MiB    0.000 MiB               + fod[a,i] * Gammad[idx2B[(i, p)], idx2B[(a, q)]]
   435                                       )
   436                             
   437                               # 2B - 2B
   438                               # n_a n_b nn_c + nn_a nn_b n_c = n_a n_b + (1 - n_a - n_b) * n_c
   439   76.445 MiB    0.000 MiB     GammaGamma = dot(Gammad, dot(occB_2B, Gammaod))
   440   76.445 MiB    0.000 MiB     for p in range(dim1B):
   441   76.445 MiB    0.000 MiB       for q in range(dim1B):
   442   76.445 MiB    0.000 MiB         for i in holes:
   443   76.445 MiB    0.000 MiB           eta1B[p,q] += (
   444   76.445 MiB    0.000 MiB             0.5*GammaGamma[idx2B[(i,p)], idx2B[(i,q)]] 
   445   76.445 MiB    0.000 MiB             - transpose(GammaGamma)[idx2B[(i,p)], idx2B[(i,q)]]
   446                                     )
   447                             
   448   76.445 MiB    0.000 MiB     GammaGamma = dot(Gammad, dot(occC_2B, Gammaod))
   449   76.445 MiB    0.000 MiB     for p in range(dim1B):
   450   76.445 MiB    0.000 MiB       for q in range(dim1B):
   451   76.445 MiB    0.000 MiB         for r in range(dim1B):
   452   76.445 MiB    0.000 MiB           eta1B[p,q] += (
   453   76.445 MiB    0.000 MiB             0.5*GammaGamma[idx2B[(r,p)], idx2B[(r,q)]] 
   454   76.445 MiB    0.000 MiB             + transpose(GammaGamma)[idx2B[(r,p)], idx2B[(r,q)]] 
   455                                     )
   456                             
   457                             
   458                               #############################        
   459                               # two-body flow equation  
   460   76.445 MiB    0.000 MiB     eta2B = np.zeros_like(Gamma)
   461                             
   462                               # 1B - 2B
   463   76.445 MiB    0.000 MiB     for p in range(dim1B):
   464   76.445 MiB    0.000 MiB       for q in range(dim1B):
   465   76.445 MiB    0.000 MiB         for r in range(dim1B):
   466   76.445 MiB    0.000 MiB           for s in range(dim1B):
   467   76.445 MiB    0.000 MiB             for t in range(dim1B):
   468   76.445 MiB    0.000 MiB               eta2B[idx2B[(p,q)],idx2B[(r,s)]] += (
   469                                           fd[p,t] * Gammaod[idx2B[(t,q)],idx2B[(r,s)]] 
   470                                           + fd[q,t] * Gammaod[idx2B[(p,t)],idx2B[(r,s)]] 
   471                                           - fd[t,r] * Gammaod[idx2B[(p,q)],idx2B[(t,s)]] 
   472                                           - fd[t,s] * Gammaod[idx2B[(p,q)],idx2B[(r,t)]]
   473                                           - fod[p,t] * Gammad[idx2B[(t,q)],idx2B[(r,s)]] 
   474                                           - fod[q,t] * Gammad[idx2B[(p,t)],idx2B[(r,s)]] 
   475                                           + fod[t,r] * Gammad[idx2B[(p,q)],idx2B[(t,s)]] 
   476   76.445 MiB    0.000 MiB                 + fod[t,s] * Gammad[idx2B[(p,q)],idx2B[(r,t)]]
   477                                         )
   478                             
   479                               
   480                               # 2B - 2B - particle and hole ladders
   481                               # Gammad.occB.Gammaod
   482   76.445 MiB    0.000 MiB     GammaGamma = dot(Gammad, dot(occB_2B, Gammaod))
   483                             
   484   76.445 MiB    0.000 MiB     eta2B += 0.5 * (GammaGamma - transpose(GammaGamma))
   485                             
   486                               # 2B - 2B - particle-hole chain
   487                               
   488                               # transform matrices to particle-hole representation and calculate 
   489                               # Gammad_ph.occA_ph.Gammaod_ph
   490   76.445 MiB   76.445 MiB     Gammad_ph = ph_transform_2B(Gammad, bas2B, idx2B, basph2B, idxph2B)
   491   76.445 MiB   76.445 MiB     Gammaod_ph = ph_transform_2B(Gammaod, bas2B, idx2B, basph2B, idxph2B)
   492                             
   493   76.445 MiB    0.000 MiB     GammaGamma_ph = dot(Gammad_ph, dot(occphA_2B, Gammaod_ph))
   494                             
   495                               # transform back to standard representation
   496   76.445 MiB   76.445 MiB     GammaGamma    = inverse_ph_transform_2B(GammaGamma_ph, bas2B, idx2B, basph2B, idxph2B)
   497                             
   498                               # commutator / antisymmetrization
   499   76.445 MiB    0.000 MiB     work = np.zeros_like(GammaGamma)
   500   76.445 MiB    0.000 MiB     for i1, (i,j) in enumerate(bas2B):
   501   76.445 MiB    0.000 MiB       for i2, (k,l) in enumerate(bas2B):
   502   76.445 MiB    0.000 MiB         work[i1, i2] -= (
   503                                     GammaGamma[i1, i2] 
   504                                     - GammaGamma[idx2B[(j,i)], i2] 
   505                                     - GammaGamma[i1, idx2B[(l,k)]] 
   506   76.445 MiB    0.000 MiB           + GammaGamma[idx2B[(j,i)], idx2B[(l,k)]]
   507                                   )
   508   76.445 MiB    0.000 MiB     GammaGamma = work
   509                             
   510   76.445 MiB    0.000 MiB     eta2B += GammaGamma
   511                             
   512                             
   513   76.445 MiB    0.000 MiB     return eta1B, eta2B


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   519   76.445 MiB   76.445 MiB   @profile
   520                             def flow_imsrg2(eta1B, eta2B, f, Gamma, user_data):
   521                             
   522   76.445 MiB    0.000 MiB     dim1B     = user_data["dim1B"]
   523   76.445 MiB    0.000 MiB     holes     = user_data["holes"]
   524   76.445 MiB    0.000 MiB     particles = user_data["particles"]
   525   76.445 MiB    0.000 MiB     bas2B     = user_data["bas2B"]
   526   76.445 MiB    0.000 MiB     idx2B     = user_data["idx2B"]
   527   76.445 MiB    0.000 MiB     basph2B   = user_data["basph2B"]
   528   76.445 MiB    0.000 MiB     idxph2B   = user_data["idxph2B"]
   529   76.445 MiB    0.000 MiB     occB_2B   = user_data["occB_2B"]
   530   76.445 MiB    0.000 MiB     occC_2B   = user_data["occC_2B"]
   531   76.445 MiB    0.000 MiB     occphA_2B = user_data["occphA_2B"]
   532                             
   533                               #############################        
   534                               # zero-body flow equation
   535   76.445 MiB    0.000 MiB     dE = 0.0
   536                             
   537   76.445 MiB    0.000 MiB     for i in holes:
   538   76.445 MiB    0.000 MiB       for a in particles:
   539   76.445 MiB    0.000 MiB         dE += eta1B[i,a] * f[a,i] - eta1B[a,i] * f[i,a]
   540                             
   541   76.445 MiB    0.000 MiB     for i in holes:
   542   76.445 MiB    0.000 MiB       for j in holes:
   543   76.445 MiB    0.000 MiB         for a in particles:
   544   76.445 MiB    0.000 MiB           for b in particles:
   545   76.445 MiB    0.000 MiB             dE += 0.5 * eta2B[idx2B[(i,j)], idx2B[(a,b)]] * Gamma[idx2B[(a,b)], idx2B[(i,j)]]
   546                             
   547                             
   548                               #############################        
   549                               # one-body flow equation  
   550   76.445 MiB    0.000 MiB     df  = np.zeros_like(f)
   551                             
   552                               # 1B - 1B
   553   76.445 MiB   76.445 MiB     df += commutator(eta1B, f)
   554                             
   555                               # 1B - 2B
   556   76.445 MiB    0.000 MiB     for p in range(dim1B):
   557   76.445 MiB    0.000 MiB       for q in range(dim1B):
   558   76.445 MiB    0.000 MiB         for i in holes:
   559   76.445 MiB    0.000 MiB           for a in particles:
   560   76.445 MiB    0.000 MiB             df[p,q] += (
   561                                         eta1B[i,a] * Gamma[idx2B[(a, p)], idx2B[(i, q)]] 
   562                                         - eta1B[a,i] * Gamma[idx2B[(i, p)], idx2B[(a, q)]] 
   563                                         - f[i,a] * eta2B[idx2B[(a, p)], idx2B[(i, q)]] 
   564   76.445 MiB    0.000 MiB               + f[a,i] * eta2B[idx2B[(i, p)], idx2B[(a, q)]]
   565                                       )
   566                             
   567                               # 2B - 2B
   568                               # n_a n_b nn_c + nn_a nn_b n_c = n_a n_b + (1 - n_a - n_b) * n_c
   569   76.445 MiB    0.000 MiB     etaGamma = dot(eta2B, dot(occB_2B, Gamma))
   570   76.445 MiB    0.000 MiB     for p in range(dim1B):
   571   76.445 MiB    0.000 MiB       for q in range(dim1B):
   572   76.445 MiB    0.000 MiB         for i in holes:
   573   76.445 MiB    0.000 MiB           df[p,q] += 0.5*(
   574   76.445 MiB    0.000 MiB             etaGamma[idx2B[(i,p)], idx2B[(i,q)]] 
   575   76.445 MiB    0.000 MiB             + transpose(etaGamma)[idx2B[(i,p)], idx2B[(i,q)]]
   576                                     )
   577                             
   578   76.445 MiB    0.000 MiB     etaGamma = dot(eta2B, dot(occC_2B, Gamma))
   579   76.445 MiB    0.000 MiB     for p in range(dim1B):
   580   76.445 MiB    0.000 MiB       for q in range(dim1B):
   581   76.445 MiB    0.000 MiB         for r in range(dim1B):
   582   76.445 MiB    0.000 MiB           df[p,q] += 0.5*(
   583   76.445 MiB    0.000 MiB             etaGamma[idx2B[(r,p)], idx2B[(r,q)]] 
   584   76.445 MiB    0.000 MiB             + transpose(etaGamma)[idx2B[(r,p)], idx2B[(r,q)]] 
   585                                     )
   586                             
   587                             
   588                               #############################        
   589                               # two-body flow equation  
   590   76.445 MiB    0.000 MiB     dGamma = np.zeros_like(Gamma)
   591                             
   592                               # 1B - 2B
   593   76.445 MiB    0.000 MiB     for p in range(dim1B):
   594   76.445 MiB    0.000 MiB       for q in range(dim1B):
   595   76.445 MiB    0.000 MiB         for r in range(dim1B):
   596   76.445 MiB    0.000 MiB           for s in range(dim1B):
   597   76.445 MiB    0.000 MiB             for t in range(dim1B):
   598   76.445 MiB    0.000 MiB               dGamma[idx2B[(p,q)],idx2B[(r,s)]] += (
   599                                           eta1B[p,t] * Gamma[idx2B[(t,q)],idx2B[(r,s)]] 
   600                                           + eta1B[q,t] * Gamma[idx2B[(p,t)],idx2B[(r,s)]] 
   601                                           - eta1B[t,r] * Gamma[idx2B[(p,q)],idx2B[(t,s)]] 
   602                                           - eta1B[t,s] * Gamma[idx2B[(p,q)],idx2B[(r,t)]]
   603                                           - f[p,t] * eta2B[idx2B[(t,q)],idx2B[(r,s)]] 
   604                                           - f[q,t] * eta2B[idx2B[(p,t)],idx2B[(r,s)]] 
   605                                           + f[t,r] * eta2B[idx2B[(p,q)],idx2B[(t,s)]] 
   606   76.445 MiB    0.000 MiB                 + f[t,s] * eta2B[idx2B[(p,q)],idx2B[(r,t)]]
   607                                         )
   608                             
   609                               
   610                               # 2B - 2B - particle and hole ladders
   611                               # eta2B.occB.Gamma
   612   76.445 MiB    0.000 MiB     etaGamma = dot(eta2B, dot(occB_2B, Gamma))
   613                             
   614   76.445 MiB    0.000 MiB     dGamma += 0.5 * (etaGamma + transpose(etaGamma))
   615                             
   616                               # 2B - 2B - particle-hole chain
   617                               
   618                               # transform matrices to particle-hole representation and calculate 
   619                               # eta2B_ph.occA_ph.Gamma_ph
   620   76.445 MiB   76.445 MiB     eta2B_ph = ph_transform_2B(eta2B, bas2B, idx2B, basph2B, idxph2B)
   621   76.445 MiB   76.445 MiB     Gamma_ph = ph_transform_2B(Gamma, bas2B, idx2B, basph2B, idxph2B)
   622                             
   623   76.445 MiB    0.000 MiB     etaGamma_ph = dot(eta2B_ph, dot(occphA_2B, Gamma_ph))
   624                             
   625                               # transform back to standard representation
   626   76.445 MiB   76.445 MiB     etaGamma    = inverse_ph_transform_2B(etaGamma_ph, bas2B, idx2B, basph2B, idxph2B)
   627                             
   628                               # commutator / antisymmetrization
   629   76.445 MiB    0.000 MiB     work = np.zeros_like(etaGamma)
   630   76.445 MiB    0.000 MiB     for i1, (i,j) in enumerate(bas2B):
   631   76.445 MiB    0.000 MiB       for i2, (k,l) in enumerate(bas2B):
   632   76.445 MiB    0.000 MiB         work[i1, i2] -= (
   633                                     etaGamma[i1, i2] 
   634                                     - etaGamma[idx2B[(j,i)], i2] 
   635                                     - etaGamma[i1, idx2B[(l,k)]] 
   636   76.445 MiB    0.000 MiB           + etaGamma[idx2B[(j,i)], idx2B[(l,k)]]
   637                                   )
   638   76.445 MiB    0.000 MiB     etaGamma = work
   639                             
   640   76.445 MiB    0.000 MiB     dGamma += etaGamma
   641                             
   642                             
   643   76.445 MiB    0.000 MiB     return dE, df, dGamma


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   649   76.445 MiB   76.445 MiB   @profile
   650                             def get_operator_from_y(y, dim1B, dim2B):
   651                               
   652                               # reshape the solution vector into 0B, 1B, 2B pieces
   653   76.445 MiB    0.000 MiB     ptr = 0
   654   76.445 MiB    0.000 MiB     zero_body = y[ptr]
   655                             
   656   76.445 MiB    0.000 MiB     ptr += 1
   657   76.445 MiB    0.000 MiB     one_body = reshape(y[ptr:ptr+dim1B*dim1B], (dim1B, dim1B))
   658                             
   659   76.445 MiB    0.000 MiB     ptr += dim1B*dim1B
   660   76.445 MiB    0.000 MiB     two_body = reshape(y[ptr:ptr+dim2B*dim2B], (dim2B, dim2B))
   661                             
   662   76.445 MiB    0.000 MiB     return zero_body,one_body,two_body


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   707   76.254 MiB   76.254 MiB   @profile
   708                             def pairing_hamiltonian(delta, g, user_data):
   709   76.254 MiB    0.000 MiB     bas1B = user_data["bas1B"]
   710   76.254 MiB    0.000 MiB     bas2B = user_data["bas2B"]
   711   76.254 MiB    0.000 MiB     idx2B = user_data["idx2B"]
   712                             
   713   76.254 MiB    0.000 MiB     dim = len(bas1B)
   714   76.254 MiB    0.000 MiB     H1B = np.zeros((dim,dim))
   715                             
   716   76.254 MiB    0.000 MiB     for i in bas1B:
   717   76.254 MiB    0.000 MiB       H1B[i,i] = delta*np.floor_divide(i, 2)
   718                             
   719   76.254 MiB    0.000 MiB     dim = len(bas2B)
   720   76.254 MiB    0.000 MiB     H2B = np.zeros((dim, dim))
   721                             
   722                               # spin up states have even indices, spin down the next odd index
   723   76.254 MiB    0.000 MiB     for (i, j) in bas2B:
   724   76.254 MiB    0.000 MiB       if (i % 2 == 0 and j == i+1):
   725   76.254 MiB    0.000 MiB         for (k, l) in bas2B:
   726   76.254 MiB    0.000 MiB           if (k % 2 == 0 and l == k+1):
   727   76.254 MiB    0.000 MiB             H2B[idx2B[(i,j)],idx2B[(k,l)]] = -0.5*g
   728   76.254 MiB    0.000 MiB             H2B[idx2B[(j,i)],idx2B[(k,l)]] = 0.5*g
   729   76.254 MiB    0.000 MiB             H2B[idx2B[(i,j)],idx2B[(l,k)]] = 0.5*g
   730   76.254 MiB    0.000 MiB             H2B[idx2B[(j,i)],idx2B[(l,k)]] = -0.5*g
   731                               
   732   76.254 MiB    0.000 MiB     return H1B, H2B


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   737   76.254 MiB   76.254 MiB   @profile
   738                             def normal_order(H1B, H2B, user_data):
   739   76.254 MiB    0.000 MiB     bas1B     = user_data["bas1B"]
   740   76.254 MiB    0.000 MiB     bas2B     = user_data["bas2B"]
   741   76.254 MiB    0.000 MiB     idx2B     = user_data["idx2B"]
   742   76.254 MiB    0.000 MiB     particles = user_data["particles"]
   743   76.254 MiB    0.000 MiB     holes     = user_data["holes"]
   744                             
   745                               # 0B part
   746   76.254 MiB    0.000 MiB     E = 0.0
   747   76.254 MiB    0.000 MiB     for i in holes:
   748   76.254 MiB    0.000 MiB       E += H1B[i,i]
   749                             
   750   76.254 MiB    0.000 MiB     for i in holes:
   751   76.254 MiB    0.000 MiB       for j in holes:
   752   76.254 MiB    0.000 MiB         E += 0.5*H2B[idx2B[(i,j)],idx2B[(i,j)]]  
   753                             
   754                               # 1B part
   755   76.254 MiB    0.000 MiB     f = H1B
   756   76.254 MiB    0.000 MiB     for i in bas1B:
   757   76.254 MiB    0.000 MiB       for j in bas1B:
   758   76.254 MiB    0.000 MiB         for h in holes:
   759   76.254 MiB    0.000 MiB           f[i,j] += H2B[idx2B[(i,h)],idx2B[(j,h)]]  
   760                             
   761                               # 2B part
   762   76.254 MiB    0.000 MiB     Gamma = H2B
   763                             
   764   76.254 MiB    0.000 MiB     return E, f, Gamma


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   831   76.254 MiB   76.254 MiB   @profile
   832                             def main(n_holes):
   833                               # grab delta and g from the command line
   834                               # delta      = float(argv[1])
   835                               # g          = float(argv[2])
   836   76.254 MiB    0.000 MiB     delta = 1
   837   76.254 MiB    0.000 MiB     g = 0.5
   838                               
   839   76.254 MiB    0.000 MiB     particles  = n_holes
   840                             
   841                               # setup shared data
   842   76.254 MiB    0.000 MiB     dim1B     = n_holes*2
   843                             
   844                               # this defines the reference state
   845                               # 1st state
   846   76.254 MiB    0.000 MiB     holes = np.arange(particles)
   847   76.254 MiB    0.000 MiB     particles = np.arange(particles,dim1B)
   848                             
   849                               # 2nd state
   850                               # holes     = [0,1,4,5]
   851                               # particles = [2,3,6,7]
   852                             
   853                               # 3rd state
   854                               # holes     = [0,1,6,7]
   855                               # particles = [2,3,4,5]
   856                             
   857                               # basis definitions
   858   76.254 MiB    0.000 MiB     bas1B     = list(range(dim1B))
   859   76.254 MiB   76.254 MiB     bas2B     = construct_basis_2B(holes, particles)
   860   76.254 MiB   76.254 MiB     basph2B   = construct_basis_ph2B(holes, particles)
   861                             
   862   76.254 MiB   76.254 MiB     idx2B     = construct_index_2B(bas2B)
   863   76.254 MiB   76.254 MiB     idxph2B   = construct_index_2B(basph2B)
   864                             
   865                               # occupation number matrices
   866   76.254 MiB   76.254 MiB     occ1B     = construct_occupation_1B(bas1B, holes, particles)
   867   76.254 MiB   76.254 MiB     occA_2B   = construct_occupationA_2B(bas2B, occ1B)
   868   76.254 MiB   76.254 MiB     occB_2B   = construct_occupationB_2B(bas2B, occ1B)
   869   76.254 MiB   76.254 MiB     occC_2B   = construct_occupationC_2B(bas2B, occ1B)
   870                             
   871   76.254 MiB   76.254 MiB     occphA_2B = construct_occupationA_2B(basph2B, occ1B)
   872                             
   873                               # store shared data in a dictionary, so we can avoid passing the basis
   874                               # lookups etc. as separate parameters all the time
   875                               user_data  = {
   876   76.254 MiB    0.000 MiB       "dim1B":      dim1B, 
   877   76.254 MiB    0.000 MiB       "holes":      holes,
   878   76.254 MiB    0.000 MiB       "particles":  particles,
   879   76.254 MiB    0.000 MiB       "bas1B":      bas1B,
   880   76.254 MiB    0.000 MiB       "bas2B":      bas2B,
   881   76.254 MiB    0.000 MiB       "basph2B":    basph2B,
   882   76.254 MiB    0.000 MiB       "idx2B":      idx2B,
   883   76.254 MiB    0.000 MiB       "idxph2B":    idxph2B,
   884   76.254 MiB    0.000 MiB       "occ1B":      occ1B,
   885   76.254 MiB    0.000 MiB       "occA_2B":    occA_2B,
   886   76.254 MiB    0.000 MiB       "occB_2B":    occB_2B,
   887   76.254 MiB    0.000 MiB       "occC_2B":    occC_2B,
   888   76.254 MiB    0.000 MiB       "occphA_2B":  occphA_2B,
   889                             
   890   76.254 MiB    0.000 MiB       "eta_norm":   0.0,                # variables for sharing data between ODE solver
   891   76.254 MiB    0.000 MiB       "dE":         0.0,                # and main routine
   892                             
   893                             
   894   76.254 MiB    0.000 MiB       "calc_eta":   eta_wegner,          # specify the generator (function object)
   895   76.254 MiB    0.000 MiB       "calc_rhs":   flow_imsrg2         # specify the right-hand side and truncation
   896                               }
   897                             
   898                               # set up initial Hamiltonian
   899   76.254 MiB   76.254 MiB     H1B, H2B = pairing_hamiltonian(delta, g, user_data)
   900                               
   901   76.254 MiB   76.254 MiB     E, f, Gamma = normal_order(H1B, H2B, user_data) 
   902                             
   903                               # reshape Hamiltonian into a linear array (initial ODE vector)
   904   76.254 MiB    0.000 MiB     y0   = np.append([E], np.append(reshape(f, -1), reshape(Gamma, -1)))
   905                             
   906   76.254 MiB    0.000 MiB     t = 1
   907   76.445 MiB   76.445 MiB     dy = derivative_wrapper(t, y0, user_data)
   908   76.445 MiB   76.445 MiB     dE, df, dG = get_operator_from_y(dy, dim1B, dim1B*dim1B)
   909   76.445 MiB    0.000 MiB     print(dE)


---------------------------------------------

Executing NP on n_holes=4 ---------------------------
-1.75
Wrote profile results to imsrg_pairing_bench.py.lprof
Timer unit: 1e-06 s

Total time: 8.6e-05 s
File: imsrg_pairing_bench.py
Function: construct_basis_2B at line 30

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    30                                           @profile
    31                                           def construct_basis_2B(holes, particles):
    32         1          1.0      1.0      1.2    basis = []
    33         5          3.0      0.6      3.5    for i in holes:
    34        20         13.0      0.7     15.1      for j in holes:
    35        16          8.0      0.5      9.3        basis.append((i, j)) # hole, hole
    36                                           
    37         5          1.0      0.2      1.2    for i in holes:
    38        20          8.0      0.4      9.3      for a in particles:
    39        16          6.0      0.4      7.0        basis.append((i, a)) # hole, particle
    40                                           
    41         5          2.0      0.4      2.3    for a in particles:
    42        20         13.0      0.7     15.1      for i in holes:
    43        16          7.0      0.4      8.1        basis.append((a, i)) # particle, hole
    44                                           
    45         5          3.0      0.6      3.5    for a in particles:
    46        20         12.0      0.6     14.0      for b in particles:
    47        16          9.0      0.6     10.5        basis.append((a, b)) # particle, particle
    48                                           
    49         1          0.0      0.0      0.0    return basis

Total time: 8.9e-05 s
File: imsrg_pairing_bench.py
Function: construct_basis_ph2B at line 52

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    52                                           @profile
    53                                           def construct_basis_ph2B(holes, particles):
    54         1          1.0      1.0      1.1    basis = []
    55         5          4.0      0.8      4.5    for i in holes:
    56        20         13.0      0.7     14.6      for j in holes:
    57        16          7.0      0.4      7.9        basis.append((i, j))
    58                                           
    59         5          1.0      0.2      1.1    for i in holes:
    60        20         12.0      0.6     13.5      for a in particles:
    61        16          7.0      0.4      7.9        basis.append((i, a))
    62                                           
    63         5          5.0      1.0      5.6    for a in particles:
    64        20         13.0      0.7     14.6      for i in holes:
    65        16          7.0      0.4      7.9        basis.append((a, i))
    66                                           
    67         5          1.0      0.2      1.1    for a in particles:
    68        20         11.0      0.6     12.4      for b in particles:
    69        16          6.0      0.4      6.7        basis.append((a, b))
    70                                           
    71         1          1.0      1.0      1.1    return basis

Total time: 9e-05 s
File: imsrg_pairing_bench.py
Function: construct_index_2B at line 77

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    77                                           @profile
    78                                           def construct_index_2B(bas2B):
    79         2          1.0      0.5      1.1    index = { }
    80       130         40.0      0.3     44.4    for i, state in enumerate(bas2B):
    81       128         49.0      0.4     54.4      index[state] = i
    82                                           
    83         2          0.0      0.0      0.0    return index

Total time: 0.032354 s
File: imsrg_pairing_bench.py
Function: ph_transform_2B at line 90

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    90                                           @profile
    91                                           def ph_transform_2B(Gamma, bas2B, idx2B, basph2B, idxph2B):
    92         4          5.0      1.2      0.0    dim = len(basph2B)
    93         4         28.0      7.0      0.1    Gamma_ph = np.zeros((dim, dim))
    94                                           
    95       260        143.0      0.6      0.4    for i1, (a,b) in enumerate(basph2B):
    96     16640       8885.0      0.5     27.5      for i2, (c, d) in enumerate(basph2B):
    97     16384      23292.0      1.4     72.0        Gamma_ph[i1, i2] -= Gamma[idx2B[(a,d)], idx2B[(c,b)]]
    98                                           
    99         4          1.0      0.2      0.0    return Gamma_ph

Total time: 0.013529 s
File: imsrg_pairing_bench.py
Function: inverse_ph_transform_2B at line 101

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   101                                           @profile
   102                                           def inverse_ph_transform_2B(Gamma_ph, bas2B, idx2B, basph2B, idxph2B):
   103         2          2.0      1.0      0.0    dim = len(bas2B)
   104         2         10.0      5.0      0.1    Gamma = np.zeros((dim, dim))
   105                                           
   106       130         73.0      0.6      0.5    for i1, (a,b) in enumerate(bas2B):
   107      8320       3757.0      0.5     27.8      for i2, (c, d) in enumerate(bas2B):
   108      8192       9685.0      1.2     71.6        Gamma[i1, i2] -= Gamma_ph[idxph2B[(a,d)], idxph2B[(c,b)]]
   109                                             
   110         2          2.0      1.0      0.0    return Gamma

Total time: 4.4e-05 s
File: imsrg_pairing_bench.py
Function: commutator at line 115

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   115                                           @profile
   116                                           def commutator(a,b):
   117         2         44.0     22.0    100.0    return dot(a,b) - dot(b,a)

Total time: 1.1e-05 s
File: imsrg_pairing_bench.py
Function: construct_occupation_1B at line 150

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   150                                           @profile
   151                                           def construct_occupation_1B(bas1B, holes, particles):
   152         1          1.0      1.0      9.1    dim = len(bas1B)
   153         1          5.0      5.0     45.5    occ = np.zeros(dim)
   154                                           
   155         5          3.0      0.6     27.3    for i in holes:
   156         4          2.0      0.5     18.2      occ[i] = 1.
   157                                           
   158         1          0.0      0.0      0.0    return occ

Total time: 0.000174 s
File: imsrg_pairing_bench.py
Function: construct_occupationA_2B at line 161

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   161                                           @profile
   162                                           def construct_occupationA_2B(bas2B, occ1B):
   163         2          2.0      1.0      1.1    dim = len(bas2B)
   164         2         24.0     12.0     13.8    occ = np.zeros((dim,dim))
   165                                           
   166       130         43.0      0.3     24.7    for i1, (i,j) in enumerate(bas2B):
   167       128        104.0      0.8     59.8      occ[i1, i1] = occ1B[i] - occ1B[j]
   168                                           
   169         2          1.0      0.5      0.6    return occ

Total time: 5.3e-05 s
File: imsrg_pairing_bench.py
Function: construct_occupationB_2B at line 173

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   173                                           @profile
   174                                           def construct_occupationB_2B(bas2B, occ1B):
   175         1          1.0      1.0      1.9    dim = len(bas2B)
   176         1         11.0     11.0     20.8    occ = np.zeros((dim,dim))
   177                                           
   178        65          1.0      0.0      1.9    for i1, (i,j) in enumerate(bas2B):
   179        64         39.0      0.6     73.6      occ[i1, i1] = 1. - occ1B[i] - occ1B[j]
   180                                           
   181         1          1.0      1.0      1.9    return occ

Total time: 8.8e-05 s
File: imsrg_pairing_bench.py
Function: construct_occupationC_2B at line 184

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   184                                           @profile
   185                                           def construct_occupationC_2B(bas2B, occ1B):
   186         1          0.0      0.0      0.0    dim = len(bas2B)
   187         1         13.0     13.0     14.8    occ = np.zeros((dim,dim))
   188                                           
   189        65         25.0      0.4     28.4    for i1, (i,j) in enumerate(bas2B):
   190        64         50.0      0.8     56.8      occ[i1, i1] = occ1B[i] * occ1B[j]
   191                                           
   192         1          0.0      0.0      0.0    return occ

Total time: 0.546309 s
File: imsrg_pairing_bench.py
Function: eta_wegner at line 382

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   382                                           @profile
   383                                           def eta_wegner(f, Gamma, user_data):
   384                                           
   385         1          1.0      1.0      0.0    dim1B     = user_data["dim1B"]
   386         1          0.0      0.0      0.0    holes     = user_data["holes"]
   387         1          0.0      0.0      0.0    particles = user_data["particles"]
   388         1          1.0      1.0      0.0    bas2B     = user_data["bas2B"]
   389         1          1.0      1.0      0.0    basph2B   = user_data["basph2B"]
   390         1          1.0      1.0      0.0    idx2B     = user_data["idx2B"]
   391         1          1.0      1.0      0.0    idxph2B   = user_data["idxph2B"]
   392         1          1.0      1.0      0.0    occB_2B   = user_data["occB_2B"]
   393         1          0.0      0.0      0.0    occC_2B   = user_data["occC_2B"]
   394         1          1.0      1.0      0.0    occphA_2B = user_data["occphA_2B"]
   395                                           
   396                                           
   397                                             # split Hamiltonian in diagonal and off-diagonal parts
   398         1         14.0     14.0      0.0    fd      = np.zeros_like(f)
   399         1          6.0      6.0      0.0    fod     = np.zeros_like(f)
   400         1         18.0     18.0      0.0    Gammad  = np.zeros_like(Gamma)
   401         1         16.0     16.0      0.0    Gammaod = np.zeros_like(Gamma)
   402                                           
   403         5          5.0      1.0      0.0    for a in particles:
   404        20         20.0      1.0      0.0      for i in holes:
   405        16         19.0      1.2      0.0        fod[a, i] = f[a,i]
   406        16         19.0      1.2      0.0        fod[i, a] = f[i,a]
   407         1          6.0      6.0      0.0    fd = f - fod
   408                                           
   409         5          5.0      1.0      0.0    for a in particles:
   410        20         19.0      0.9      0.0      for b in particles:
   411        80         73.0      0.9      0.0        for i in holes:
   412       320        323.0      1.0      0.1          for j in holes:
   413       256        461.0      1.8      0.1            Gammaod[idx2B[(a,b)], idx2B[(i,j)]] = Gamma[idx2B[(a,b)], idx2B[(i,j)]]
   414       256        461.0      1.8      0.1            Gammaod[idx2B[(i,j)], idx2B[(a,b)]] = Gamma[idx2B[(i,j)], idx2B[(a,b)]]
   415         1         21.0     21.0      0.0    Gammad = Gamma - Gammaod
   416                                           
   417                                           
   418                                             #############################        
   419                                             # one-body flow equation  
   420         1         13.0     13.0      0.0    eta1B  = np.zeros_like(f)
   421                                           
   422                                             # 1B - 1B
   423         1         48.0     48.0      0.0    eta1B += commutator(fd, fod)
   424                                           
   425                                             # 1B - 2B
   426         9         11.0      1.2      0.0    for p in range(dim1B):
   427        72         57.0      0.8      0.0      for q in range(dim1B):
   428       320        331.0      1.0      0.1        for i in holes:
   429      1280       1367.0      1.1      0.3          for a in particles:
   430      1024       1030.0      1.0      0.2            eta1B[p,q] += (
   431                                                       fd[i,a]  * Gammaod[idx2B[(a, p)], idx2B[(i, q)]] 
   432                                                       - fd[a,i]  * Gammaod[idx2B[(i, p)], idx2B[(a, q)]] 
   433                                                       - fod[i,a] * Gammad[idx2B[(a, p)], idx2B[(i, q)]] 
   434      1024       5605.0      5.5      1.0              + fod[a,i] * Gammad[idx2B[(i, p)], idx2B[(a, q)]]
   435                                                     )
   436                                           
   437                                             # 2B - 2B
   438                                             # n_a n_b nn_c + nn_a nn_b n_c = n_a n_b + (1 - n_a - n_b) * n_c
   439         1         88.0     88.0      0.0    GammaGamma = dot(Gammad, dot(occB_2B, Gammaod))
   440         9          7.0      0.8      0.0    for p in range(dim1B):
   441        72         61.0      0.8      0.0      for q in range(dim1B):
   442       320        330.0      1.0      0.1        for i in holes:
   443       256        240.0      0.9      0.0          eta1B[p,q] += (
   444       256        402.0      1.6      0.1            0.5*GammaGamma[idx2B[(i,p)], idx2B[(i,q)]] 
   445       256        751.0      2.9      0.1            - transpose(GammaGamma)[idx2B[(i,p)], idx2B[(i,q)]]
   446                                                   )
   447                                           
   448         1         77.0     77.0      0.0    GammaGamma = dot(Gammad, dot(occC_2B, Gammaod))
   449         9          8.0      0.9      0.0    for p in range(dim1B):
   450        72         71.0      1.0      0.0      for q in range(dim1B):
   451       576        517.0      0.9      0.1        for r in range(dim1B):
   452       512        522.0      1.0      0.1          eta1B[p,q] += (
   453       512        973.0      1.9      0.2            0.5*GammaGamma[idx2B[(r,p)], idx2B[(r,q)]] 
   454       512       1663.0      3.2      0.3            + transpose(GammaGamma)[idx2B[(r,p)], idx2B[(r,q)]] 
   455                                                   )
   456                                           
   457                                           
   458                                             #############################        
   459                                             # two-body flow equation  
   460         1         14.0     14.0      0.0    eta2B = np.zeros_like(Gamma)
   461                                           
   462                                             # 1B - 2B
   463         9          8.0      0.9      0.0    for p in range(dim1B):
   464        72         74.0      1.0      0.0      for q in range(dim1B):
   465       576        572.0      1.0      0.1        for r in range(dim1B):
   466      4608       4709.0      1.0      0.9          for s in range(dim1B):
   467     36864      39629.0      1.1      7.3            for t in range(dim1B):
   468     32768      64771.0      2.0     11.9              eta2B[idx2B[(p,q)],idx2B[(r,s)]] += (
   469                                                         fd[p,t] * Gammaod[idx2B[(t,q)],idx2B[(r,s)]] 
   470                                                         + fd[q,t] * Gammaod[idx2B[(p,t)],idx2B[(r,s)]] 
   471                                                         - fd[t,r] * Gammaod[idx2B[(p,q)],idx2B[(t,s)]] 
   472                                                         - fd[t,s] * Gammaod[idx2B[(p,q)],idx2B[(r,t)]]
   473                                                         - fod[p,t] * Gammad[idx2B[(t,q)],idx2B[(r,s)]] 
   474                                                         - fod[q,t] * Gammad[idx2B[(p,t)],idx2B[(r,s)]] 
   475                                                         + fod[t,r] * Gammad[idx2B[(p,q)],idx2B[(t,s)]] 
   476     32768     372520.0     11.4     68.2                + fod[t,s] * Gammad[idx2B[(p,q)],idx2B[(r,t)]]
   477                                                       )
   478                                           
   479                                             
   480                                             # 2B - 2B - particle and hole ladders
   481                                             # Gammad.occB.Gammaod
   482         1        102.0    102.0      0.0    GammaGamma = dot(Gammad, dot(occB_2B, Gammaod))
   483                                           
   484         1         50.0     50.0      0.0    eta2B += 0.5 * (GammaGamma - transpose(GammaGamma))
   485                                           
   486                                             # 2B - 2B - particle-hole chain
   487                                             
   488                                             # transform matrices to particle-hole representation and calculate 
   489                                             # Gammad_ph.occA_ph.Gammaod_ph
   490         1      10236.0  10236.0      1.9    Gammad_ph = ph_transform_2B(Gammad, bas2B, idx2B, basph2B, idxph2B)
   491         1      10291.0  10291.0      1.9    Gammaod_ph = ph_transform_2B(Gammaod, bas2B, idx2B, basph2B, idxph2B)
   492                                           
   493         1         84.0     84.0      0.0    GammaGamma_ph = dot(Gammad_ph, dot(occphA_2B, Gammaod_ph))
   494                                           
   495                                             # transform back to standard representation
   496         1       9776.0   9776.0      1.8    GammaGamma    = inverse_ph_transform_2B(GammaGamma_ph, bas2B, idx2B, basph2B, idxph2B)
   497                                           
   498                                             # commutator / antisymmetrization
   499         1         23.0     23.0      0.0    work = np.zeros_like(GammaGamma)
   500        65         56.0      0.9      0.0    for i1, (i,j) in enumerate(bas2B):
   501      4160       3623.0      0.9      0.7      for i2, (k,l) in enumerate(bas2B):
   502      4096       3876.0      0.9      0.7        work[i1, i2] -= (
   503                                                   GammaGamma[i1, i2] 
   504                                                   - GammaGamma[idx2B[(j,i)], i2] 
   505                                                   - GammaGamma[i1, idx2B[(l,k)]] 
   506      4096      10219.0      2.5      1.9          + GammaGamma[idx2B[(j,i)], idx2B[(l,k)]]
   507                                                 )
   508         1          1.0      1.0      0.0    GammaGamma = work
   509                                           
   510         1          9.0      9.0      0.0    eta2B += GammaGamma
   511                                           
   512                                           
   513         1          1.0      1.0      0.0    return eta1B, eta2B

Total time: 0.588562 s
File: imsrg_pairing_bench.py
Function: flow_imsrg2 at line 519

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   519                                           @profile
   520                                           def flow_imsrg2(eta1B, eta2B, f, Gamma, user_data):
   521                                           
   522         1          2.0      2.0      0.0    dim1B     = user_data["dim1B"]
   523         1          2.0      2.0      0.0    holes     = user_data["holes"]
   524         1          1.0      1.0      0.0    particles = user_data["particles"]
   525         1          1.0      1.0      0.0    bas2B     = user_data["bas2B"]
   526         1          1.0      1.0      0.0    idx2B     = user_data["idx2B"]
   527         1          0.0      0.0      0.0    basph2B   = user_data["basph2B"]
   528         1          1.0      1.0      0.0    idxph2B   = user_data["idxph2B"]
   529         1          0.0      0.0      0.0    occB_2B   = user_data["occB_2B"]
   530         1          1.0      1.0      0.0    occC_2B   = user_data["occC_2B"]
   531         1          1.0      1.0      0.0    occphA_2B = user_data["occphA_2B"]
   532                                           
   533                                             #############################        
   534                                             # zero-body flow equation
   535         1          0.0      0.0      0.0    dE = 0.0
   536                                           
   537         5          5.0      1.0      0.0    for i in holes:
   538        20         23.0      1.1      0.0      for a in particles:
   539        16         32.0      2.0      0.0        dE += eta1B[i,a] * f[a,i] - eta1B[a,i] * f[i,a]
   540                                           
   541         5          6.0      1.2      0.0    for i in holes:
   542        20         19.0      0.9      0.0      for j in holes:
   543        80         71.0      0.9      0.0        for a in particles:
   544       320        297.0      0.9      0.1          for b in particles:
   545       256        504.0      2.0      0.1            dE += 0.5 * eta2B[idx2B[(i,j)], idx2B[(a,b)]] * Gamma[idx2B[(a,b)], idx2B[(i,j)]]
   546                                           
   547                                           
   548                                             #############################        
   549                                             # one-body flow equation  
   550         1         11.0     11.0      0.0    df  = np.zeros_like(f)
   551                                           
   552                                             # 1B - 1B
   553         1         16.0     16.0      0.0    df += commutator(eta1B, f)
   554                                           
   555                                             # 1B - 2B
   556         9          7.0      0.8      0.0    for p in range(dim1B):
   557        72         59.0      0.8      0.0      for q in range(dim1B):
   558       320        341.0      1.1      0.1        for i in holes:
   559      1280       1262.0      1.0      0.2          for a in particles:
   560      1024        987.0      1.0      0.2            df[p,q] += (
   561                                                       eta1B[i,a] * Gamma[idx2B[(a, p)], idx2B[(i, q)]] 
   562                                                       - eta1B[a,i] * Gamma[idx2B[(i, p)], idx2B[(a, q)]] 
   563                                                       - f[i,a] * eta2B[idx2B[(a, p)], idx2B[(i, q)]] 
   564      1024       4979.0      4.9      0.8              + f[a,i] * eta2B[idx2B[(i, p)], idx2B[(a, q)]]
   565                                                     )
   566                                           
   567                                             # 2B - 2B
   568                                             # n_a n_b nn_c + nn_a nn_b n_c = n_a n_b + (1 - n_a - n_b) * n_c
   569         1         59.0     59.0      0.0    etaGamma = dot(eta2B, dot(occB_2B, Gamma))
   570         9          8.0      0.9      0.0    for p in range(dim1B):
   571        72         66.0      0.9      0.0      for q in range(dim1B):
   572       320        314.0      1.0      0.1        for i in holes:
   573       256        236.0      0.9      0.0          df[p,q] += 0.5*(
   574       256        350.0      1.4      0.1            etaGamma[idx2B[(i,p)], idx2B[(i,q)]] 
   575       256        729.0      2.8      0.1            + transpose(etaGamma)[idx2B[(i,p)], idx2B[(i,q)]]
   576                                                   )
   577                                           
   578         1         60.0     60.0      0.0    etaGamma = dot(eta2B, dot(occC_2B, Gamma))
   579         9          9.0      1.0      0.0    for p in range(dim1B):
   580        72         66.0      0.9      0.0      for q in range(dim1B):
   581       576        538.0      0.9      0.1        for r in range(dim1B):
   582       512        553.0      1.1      0.1          df[p,q] += 0.5*(
   583       512        942.0      1.8      0.2            etaGamma[idx2B[(r,p)], idx2B[(r,q)]] 
   584       512       1771.0      3.5      0.3            + transpose(etaGamma)[idx2B[(r,p)], idx2B[(r,q)]] 
   585                                                   )
   586                                           
   587                                           
   588                                             #############################        
   589                                             # two-body flow equation  
   590         1         16.0     16.0      0.0    dGamma = np.zeros_like(Gamma)
   591                                           
   592                                             # 1B - 2B
   593         9         13.0      1.4      0.0    for p in range(dim1B):
   594        72         92.0      1.3      0.0      for q in range(dim1B):
   595       576        644.0      1.1      0.1        for r in range(dim1B):
   596      4608       5133.0      1.1      0.9          for s in range(dim1B):
   597     36864      44258.0      1.2      7.5            for t in range(dim1B):
   598     32768      70096.0      2.1     11.9              dGamma[idx2B[(p,q)],idx2B[(r,s)]] += (
   599                                                         eta1B[p,t] * Gamma[idx2B[(t,q)],idx2B[(r,s)]] 
   600                                                         + eta1B[q,t] * Gamma[idx2B[(p,t)],idx2B[(r,s)]] 
   601                                                         - eta1B[t,r] * Gamma[idx2B[(p,q)],idx2B[(t,s)]] 
   602                                                         - eta1B[t,s] * Gamma[idx2B[(p,q)],idx2B[(r,t)]]
   603                                                         - f[p,t] * eta2B[idx2B[(t,q)],idx2B[(r,s)]] 
   604                                                         - f[q,t] * eta2B[idx2B[(p,t)],idx2B[(r,s)]] 
   605                                                         + f[t,r] * eta2B[idx2B[(p,q)],idx2B[(t,s)]] 
   606     32768     389586.0     11.9     66.2                + f[t,s] * eta2B[idx2B[(p,q)],idx2B[(r,t)]]
   607                                                       )
   608                                           
   609                                             
   610                                             # 2B - 2B - particle and hole ladders
   611                                             # eta2B.occB.Gamma
   612         1         82.0     82.0      0.0    etaGamma = dot(eta2B, dot(occB_2B, Gamma))
   613                                           
   614         1         53.0     53.0      0.0    dGamma += 0.5 * (etaGamma + transpose(etaGamma))
   615                                           
   616                                             # 2B - 2B - particle-hole chain
   617                                             
   618                                             # transform matrices to particle-hole representation and calculate 
   619                                             # eta2B_ph.occA_ph.Gamma_ph
   620         1      14499.0  14499.0      2.5    eta2B_ph = ph_transform_2B(eta2B, bas2B, idx2B, basph2B, idxph2B)
   621         1      11701.0  11701.0      2.0    Gamma_ph = ph_transform_2B(Gamma, bas2B, idx2B, basph2B, idxph2B)
   622                                           
   623         1         85.0     85.0      0.0    etaGamma_ph = dot(eta2B_ph, dot(occphA_2B, Gamma_ph))
   624                                           
   625                                             # transform back to standard representation
   626         1      10274.0  10274.0      1.7    etaGamma    = inverse_ph_transform_2B(etaGamma_ph, bas2B, idx2B, basph2B, idxph2B)
   627                                           
   628                                             # commutator / antisymmetrization
   629         1         30.0     30.0      0.0    work = np.zeros_like(etaGamma)
   630        65         77.0      1.2      0.0    for i1, (i,j) in enumerate(bas2B):
   631      4160       5687.0      1.4      1.0      for i2, (k,l) in enumerate(bas2B):
   632      4096       5849.0      1.4      1.0        work[i1, i2] -= (
   633                                                   etaGamma[i1, i2] 
   634                                                   - etaGamma[idx2B[(j,i)], i2] 
   635                                                   - etaGamma[i1, idx2B[(l,k)]] 
   636      4096      16031.0      3.9      2.7          + etaGamma[idx2B[(j,i)], idx2B[(l,k)]]
   637                                                 )
   638         1          3.0      3.0      0.0    etaGamma = work
   639                                           
   640         1         21.0     21.0      0.0    dGamma += etaGamma
   641                                           
   642                                           
   643         1          2.0      2.0      0.0    return dE, df, dGamma

Total time: 2.7e-05 s
File: imsrg_pairing_bench.py
Function: get_operator_from_y at line 649

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   649                                           @profile
   650                                           def get_operator_from_y(y, dim1B, dim2B):
   651                                             
   652                                             # reshape the solution vector into 0B, 1B, 2B pieces
   653         2          2.0      1.0      7.4    ptr = 0
   654         2          2.0      1.0      7.4    zero_body = y[ptr]
   655                                           
   656         2          1.0      0.5      3.7    ptr += 1
   657         2         13.0      6.5     48.1    one_body = reshape(y[ptr:ptr+dim1B*dim1B], (dim1B, dim1B))
   658                                           
   659         2          2.0      1.0      7.4    ptr += dim1B*dim1B
   660         2          6.0      3.0     22.2    two_body = reshape(y[ptr:ptr+dim2B*dim2B], (dim2B, dim2B))
   661                                           
   662         2          1.0      0.5      3.7    return zero_body,one_body,two_body

Total time: 0.000618 s
File: imsrg_pairing_bench.py
Function: pairing_hamiltonian at line 707

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   707                                           @profile
   708                                           def pairing_hamiltonian(delta, g, user_data):
   709         1          1.0      1.0      0.2    bas1B = user_data["bas1B"]
   710         1          1.0      1.0      0.2    bas2B = user_data["bas2B"]
   711         1          1.0      1.0      0.2    idx2B = user_data["idx2B"]
   712                                           
   713         1          1.0      1.0      0.2    dim = len(bas1B)
   714         1          3.0      3.0      0.5    H1B = np.zeros((dim,dim))
   715                                           
   716         9          8.0      0.9      1.3    for i in bas1B:
   717         8         36.0      4.5      5.8      H1B[i,i] = delta*np.floor_divide(i, 2)
   718                                           
   719         1          0.0      0.0      0.0    dim = len(bas2B)
   720         1         12.0     12.0      1.9    H2B = np.zeros((dim, dim))
   721                                           
   722                                             # spin up states have even indices, spin down the next odd index
   723        65         39.0      0.6      6.3    for (i, j) in bas2B:
   724        64         61.0      1.0      9.9      if (i % 2 == 0 and j == i+1):
   725       260        140.0      0.5     22.7        for (k, l) in bas2B:
   726       256        248.0      1.0     40.1          if (k % 2 == 0 and l == k+1):
   727        16         17.0      1.1      2.8            H2B[idx2B[(i,j)],idx2B[(k,l)]] = -0.5*g
   728        16         16.0      1.0      2.6            H2B[idx2B[(j,i)],idx2B[(k,l)]] = 0.5*g
   729        16         16.0      1.0      2.6            H2B[idx2B[(i,j)],idx2B[(l,k)]] = 0.5*g
   730        16         17.0      1.1      2.8            H2B[idx2B[(j,i)],idx2B[(l,k)]] = -0.5*g
   731                                             
   732         1          1.0      1.0      0.2    return H1B, H2B

Total time: 0.000714 s
File: imsrg_pairing_bench.py
Function: normal_order at line 737

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   737                                           @profile
   738                                           def normal_order(H1B, H2B, user_data):
   739         1          0.0      0.0      0.0    bas1B     = user_data["bas1B"]
   740         1          1.0      1.0      0.1    bas2B     = user_data["bas2B"]
   741         1          0.0      0.0      0.0    idx2B     = user_data["idx2B"]
   742         1          0.0      0.0      0.0    particles = user_data["particles"]
   743         1          1.0      1.0      0.1    holes     = user_data["holes"]
   744                                           
   745                                             # 0B part
   746         1          1.0      1.0      0.1    E = 0.0
   747         5          7.0      1.4      1.0    for i in holes:
   748         4          4.0      1.0      0.6      E += H1B[i,i]
   749                                           
   750         5          5.0      1.0      0.7    for i in holes:
   751        20         11.0      0.6      1.5      for j in holes:
   752        16         19.0      1.2      2.7        E += 0.5*H2B[idx2B[(i,j)],idx2B[(i,j)]]  
   753                                           
   754                                             # 1B part
   755         1          1.0      1.0      0.1    f = H1B
   756         9          8.0      0.9      1.1    for i in bas1B:
   757        72         38.0      0.5      5.3      for j in bas1B:
   758       320        226.0      0.7     31.7        for h in holes:
   759       256        390.0      1.5     54.6          f[i,j] += H2B[idx2B[(i,h)],idx2B[(j,h)]]  
   760                                           
   761                                             # 2B part
   762         1          1.0      1.0      0.1    Gamma = H2B
   763                                           
   764         1          1.0      1.0      0.1    return E, f, Gamma

Total time: 1.41764 s
File: imsrg_pairing_bench.py
Function: main at line 831

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   831                                           @profile
   832                                           def main(n_holes):
   833                                             # grab delta and g from the command line
   834                                             # delta      = float(argv[1])
   835                                             # g          = float(argv[2])
   836         1          2.0      2.0      0.0    delta = 1
   837         1          1.0      1.0      0.0    g = 0.5
   838                                             
   839         1          1.0      1.0      0.0    particles  = n_holes
   840                                           
   841                                             # setup shared data
   842         1          1.0      1.0      0.0    dim1B     = n_holes*2
   843                                           
   844                                             # this defines the reference state
   845                                             # 1st state
   846         1          7.0      7.0      0.0    holes = np.arange(particles)
   847         1          3.0      3.0      0.0    particles = np.arange(particles,dim1B)
   848                                           
   849                                             # 2nd state
   850                                             # holes     = [0,1,4,5]
   851                                             # particles = [2,3,6,7]
   852                                           
   853                                             # 3rd state
   854                                             # holes     = [0,1,6,7]
   855                                             # particles = [2,3,4,5]
   856                                           
   857                                             # basis definitions
   858         1          3.0      3.0      0.0    bas1B     = list(range(dim1B))
   859         1        141.0    141.0      0.0    bas2B     = construct_basis_2B(holes, particles)
   860         1        134.0    134.0      0.0    basph2B   = construct_basis_ph2B(holes, particles)
   861                                           
   862         1         84.0     84.0      0.0    idx2B     = construct_index_2B(bas2B)
   863         1         80.0     80.0      0.0    idxph2B   = construct_index_2B(basph2B)
   864                                           
   865                                             # occupation number matrices
   866         1         21.0     21.0      0.0    occ1B     = construct_occupation_1B(bas1B, holes, particles)
   867         1        134.0    134.0      0.0    occA_2B   = construct_occupationA_2B(bas2B, occ1B)
   868         1        150.0    150.0      0.0    occB_2B   = construct_occupationB_2B(bas2B, occ1B)
   869         1        132.0    132.0      0.0    occC_2B   = construct_occupationC_2B(bas2B, occ1B)
   870                                           
   871         1        131.0    131.0      0.0    occphA_2B = construct_occupationA_2B(basph2B, occ1B)
   872                                           
   873                                             # store shared data in a dictionary, so we can avoid passing the basis
   874                                             # lookups etc. as separate parameters all the time
   875                                             user_data  = {
   876         1          1.0      1.0      0.0      "dim1B":      dim1B, 
   877         1          1.0      1.0      0.0      "holes":      holes,
   878         1          1.0      1.0      0.0      "particles":  particles,
   879         1          1.0      1.0      0.0      "bas1B":      bas1B,
   880         1          1.0      1.0      0.0      "bas2B":      bas2B,
   881         1          1.0      1.0      0.0      "basph2B":    basph2B,
   882         1          1.0      1.0      0.0      "idx2B":      idx2B,
   883         1          1.0      1.0      0.0      "idxph2B":    idxph2B,
   884         1          1.0      1.0      0.0      "occ1B":      occ1B,
   885         1          1.0      1.0      0.0      "occA_2B":    occA_2B,
   886         1          1.0      1.0      0.0      "occB_2B":    occB_2B,
   887         1          1.0      1.0      0.0      "occC_2B":    occC_2B,
   888         1          1.0      1.0      0.0      "occphA_2B":  occphA_2B,
   889                                           
   890         1          1.0      1.0      0.0      "eta_norm":   0.0,                # variables for sharing data between ODE solver
   891         1          1.0      1.0      0.0      "dE":         0.0,                # and main routine
   892                                           
   893                                           
   894         1          0.0      0.0      0.0      "calc_eta":   eta_wegner,          # specify the generator (function object)
   895         1          2.0      2.0      0.0      "calc_rhs":   flow_imsrg2         # specify the right-hand side and truncation
   896                                             }
   897                                           
   898                                             # set up initial Hamiltonian
   899         1       1092.0   1092.0      0.1    H1B, H2B = pairing_hamiltonian(delta, g, user_data)
   900                                             
   901         1       1132.0   1132.0      0.1    E, f, Gamma = normal_order(H1B, H2B, user_data) 
   902                                           
   903                                             # reshape Hamiltonian into a linear array (initial ODE vector)
   904         1         77.0     77.0      0.0    y0   = np.append([E], np.append(reshape(f, -1), reshape(Gamma, -1)))
   905                                           
   906         1          1.0      1.0      0.0    t = 1
   907         1    1414260.0 1414260.0     99.8    dy = derivative_wrapper(t, y0, user_data)
   908         1         22.0     22.0      0.0    dE, df, dG = get_operator_from_y(dy, dim1B, dim1B*dim1B)
   909         1         16.0     16.0      0.0    print(dE)

-1.75
Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
    30   75.887 MiB   75.887 MiB   @profile
    31                             def construct_basis_2B(holes, particles):
    32   75.887 MiB    0.000 MiB     basis = []
    33   75.887 MiB    0.000 MiB     for i in holes:
    34   75.887 MiB    0.000 MiB       for j in holes:
    35   75.887 MiB    0.000 MiB         basis.append((i, j)) # hole, hole
    36                             
    37   75.887 MiB    0.000 MiB     for i in holes:
    38   75.887 MiB    0.000 MiB       for a in particles:
    39   75.887 MiB    0.000 MiB         basis.append((i, a)) # hole, particle
    40                             
    41   75.887 MiB    0.000 MiB     for a in particles:
    42   75.887 MiB    0.000 MiB       for i in holes:
    43   75.887 MiB    0.000 MiB         basis.append((a, i)) # particle, hole
    44                             
    45   75.887 MiB    0.000 MiB     for a in particles:
    46   75.887 MiB    0.000 MiB       for b in particles:
    47   75.887 MiB    0.000 MiB         basis.append((a, b)) # particle, particle
    48                             
    49   75.887 MiB    0.000 MiB     return basis


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
    52   75.887 MiB   75.887 MiB   @profile
    53                             def construct_basis_ph2B(holes, particles):
    54   75.887 MiB    0.000 MiB     basis = []
    55   75.887 MiB    0.000 MiB     for i in holes:
    56   75.887 MiB    0.000 MiB       for j in holes:
    57   75.887 MiB    0.000 MiB         basis.append((i, j))
    58                             
    59   75.887 MiB    0.000 MiB     for i in holes:
    60   75.887 MiB    0.000 MiB       for a in particles:
    61   75.887 MiB    0.000 MiB         basis.append((i, a))
    62                             
    63   75.887 MiB    0.000 MiB     for a in particles:
    64   75.887 MiB    0.000 MiB       for i in holes:
    65   75.887 MiB    0.000 MiB         basis.append((a, i))
    66                             
    67   75.887 MiB    0.000 MiB     for a in particles:
    68   75.887 MiB    0.000 MiB       for b in particles:
    69   75.887 MiB    0.000 MiB         basis.append((a, b))
    70                             
    71   75.887 MiB    0.000 MiB     return basis


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
    77   75.887 MiB   75.887 MiB   @profile
    78                             def construct_index_2B(bas2B):
    79   75.887 MiB    0.000 MiB     index = { }
    80   75.887 MiB    0.000 MiB     for i, state in enumerate(bas2B):
    81   75.887 MiB    0.000 MiB       index[state] = i
    82                             
    83   75.887 MiB    0.000 MiB     return index


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
    90   76.566 MiB   76.566 MiB   @profile
    91                             def ph_transform_2B(Gamma, bas2B, idx2B, basph2B, idxph2B):
    92   76.566 MiB    0.000 MiB     dim = len(basph2B)
    93   76.566 MiB    0.000 MiB     Gamma_ph = np.zeros((dim, dim))
    94                             
    95   76.566 MiB    0.000 MiB     for i1, (a,b) in enumerate(basph2B):
    96   76.566 MiB    0.000 MiB       for i2, (c, d) in enumerate(basph2B):
    97   76.566 MiB    0.000 MiB         Gamma_ph[i1, i2] -= Gamma[idx2B[(a,d)], idx2B[(c,b)]]
    98                             
    99   76.566 MiB    0.000 MiB     return Gamma_ph


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   101   76.566 MiB   76.566 MiB   @profile
   102                             def inverse_ph_transform_2B(Gamma_ph, bas2B, idx2B, basph2B, idxph2B):
   103   76.566 MiB    0.000 MiB     dim = len(bas2B)
   104   76.566 MiB    0.000 MiB     Gamma = np.zeros((dim, dim))
   105                             
   106   76.566 MiB    0.000 MiB     for i1, (a,b) in enumerate(bas2B):
   107   76.566 MiB    0.000 MiB       for i2, (c, d) in enumerate(bas2B):
   108   76.566 MiB    0.000 MiB         Gamma[i1, i2] -= Gamma_ph[idxph2B[(a,d)], idxph2B[(c,b)]]
   109                               
   110   76.566 MiB    0.000 MiB     return Gamma


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   115   76.566 MiB   76.566 MiB   @profile
   116                             def commutator(a,b):
   117   76.566 MiB    0.000 MiB     return dot(a,b) - dot(b,a)


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   150   75.887 MiB   75.887 MiB   @profile
   151                             def construct_occupation_1B(bas1B, holes, particles):
   152   75.887 MiB    0.000 MiB     dim = len(bas1B)
   153   75.887 MiB    0.000 MiB     occ = np.zeros(dim)
   154                             
   155   75.887 MiB    0.000 MiB     for i in holes:
   156   75.887 MiB    0.000 MiB       occ[i] = 1.
   157                             
   158   75.887 MiB    0.000 MiB     return occ


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   161   75.887 MiB   75.887 MiB   @profile
   162                             def construct_occupationA_2B(bas2B, occ1B):
   163   75.887 MiB    0.000 MiB     dim = len(bas2B)
   164   75.887 MiB    0.000 MiB     occ = np.zeros((dim,dim))
   165                             
   166   75.887 MiB    0.000 MiB     for i1, (i,j) in enumerate(bas2B):
   167   75.887 MiB    0.000 MiB       occ[i1, i1] = occ1B[i] - occ1B[j]
   168                             
   169   75.887 MiB    0.000 MiB     return occ


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   173   75.887 MiB   75.887 MiB   @profile
   174                             def construct_occupationB_2B(bas2B, occ1B):
   175   75.887 MiB    0.000 MiB     dim = len(bas2B)
   176   75.887 MiB    0.000 MiB     occ = np.zeros((dim,dim))
   177                             
   178   75.887 MiB    0.000 MiB     for i1, (i,j) in enumerate(bas2B):
   179   75.887 MiB    0.000 MiB       occ[i1, i1] = 1. - occ1B[i] - occ1B[j]
   180                             
   181   75.887 MiB    0.000 MiB     return occ


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   184   75.887 MiB   75.887 MiB   @profile
   185                             def construct_occupationC_2B(bas2B, occ1B):
   186   75.887 MiB    0.000 MiB     dim = len(bas2B)
   187   75.887 MiB    0.000 MiB     occ = np.zeros((dim,dim))
   188                             
   189   75.887 MiB    0.000 MiB     for i1, (i,j) in enumerate(bas2B):
   190   75.887 MiB    0.000 MiB       occ[i1, i1] = occ1B[i] * occ1B[j]
   191                             
   192   75.887 MiB    0.000 MiB     return occ


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   382   76.082 MiB   76.082 MiB   @profile
   383                             def eta_wegner(f, Gamma, user_data):
   384                             
   385   76.082 MiB    0.000 MiB     dim1B     = user_data["dim1B"]
   386   76.082 MiB    0.000 MiB     holes     = user_data["holes"]
   387   76.082 MiB    0.000 MiB     particles = user_data["particles"]
   388   76.082 MiB    0.000 MiB     bas2B     = user_data["bas2B"]
   389   76.082 MiB    0.000 MiB     basph2B   = user_data["basph2B"]
   390   76.082 MiB    0.000 MiB     idx2B     = user_data["idx2B"]
   391   76.082 MiB    0.000 MiB     idxph2B   = user_data["idxph2B"]
   392   76.082 MiB    0.000 MiB     occB_2B   = user_data["occB_2B"]
   393   76.082 MiB    0.000 MiB     occC_2B   = user_data["occC_2B"]
   394   76.082 MiB    0.000 MiB     occphA_2B = user_data["occphA_2B"]
   395                             
   396                             
   397                               # split Hamiltonian in diagonal and off-diagonal parts
   398   76.082 MiB    0.000 MiB     fd      = np.zeros_like(f)
   399   76.082 MiB    0.000 MiB     fod     = np.zeros_like(f)
   400   76.082 MiB    0.000 MiB     Gammad  = np.zeros_like(Gamma)
   401   76.082 MiB    0.000 MiB     Gammaod = np.zeros_like(Gamma)
   402                             
   403   76.082 MiB    0.000 MiB     for a in particles:
   404   76.082 MiB    0.000 MiB       for i in holes:
   405   76.082 MiB    0.000 MiB         fod[a, i] = f[a,i]
   406   76.082 MiB    0.000 MiB         fod[i, a] = f[i,a]
   407   76.082 MiB    0.000 MiB     fd = f - fod
   408                             
   409   76.082 MiB    0.000 MiB     for a in particles:
   410   76.082 MiB    0.000 MiB       for b in particles:
   411   76.082 MiB    0.000 MiB         for i in holes:
   412   76.082 MiB    0.000 MiB           for j in holes:
   413   76.082 MiB    0.000 MiB             Gammaod[idx2B[(a,b)], idx2B[(i,j)]] = Gamma[idx2B[(a,b)], idx2B[(i,j)]]
   414   76.082 MiB    0.000 MiB             Gammaod[idx2B[(i,j)], idx2B[(a,b)]] = Gamma[idx2B[(i,j)], idx2B[(a,b)]]
   415   76.082 MiB    0.000 MiB     Gammad = Gamma - Gammaod
   416                             
   417                             
   418                               #############################        
   419                               # one-body flow equation  
   420   76.082 MiB    0.000 MiB     eta1B  = np.zeros_like(f)
   421                             
   422                               # 1B - 1B
   423   76.082 MiB   76.082 MiB     eta1B += commutator(fd, fod)
   424                             
   425                               # 1B - 2B
   426   76.082 MiB    0.000 MiB     for p in range(dim1B):
   427   76.082 MiB    0.000 MiB       for q in range(dim1B):
   428   76.082 MiB    0.000 MiB         for i in holes:
   429   76.082 MiB    0.000 MiB           for a in particles:
   430   76.082 MiB    0.000 MiB             eta1B[p,q] += (
   431                                         fd[i,a]  * Gammaod[idx2B[(a, p)], idx2B[(i, q)]] 
   432                                         - fd[a,i]  * Gammaod[idx2B[(i, p)], idx2B[(a, q)]] 
   433                                         - fod[i,a] * Gammad[idx2B[(a, p)], idx2B[(i, q)]] 
   434   76.082 MiB    0.000 MiB               + fod[a,i] * Gammad[idx2B[(i, p)], idx2B[(a, q)]]
   435                                       )
   436                             
   437                               # 2B - 2B
   438                               # n_a n_b nn_c + nn_a nn_b n_c = n_a n_b + (1 - n_a - n_b) * n_c
   439   76.082 MiB    0.000 MiB     GammaGamma = dot(Gammad, dot(occB_2B, Gammaod))
   440   76.082 MiB    0.000 MiB     for p in range(dim1B):
   441   76.082 MiB    0.000 MiB       for q in range(dim1B):
   442   76.082 MiB    0.000 MiB         for i in holes:
   443   76.082 MiB    0.000 MiB           eta1B[p,q] += (
   444   76.082 MiB    0.000 MiB             0.5*GammaGamma[idx2B[(i,p)], idx2B[(i,q)]] 
   445   76.082 MiB    0.000 MiB             - transpose(GammaGamma)[idx2B[(i,p)], idx2B[(i,q)]]
   446                                     )
   447                             
   448   76.082 MiB    0.000 MiB     GammaGamma = dot(Gammad, dot(occC_2B, Gammaod))
   449   76.082 MiB    0.000 MiB     for p in range(dim1B):
   450   76.082 MiB    0.000 MiB       for q in range(dim1B):
   451   76.082 MiB    0.000 MiB         for r in range(dim1B):
   452   76.082 MiB    0.000 MiB           eta1B[p,q] += (
   453   76.082 MiB    0.000 MiB             0.5*GammaGamma[idx2B[(r,p)], idx2B[(r,q)]] 
   454   76.082 MiB    0.000 MiB             + transpose(GammaGamma)[idx2B[(r,p)], idx2B[(r,q)]] 
   455                                     )
   456                             
   457                             
   458                               #############################        
   459                               # two-body flow equation  
   460   76.082 MiB    0.000 MiB     eta2B = np.zeros_like(Gamma)
   461                             
   462                               # 1B - 2B
   463   76.082 MiB    0.000 MiB     for p in range(dim1B):
   464   76.082 MiB    0.000 MiB       for q in range(dim1B):
   465   76.082 MiB    0.000 MiB         for r in range(dim1B):
   466   76.082 MiB    0.000 MiB           for s in range(dim1B):
   467   76.082 MiB    0.000 MiB             for t in range(dim1B):
   468   76.082 MiB    0.000 MiB               eta2B[idx2B[(p,q)],idx2B[(r,s)]] += (
   469                                           fd[p,t] * Gammaod[idx2B[(t,q)],idx2B[(r,s)]] 
   470                                           + fd[q,t] * Gammaod[idx2B[(p,t)],idx2B[(r,s)]] 
   471                                           - fd[t,r] * Gammaod[idx2B[(p,q)],idx2B[(t,s)]] 
   472                                           - fd[t,s] * Gammaod[idx2B[(p,q)],idx2B[(r,t)]]
   473                                           - fod[p,t] * Gammad[idx2B[(t,q)],idx2B[(r,s)]] 
   474                                           - fod[q,t] * Gammad[idx2B[(p,t)],idx2B[(r,s)]] 
   475                                           + fod[t,r] * Gammad[idx2B[(p,q)],idx2B[(t,s)]] 
   476   76.082 MiB    0.000 MiB                 + fod[t,s] * Gammad[idx2B[(p,q)],idx2B[(r,t)]]
   477                                         )
   478                             
   479                               
   480                               # 2B - 2B - particle and hole ladders
   481                               # Gammad.occB.Gammaod
   482   76.082 MiB    0.000 MiB     GammaGamma = dot(Gammad, dot(occB_2B, Gammaod))
   483                             
   484   76.082 MiB    0.000 MiB     eta2B += 0.5 * (GammaGamma - transpose(GammaGamma))
   485                             
   486                               # 2B - 2B - particle-hole chain
   487                               
   488                               # transform matrices to particle-hole representation and calculate 
   489                               # Gammad_ph.occA_ph.Gammaod_ph
   490   76.082 MiB   76.082 MiB     Gammad_ph = ph_transform_2B(Gammad, bas2B, idx2B, basph2B, idxph2B)
   491   76.082 MiB   76.082 MiB     Gammaod_ph = ph_transform_2B(Gammaod, bas2B, idx2B, basph2B, idxph2B)
   492                             
   493   76.566 MiB    0.484 MiB     GammaGamma_ph = dot(Gammad_ph, dot(occphA_2B, Gammaod_ph))
   494                             
   495                               # transform back to standard representation
   496   76.566 MiB   76.566 MiB     GammaGamma    = inverse_ph_transform_2B(GammaGamma_ph, bas2B, idx2B, basph2B, idxph2B)
   497                             
   498                               # commutator / antisymmetrization
   499   76.566 MiB    0.000 MiB     work = np.zeros_like(GammaGamma)
   500   76.566 MiB    0.000 MiB     for i1, (i,j) in enumerate(bas2B):
   501   76.566 MiB    0.000 MiB       for i2, (k,l) in enumerate(bas2B):
   502   76.566 MiB    0.000 MiB         work[i1, i2] -= (
   503                                     GammaGamma[i1, i2] 
   504                                     - GammaGamma[idx2B[(j,i)], i2] 
   505                                     - GammaGamma[i1, idx2B[(l,k)]] 
   506   76.566 MiB    0.000 MiB           + GammaGamma[idx2B[(j,i)], idx2B[(l,k)]]
   507                                   )
   508   76.566 MiB    0.000 MiB     GammaGamma = work
   509                             
   510   76.566 MiB    0.000 MiB     eta2B += GammaGamma
   511                             
   512                             
   513   76.566 MiB    0.000 MiB     return eta1B, eta2B


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   519   76.566 MiB   76.566 MiB   @profile
   520                             def flow_imsrg2(eta1B, eta2B, f, Gamma, user_data):
   521                             
   522   76.566 MiB    0.000 MiB     dim1B     = user_data["dim1B"]
   523   76.566 MiB    0.000 MiB     holes     = user_data["holes"]
   524   76.566 MiB    0.000 MiB     particles = user_data["particles"]
   525   76.566 MiB    0.000 MiB     bas2B     = user_data["bas2B"]
   526   76.566 MiB    0.000 MiB     idx2B     = user_data["idx2B"]
   527   76.566 MiB    0.000 MiB     basph2B   = user_data["basph2B"]
   528   76.566 MiB    0.000 MiB     idxph2B   = user_data["idxph2B"]
   529   76.566 MiB    0.000 MiB     occB_2B   = user_data["occB_2B"]
   530   76.566 MiB    0.000 MiB     occC_2B   = user_data["occC_2B"]
   531   76.566 MiB    0.000 MiB     occphA_2B = user_data["occphA_2B"]
   532                             
   533                               #############################        
   534                               # zero-body flow equation
   535   76.566 MiB    0.000 MiB     dE = 0.0
   536                             
   537   76.566 MiB    0.000 MiB     for i in holes:
   538   76.566 MiB    0.000 MiB       for a in particles:
   539   76.566 MiB    0.000 MiB         dE += eta1B[i,a] * f[a,i] - eta1B[a,i] * f[i,a]
   540                             
   541   76.566 MiB    0.000 MiB     for i in holes:
   542   76.566 MiB    0.000 MiB       for j in holes:
   543   76.566 MiB    0.000 MiB         for a in particles:
   544   76.566 MiB    0.000 MiB           for b in particles:
   545   76.566 MiB    0.000 MiB             dE += 0.5 * eta2B[idx2B[(i,j)], idx2B[(a,b)]] * Gamma[idx2B[(a,b)], idx2B[(i,j)]]
   546                             
   547                             
   548                               #############################        
   549                               # one-body flow equation  
   550   76.566 MiB    0.000 MiB     df  = np.zeros_like(f)
   551                             
   552                               # 1B - 1B
   553   76.566 MiB   76.566 MiB     df += commutator(eta1B, f)
   554                             
   555                               # 1B - 2B
   556   76.566 MiB    0.000 MiB     for p in range(dim1B):
   557   76.566 MiB    0.000 MiB       for q in range(dim1B):
   558   76.566 MiB    0.000 MiB         for i in holes:
   559   76.566 MiB    0.000 MiB           for a in particles:
   560   76.566 MiB    0.000 MiB             df[p,q] += (
   561                                         eta1B[i,a] * Gamma[idx2B[(a, p)], idx2B[(i, q)]] 
   562                                         - eta1B[a,i] * Gamma[idx2B[(i, p)], idx2B[(a, q)]] 
   563                                         - f[i,a] * eta2B[idx2B[(a, p)], idx2B[(i, q)]] 
   564   76.566 MiB    0.000 MiB               + f[a,i] * eta2B[idx2B[(i, p)], idx2B[(a, q)]]
   565                                       )
   566                             
   567                               # 2B - 2B
   568                               # n_a n_b nn_c + nn_a nn_b n_c = n_a n_b + (1 - n_a - n_b) * n_c
   569   76.566 MiB    0.000 MiB     etaGamma = dot(eta2B, dot(occB_2B, Gamma))
   570   76.566 MiB    0.000 MiB     for p in range(dim1B):
   571   76.566 MiB    0.000 MiB       for q in range(dim1B):
   572   76.566 MiB    0.000 MiB         for i in holes:
   573   76.566 MiB    0.000 MiB           df[p,q] += 0.5*(
   574   76.566 MiB    0.000 MiB             etaGamma[idx2B[(i,p)], idx2B[(i,q)]] 
   575   76.566 MiB    0.000 MiB             + transpose(etaGamma)[idx2B[(i,p)], idx2B[(i,q)]]
   576                                     )
   577                             
   578   76.566 MiB    0.000 MiB     etaGamma = dot(eta2B, dot(occC_2B, Gamma))
   579   76.566 MiB    0.000 MiB     for p in range(dim1B):
   580   76.566 MiB    0.000 MiB       for q in range(dim1B):
   581   76.566 MiB    0.000 MiB         for r in range(dim1B):
   582   76.566 MiB    0.000 MiB           df[p,q] += 0.5*(
   583   76.566 MiB    0.000 MiB             etaGamma[idx2B[(r,p)], idx2B[(r,q)]] 
   584   76.566 MiB    0.000 MiB             + transpose(etaGamma)[idx2B[(r,p)], idx2B[(r,q)]] 
   585                                     )
   586                             
   587                             
   588                               #############################        
   589                               # two-body flow equation  
   590   76.566 MiB    0.000 MiB     dGamma = np.zeros_like(Gamma)
   591                             
   592                               # 1B - 2B
   593   76.566 MiB    0.000 MiB     for p in range(dim1B):
   594   76.566 MiB    0.000 MiB       for q in range(dim1B):
   595   76.566 MiB    0.000 MiB         for r in range(dim1B):
   596   76.566 MiB    0.000 MiB           for s in range(dim1B):
   597   76.566 MiB    0.000 MiB             for t in range(dim1B):
   598   76.566 MiB    0.000 MiB               dGamma[idx2B[(p,q)],idx2B[(r,s)]] += (
   599                                           eta1B[p,t] * Gamma[idx2B[(t,q)],idx2B[(r,s)]] 
   600                                           + eta1B[q,t] * Gamma[idx2B[(p,t)],idx2B[(r,s)]] 
   601                                           - eta1B[t,r] * Gamma[idx2B[(p,q)],idx2B[(t,s)]] 
   602                                           - eta1B[t,s] * Gamma[idx2B[(p,q)],idx2B[(r,t)]]
   603                                           - f[p,t] * eta2B[idx2B[(t,q)],idx2B[(r,s)]] 
   604                                           - f[q,t] * eta2B[idx2B[(p,t)],idx2B[(r,s)]] 
   605                                           + f[t,r] * eta2B[idx2B[(p,q)],idx2B[(t,s)]] 
   606   76.566 MiB    0.000 MiB                 + f[t,s] * eta2B[idx2B[(p,q)],idx2B[(r,t)]]
   607                                         )
   608                             
   609                               
   610                               # 2B - 2B - particle and hole ladders
   611                               # eta2B.occB.Gamma
   612   76.566 MiB    0.000 MiB     etaGamma = dot(eta2B, dot(occB_2B, Gamma))
   613                             
   614   76.566 MiB    0.000 MiB     dGamma += 0.5 * (etaGamma + transpose(etaGamma))
   615                             
   616                               # 2B - 2B - particle-hole chain
   617                               
   618                               # transform matrices to particle-hole representation and calculate 
   619                               # eta2B_ph.occA_ph.Gamma_ph
   620   76.566 MiB   76.566 MiB     eta2B_ph = ph_transform_2B(eta2B, bas2B, idx2B, basph2B, idxph2B)
   621   76.566 MiB   76.566 MiB     Gamma_ph = ph_transform_2B(Gamma, bas2B, idx2B, basph2B, idxph2B)
   622                             
   623   76.566 MiB    0.000 MiB     etaGamma_ph = dot(eta2B_ph, dot(occphA_2B, Gamma_ph))
   624                             
   625                               # transform back to standard representation
   626   76.566 MiB   76.566 MiB     etaGamma    = inverse_ph_transform_2B(etaGamma_ph, bas2B, idx2B, basph2B, idxph2B)
   627                             
   628                               # commutator / antisymmetrization
   629   76.566 MiB    0.000 MiB     work = np.zeros_like(etaGamma)
   630   76.566 MiB    0.000 MiB     for i1, (i,j) in enumerate(bas2B):
   631   76.566 MiB    0.000 MiB       for i2, (k,l) in enumerate(bas2B):
   632   76.566 MiB    0.000 MiB         work[i1, i2] -= (
   633                                     etaGamma[i1, i2] 
   634                                     - etaGamma[idx2B[(j,i)], i2] 
   635                                     - etaGamma[i1, idx2B[(l,k)]] 
   636   76.566 MiB    0.000 MiB           + etaGamma[idx2B[(j,i)], idx2B[(l,k)]]
   637                                   )
   638   76.566 MiB    0.000 MiB     etaGamma = work
   639                             
   640   76.566 MiB    0.000 MiB     dGamma += etaGamma
   641                             
   642                             
   643   76.566 MiB    0.000 MiB     return dE, df, dGamma


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   649   76.566 MiB   76.566 MiB   @profile
   650                             def get_operator_from_y(y, dim1B, dim2B):
   651                               
   652                               # reshape the solution vector into 0B, 1B, 2B pieces
   653   76.566 MiB    0.000 MiB     ptr = 0
   654   76.566 MiB    0.000 MiB     zero_body = y[ptr]
   655                             
   656   76.566 MiB    0.000 MiB     ptr += 1
   657   76.566 MiB    0.000 MiB     one_body = reshape(y[ptr:ptr+dim1B*dim1B], (dim1B, dim1B))
   658                             
   659   76.566 MiB    0.000 MiB     ptr += dim1B*dim1B
   660   76.566 MiB    0.000 MiB     two_body = reshape(y[ptr:ptr+dim2B*dim2B], (dim2B, dim2B))
   661                             
   662   76.566 MiB    0.000 MiB     return zero_body,one_body,two_body


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   707   75.887 MiB   75.887 MiB   @profile
   708                             def pairing_hamiltonian(delta, g, user_data):
   709   75.887 MiB    0.000 MiB     bas1B = user_data["bas1B"]
   710   75.887 MiB    0.000 MiB     bas2B = user_data["bas2B"]
   711   75.887 MiB    0.000 MiB     idx2B = user_data["idx2B"]
   712                             
   713   75.887 MiB    0.000 MiB     dim = len(bas1B)
   714   75.887 MiB    0.000 MiB     H1B = np.zeros((dim,dim))
   715                             
   716   75.887 MiB    0.000 MiB     for i in bas1B:
   717   75.887 MiB    0.000 MiB       H1B[i,i] = delta*np.floor_divide(i, 2)
   718                             
   719   75.887 MiB    0.000 MiB     dim = len(bas2B)
   720   75.887 MiB    0.000 MiB     H2B = np.zeros((dim, dim))
   721                             
   722                               # spin up states have even indices, spin down the next odd index
   723   75.887 MiB    0.000 MiB     for (i, j) in bas2B:
   724   75.887 MiB    0.000 MiB       if (i % 2 == 0 and j == i+1):
   725   75.887 MiB    0.000 MiB         for (k, l) in bas2B:
   726   75.887 MiB    0.000 MiB           if (k % 2 == 0 and l == k+1):
   727   75.887 MiB    0.000 MiB             H2B[idx2B[(i,j)],idx2B[(k,l)]] = -0.5*g
   728   75.887 MiB    0.000 MiB             H2B[idx2B[(j,i)],idx2B[(k,l)]] = 0.5*g
   729   75.887 MiB    0.000 MiB             H2B[idx2B[(i,j)],idx2B[(l,k)]] = 0.5*g
   730   75.887 MiB    0.000 MiB             H2B[idx2B[(j,i)],idx2B[(l,k)]] = -0.5*g
   731                               
   732   75.887 MiB    0.000 MiB     return H1B, H2B


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   737   75.887 MiB   75.887 MiB   @profile
   738                             def normal_order(H1B, H2B, user_data):
   739   75.887 MiB    0.000 MiB     bas1B     = user_data["bas1B"]
   740   75.887 MiB    0.000 MiB     bas2B     = user_data["bas2B"]
   741   75.887 MiB    0.000 MiB     idx2B     = user_data["idx2B"]
   742   75.887 MiB    0.000 MiB     particles = user_data["particles"]
   743   75.887 MiB    0.000 MiB     holes     = user_data["holes"]
   744                             
   745                               # 0B part
   746   75.887 MiB    0.000 MiB     E = 0.0
   747   75.887 MiB    0.000 MiB     for i in holes:
   748   75.887 MiB    0.000 MiB       E += H1B[i,i]
   749                             
   750   75.887 MiB    0.000 MiB     for i in holes:
   751   75.887 MiB    0.000 MiB       for j in holes:
   752   75.887 MiB    0.000 MiB         E += 0.5*H2B[idx2B[(i,j)],idx2B[(i,j)]]  
   753                             
   754                               # 1B part
   755   75.887 MiB    0.000 MiB     f = H1B
   756   75.887 MiB    0.000 MiB     for i in bas1B:
   757   75.887 MiB    0.000 MiB       for j in bas1B:
   758   75.887 MiB    0.000 MiB         for h in holes:
   759   75.887 MiB    0.000 MiB           f[i,j] += H2B[idx2B[(i,h)],idx2B[(j,h)]]  
   760                             
   761                               # 2B part
   762   75.887 MiB    0.000 MiB     Gamma = H2B
   763                             
   764   75.887 MiB    0.000 MiB     return E, f, Gamma


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   831   75.887 MiB   75.887 MiB   @profile
   832                             def main(n_holes):
   833                               # grab delta and g from the command line
   834                               # delta      = float(argv[1])
   835                               # g          = float(argv[2])
   836   75.887 MiB    0.000 MiB     delta = 1
   837   75.887 MiB    0.000 MiB     g = 0.5
   838                               
   839   75.887 MiB    0.000 MiB     particles  = n_holes
   840                             
   841                               # setup shared data
   842   75.887 MiB    0.000 MiB     dim1B     = n_holes*2
   843                             
   844                               # this defines the reference state
   845                               # 1st state
   846   75.887 MiB    0.000 MiB     holes = np.arange(particles)
   847   75.887 MiB    0.000 MiB     particles = np.arange(particles,dim1B)
   848                             
   849                               # 2nd state
   850                               # holes     = [0,1,4,5]
   851                               # particles = [2,3,6,7]
   852                             
   853                               # 3rd state
   854                               # holes     = [0,1,6,7]
   855                               # particles = [2,3,4,5]
   856                             
   857                               # basis definitions
   858   75.887 MiB    0.000 MiB     bas1B     = list(range(dim1B))
   859   75.887 MiB   75.887 MiB     bas2B     = construct_basis_2B(holes, particles)
   860   75.887 MiB   75.887 MiB     basph2B   = construct_basis_ph2B(holes, particles)
   861                             
   862   75.887 MiB   75.887 MiB     idx2B     = construct_index_2B(bas2B)
   863   75.887 MiB   75.887 MiB     idxph2B   = construct_index_2B(basph2B)
   864                             
   865                               # occupation number matrices
   866   75.887 MiB   75.887 MiB     occ1B     = construct_occupation_1B(bas1B, holes, particles)
   867   75.887 MiB   75.887 MiB     occA_2B   = construct_occupationA_2B(bas2B, occ1B)
   868   75.887 MiB   75.887 MiB     occB_2B   = construct_occupationB_2B(bas2B, occ1B)
   869   75.887 MiB   75.887 MiB     occC_2B   = construct_occupationC_2B(bas2B, occ1B)
   870                             
   871   75.887 MiB   75.887 MiB     occphA_2B = construct_occupationA_2B(basph2B, occ1B)
   872                             
   873                               # store shared data in a dictionary, so we can avoid passing the basis
   874                               # lookups etc. as separate parameters all the time
   875                               user_data  = {
   876   75.887 MiB    0.000 MiB       "dim1B":      dim1B, 
   877   75.887 MiB    0.000 MiB       "holes":      holes,
   878   75.887 MiB    0.000 MiB       "particles":  particles,
   879   75.887 MiB    0.000 MiB       "bas1B":      bas1B,
   880   75.887 MiB    0.000 MiB       "bas2B":      bas2B,
   881   75.887 MiB    0.000 MiB       "basph2B":    basph2B,
   882   75.887 MiB    0.000 MiB       "idx2B":      idx2B,
   883   75.887 MiB    0.000 MiB       "idxph2B":    idxph2B,
   884   75.887 MiB    0.000 MiB       "occ1B":      occ1B,
   885   75.887 MiB    0.000 MiB       "occA_2B":    occA_2B,
   886   75.887 MiB    0.000 MiB       "occB_2B":    occB_2B,
   887   75.887 MiB    0.000 MiB       "occC_2B":    occC_2B,
   888   75.887 MiB    0.000 MiB       "occphA_2B":  occphA_2B,
   889                             
   890   75.887 MiB    0.000 MiB       "eta_norm":   0.0,                # variables for sharing data between ODE solver
   891   75.887 MiB    0.000 MiB       "dE":         0.0,                # and main routine
   892                             
   893                             
   894   75.887 MiB    0.000 MiB       "calc_eta":   eta_wegner,          # specify the generator (function object)
   895   75.887 MiB    0.000 MiB       "calc_rhs":   flow_imsrg2         # specify the right-hand side and truncation
   896                               }
   897                             
   898                               # set up initial Hamiltonian
   899   75.887 MiB   75.887 MiB     H1B, H2B = pairing_hamiltonian(delta, g, user_data)
   900                               
   901   75.887 MiB   75.887 MiB     E, f, Gamma = normal_order(H1B, H2B, user_data) 
   902                             
   903                               # reshape Hamiltonian into a linear array (initial ODE vector)
   904   76.082 MiB    0.195 MiB     y0   = np.append([E], np.append(reshape(f, -1), reshape(Gamma, -1)))
   905                             
   906   76.082 MiB    0.000 MiB     t = 1
   907   76.566 MiB   76.566 MiB     dy = derivative_wrapper(t, y0, user_data)
   908   76.566 MiB   76.566 MiB     dE, df, dG = get_operator_from_y(dy, dim1B, dim1B*dim1B)
   909   76.566 MiB    0.000 MiB     print(dE)


---------------------------------------------

Executing NP on n_holes=6 ---------------------------
-5.625
Wrote profile results to imsrg_pairing_bench.py.lprof
Timer unit: 1e-06 s

Total time: 0.000167 s
File: imsrg_pairing_bench.py
Function: construct_basis_2B at line 30

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    30                                           @profile
    31                                           def construct_basis_2B(holes, particles):
    32         1          1.0      1.0      0.6    basis = []
    33         7          5.0      0.7      3.0    for i in holes:
    34        42         24.0      0.6     14.4      for j in holes:
    35        36         15.0      0.4      9.0        basis.append((i, j)) # hole, hole
    36                                           
    37         7          5.0      0.7      3.0    for i in holes:
    38        42         19.0      0.5     11.4      for a in particles:
    39        36         14.0      0.4      8.4        basis.append((i, a)) # hole, particle
    40                                           
    41         7          5.0      0.7      3.0    for a in particles:
    42        42         26.0      0.6     15.6      for i in holes:
    43        36         16.0      0.4      9.6        basis.append((a, i)) # particle, hole
    44                                           
    45         7          1.0      0.1      0.6    for a in particles:
    46        42         22.0      0.5     13.2      for b in particles:
    47        36         14.0      0.4      8.4        basis.append((a, b)) # particle, particle
    48                                           
    49         1          0.0      0.0      0.0    return basis

Total time: 0.000168 s
File: imsrg_pairing_bench.py
Function: construct_basis_ph2B at line 52

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    52                                           @profile
    53                                           def construct_basis_ph2B(holes, particles):
    54         1          0.0      0.0      0.0    basis = []
    55         7          4.0      0.6      2.4    for i in holes:
    56        42         21.0      0.5     12.5      for j in holes:
    57        36         14.0      0.4      8.3        basis.append((i, j))
    58                                           
    59         7          2.0      0.3      1.2    for i in holes:
    60        42         22.0      0.5     13.1      for a in particles:
    61        36         16.0      0.4      9.5        basis.append((i, a))
    62                                           
    63         7          5.0      0.7      3.0    for a in particles:
    64        42         23.0      0.5     13.7      for i in holes:
    65        36         15.0      0.4      8.9        basis.append((a, i))
    66                                           
    67         7          5.0      0.7      3.0    for a in particles:
    68        42         21.0      0.5     12.5      for b in particles:
    69        36         20.0      0.6     11.9        basis.append((a, b))
    70                                           
    71         1          0.0      0.0      0.0    return basis

Total time: 0.000203 s
File: imsrg_pairing_bench.py
Function: construct_index_2B at line 77

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    77                                           @profile
    78                                           def construct_index_2B(bas2B):
    79         2          1.0      0.5      0.5    index = { }
    80       290         91.0      0.3     44.8    for i, state in enumerate(bas2B):
    81       288        111.0      0.4     54.7      index[state] = i
    82                                           
    83         2          0.0      0.0      0.0    return index

Total time: 0.198715 s
File: imsrg_pairing_bench.py
Function: ph_transform_2B at line 90

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    90                                           @profile
    91                                           def ph_transform_2B(Gamma, bas2B, idx2B, basph2B, idxph2B):
    92         4          7.0      1.8      0.0    dim = len(basph2B)
    93         4         87.0     21.8      0.0    Gamma_ph = np.zeros((dim, dim))
    94                                           
    95       580        354.0      0.6      0.2    for i1, (a,b) in enumerate(basph2B):
    96     83520      53090.0      0.6     26.7      for i2, (c, d) in enumerate(basph2B):
    97     82944     145174.0      1.8     73.1        Gamma_ph[i1, i2] -= Gamma[idx2B[(a,d)], idx2B[(c,b)]]
    98                                           
    99         4          3.0      0.8      0.0    return Gamma_ph

Total time: 0.122752 s
File: imsrg_pairing_bench.py
Function: inverse_ph_transform_2B at line 101

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   101                                           @profile
   102                                           def inverse_ph_transform_2B(Gamma_ph, bas2B, idx2B, basph2B, idxph2B):
   103         2          3.0      1.5      0.0    dim = len(bas2B)
   104         2         22.0     11.0      0.0    Gamma = np.zeros((dim, dim))
   105                                           
   106       290        226.0      0.8      0.2    for i1, (a,b) in enumerate(bas2B):
   107     41760      32663.0      0.8     26.6      for i2, (c, d) in enumerate(bas2B):
   108     41472      89837.0      2.2     73.2        Gamma[i1, i2] -= Gamma_ph[idxph2B[(a,d)], idxph2B[(c,b)]]
   109                                             
   110         2          1.0      0.5      0.0    return Gamma

Total time: 5.7e-05 s
File: imsrg_pairing_bench.py
Function: commutator at line 115

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   115                                           @profile
   116                                           def commutator(a,b):
   117         2         57.0     28.5    100.0    return dot(a,b) - dot(b,a)

Total time: 1.4e-05 s
File: imsrg_pairing_bench.py
Function: construct_occupation_1B at line 150

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   150                                           @profile
   151                                           def construct_occupation_1B(bas1B, holes, particles):
   152         1          1.0      1.0      7.1    dim = len(bas1B)
   153         1          5.0      5.0     35.7    occ = np.zeros(dim)
   154                                           
   155         7          4.0      0.6     28.6    for i in holes:
   156         6          4.0      0.7     28.6      occ[i] = 1.
   157                                           
   158         1          0.0      0.0      0.0    return occ

Total time: 0.000451 s
File: imsrg_pairing_bench.py
Function: construct_occupationA_2B at line 161

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   161                                           @profile
   162                                           def construct_occupationA_2B(bas2B, occ1B):
   163         2          1.0      0.5      0.2    dim = len(bas2B)
   164         2         92.0     46.0     20.4    occ = np.zeros((dim,dim))
   165                                           
   166       290        108.0      0.4     23.9    for i1, (i,j) in enumerate(bas2B):
   167       288        248.0      0.9     55.0      occ[i1, i1] = occ1B[i] - occ1B[j]
   168                                           
   169         2          2.0      1.0      0.4    return occ

Total time: 0.00025 s
File: imsrg_pairing_bench.py
Function: construct_occupationB_2B at line 173

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   173                                           @profile
   174                                           def construct_occupationB_2B(bas2B, occ1B):
   175         1          0.0      0.0      0.0    dim = len(bas2B)
   176         1         65.0     65.0     26.0    occ = np.zeros((dim,dim))
   177                                           
   178       145         53.0      0.4     21.2    for i1, (i,j) in enumerate(bas2B):
   179       144        132.0      0.9     52.8      occ[i1, i1] = 1. - occ1B[i] - occ1B[j]
   180                                           
   181         1          0.0      0.0      0.0    return occ

Total time: 0.000225 s
File: imsrg_pairing_bench.py
Function: construct_occupationC_2B at line 184

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   184                                           @profile
   185                                           def construct_occupationC_2B(bas2B, occ1B):
   186         1          1.0      1.0      0.4    dim = len(bas2B)
   187         1         51.0     51.0     22.7    occ = np.zeros((dim,dim))
   188                                           
   189       145         59.0      0.4     26.2    for i1, (i,j) in enumerate(bas2B):
   190       144        114.0      0.8     50.7      occ[i1, i1] = occ1B[i] * occ1B[j]
   191                                           
   192         1          0.0      0.0      0.0    return occ

Total time: 3.51789 s
File: imsrg_pairing_bench.py
Function: eta_wegner at line 382

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   382                                           @profile
   383                                           def eta_wegner(f, Gamma, user_data):
   384                                           
   385         1          2.0      2.0      0.0    dim1B     = user_data["dim1B"]
   386         1          1.0      1.0      0.0    holes     = user_data["holes"]
   387         1          1.0      1.0      0.0    particles = user_data["particles"]
   388         1          1.0      1.0      0.0    bas2B     = user_data["bas2B"]
   389         1          0.0      0.0      0.0    basph2B   = user_data["basph2B"]
   390         1          1.0      1.0      0.0    idx2B     = user_data["idx2B"]
   391         1          0.0      0.0      0.0    idxph2B   = user_data["idxph2B"]
   392         1          1.0      1.0      0.0    occB_2B   = user_data["occB_2B"]
   393         1          1.0      1.0      0.0    occC_2B   = user_data["occC_2B"]
   394         1          1.0      1.0      0.0    occphA_2B = user_data["occphA_2B"]
   395                                           
   396                                           
   397                                             # split Hamiltonian in diagonal and off-diagonal parts
   398         1         15.0     15.0      0.0    fd      = np.zeros_like(f)
   399         1          5.0      5.0      0.0    fod     = np.zeros_like(f)
   400         1         61.0     61.0      0.0    Gammad  = np.zeros_like(Gamma)
   401         1         71.0     71.0      0.0    Gammaod = np.zeros_like(Gamma)
   402                                           
   403         7          8.0      1.1      0.0    for a in particles:
   404        42         37.0      0.9      0.0      for i in holes:
   405        36         41.0      1.1      0.0        fod[a, i] = f[a,i]
   406        36         41.0      1.1      0.0        fod[i, a] = f[i,a]
   407         1          6.0      6.0      0.0    fd = f - fod
   408                                           
   409         7          5.0      0.7      0.0    for a in particles:
   410        42         40.0      1.0      0.0      for b in particles:
   411       252        237.0      0.9      0.0        for i in holes:
   412      1512       1454.0      1.0      0.0          for j in holes:
   413      1296       2375.0      1.8      0.1            Gammaod[idx2B[(a,b)], idx2B[(i,j)]] = Gamma[idx2B[(a,b)], idx2B[(i,j)]]
   414      1296       2359.0      1.8      0.1            Gammaod[idx2B[(i,j)], idx2B[(a,b)]] = Gamma[idx2B[(i,j)], idx2B[(a,b)]]
   415         1         72.0     72.0      0.0    Gammad = Gamma - Gammaod
   416                                           
   417                                           
   418                                             #############################        
   419                                             # one-body flow equation  
   420         1         13.0     13.0      0.0    eta1B  = np.zeros_like(f)
   421                                           
   422                                             # 1B - 1B
   423         1         55.0     55.0      0.0    eta1B += commutator(fd, fod)
   424                                           
   425                                             # 1B - 2B
   426        13         10.0      0.8      0.0    for p in range(dim1B):
   427       156        129.0      0.8      0.0      for q in range(dim1B):
   428      1008        920.0      0.9      0.0        for i in holes:
   429      6048       5634.0      0.9      0.2          for a in particles:
   430      5184       4691.0      0.9      0.1            eta1B[p,q] += (
   431                                                       fd[i,a]  * Gammaod[idx2B[(a, p)], idx2B[(i, q)]] 
   432                                                       - fd[a,i]  * Gammaod[idx2B[(i, p)], idx2B[(a, q)]] 
   433                                                       - fod[i,a] * Gammad[idx2B[(a, p)], idx2B[(i, q)]] 
   434      5184      25231.0      4.9      0.7              + fod[a,i] * Gammad[idx2B[(i, p)], idx2B[(a, q)]]
   435                                                     )
   436                                           
   437                                             # 2B - 2B
   438                                             # n_a n_b nn_c + nn_a nn_b n_c = n_a n_b + (1 - n_a - n_b) * n_c
   439         1        433.0    433.0      0.0    GammaGamma = dot(Gammad, dot(occB_2B, Gammaod))
   440        13         19.0      1.5      0.0    for p in range(dim1B):
   441       156        214.0      1.4      0.0      for q in range(dim1B):
   442      1008       1722.0      1.7      0.0        for i in holes:
   443       864       1395.0      1.6      0.0          eta1B[p,q] += (
   444       864       2396.0      2.8      0.1            0.5*GammaGamma[idx2B[(i,p)], idx2B[(i,q)]] 
   445       864       4460.0      5.2      0.1            - transpose(GammaGamma)[idx2B[(i,p)], idx2B[(i,q)]]
   446                                                   )
   447                                           
   448         1        362.0    362.0      0.0    GammaGamma = dot(Gammad, dot(occC_2B, Gammaod))
   449        13         19.0      1.5      0.0    for p in range(dim1B):
   450       156        218.0      1.4      0.0      for q in range(dim1B):
   451      1872       2651.0      1.4      0.1        for r in range(dim1B):
   452      1728       2789.0      1.6      0.1          eta1B[p,q] += (
   453      1728       5303.0      3.1      0.2            0.5*GammaGamma[idx2B[(r,p)], idx2B[(r,q)]] 
   454      1728       9392.0      5.4      0.3            + transpose(GammaGamma)[idx2B[(r,p)], idx2B[(r,q)]] 
   455                                                   )
   456                                           
   457                                           
   458                                             #############################        
   459                                             # two-body flow equation  
   460         1         34.0     34.0      0.0    eta2B = np.zeros_like(Gamma)
   461                                           
   462                                             # 1B - 2B
   463        13         12.0      0.9      0.0    for p in range(dim1B):
   464       156        139.0      0.9      0.0      for q in range(dim1B):
   465      1872       1584.0      0.8      0.0        for r in range(dim1B):
   466     22464      18872.0      0.8      0.5          for s in range(dim1B):
   467    269568     226115.0      0.8      6.4            for t in range(dim1B):
   468    248832     413704.0      1.7     11.8              eta2B[idx2B[(p,q)],idx2B[(r,s)]] += (
   469                                                         fd[p,t] * Gammaod[idx2B[(t,q)],idx2B[(r,s)]] 
   470                                                         + fd[q,t] * Gammaod[idx2B[(p,t)],idx2B[(r,s)]] 
   471                                                         - fd[t,r] * Gammaod[idx2B[(p,q)],idx2B[(t,s)]] 
   472                                                         - fd[t,s] * Gammaod[idx2B[(p,q)],idx2B[(r,t)]]
   473                                                         - fod[p,t] * Gammad[idx2B[(t,q)],idx2B[(r,s)]] 
   474                                                         - fod[q,t] * Gammad[idx2B[(p,t)],idx2B[(r,s)]] 
   475                                                         + fod[t,r] * Gammad[idx2B[(p,q)],idx2B[(t,s)]] 
   476    248832    2452299.0      9.9     69.7                + fod[t,s] * Gammad[idx2B[(p,q)],idx2B[(r,t)]]
   477                                                       )
   478                                           
   479                                             
   480                                             # 2B - 2B - particle and hole ladders
   481                                             # Gammad.occB.Gammaod
   482         1        449.0    449.0      0.0    GammaGamma = dot(Gammad, dot(occB_2B, Gammaod))
   483                                           
   484         1        143.0    143.0      0.0    eta2B += 0.5 * (GammaGamma - transpose(GammaGamma))
   485                                           
   486                                             # 2B - 2B - particle-hole chain
   487                                             
   488                                             # transform matrices to particle-hole representation and calculate 
   489                                             # Gammad_ph.occA_ph.Gammaod_ph
   490         1      91919.0  91919.0      2.6    Gammad_ph = ph_transform_2B(Gammad, bas2B, idx2B, basph2B, idxph2B)
   491         1      54564.0  54564.0      1.6    Gammaod_ph = ph_transform_2B(Gammaod, bas2B, idx2B, basph2B, idxph2B)
   492                                           
   493         1        482.0    482.0      0.0    GammaGamma_ph = dot(Gammad_ph, dot(occphA_2B, Gammaod_ph))
   494                                           
   495                                             # transform back to standard representation
   496         1      89721.0  89721.0      2.6    GammaGamma    = inverse_ph_transform_2B(GammaGamma_ph, bas2B, idx2B, basph2B, idxph2B)
   497                                           
   498                                             # commutator / antisymmetrization
   499         1         45.0     45.0      0.0    work = np.zeros_like(GammaGamma)
   500       145        137.0      0.9      0.0    for i1, (i,j) in enumerate(bas2B):
   501     20880      18606.0      0.9      0.5      for i2, (k,l) in enumerate(bas2B):
   502     20736      19889.0      1.0      0.6        work[i1, i2] -= (
   503                                                   GammaGamma[i1, i2] 
   504                                                   - GammaGamma[idx2B[(j,i)], i2] 
   505                                                   - GammaGamma[i1, idx2B[(l,k)]] 
   506     20736      54239.0      2.6      1.5          + GammaGamma[idx2B[(j,i)], idx2B[(l,k)]]
   507                                                 )
   508         1          2.0      2.0      0.0    GammaGamma = work
   509                                           
   510         1         42.0     42.0      0.0    eta2B += GammaGamma
   511                                           
   512                                           
   513         1          1.0      1.0      0.0    return eta1B, eta2B

Total time: 3.69721 s
File: imsrg_pairing_bench.py
Function: flow_imsrg2 at line 519

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   519                                           @profile
   520                                           def flow_imsrg2(eta1B, eta2B, f, Gamma, user_data):
   521                                           
   522         1          1.0      1.0      0.0    dim1B     = user_data["dim1B"]
   523         1          1.0      1.0      0.0    holes     = user_data["holes"]
   524         1          1.0      1.0      0.0    particles = user_data["particles"]
   525         1          1.0      1.0      0.0    bas2B     = user_data["bas2B"]
   526         1          1.0      1.0      0.0    idx2B     = user_data["idx2B"]
   527         1          0.0      0.0      0.0    basph2B   = user_data["basph2B"]
   528         1          1.0      1.0      0.0    idxph2B   = user_data["idxph2B"]
   529         1          0.0      0.0      0.0    occB_2B   = user_data["occB_2B"]
   530         1          1.0      1.0      0.0    occC_2B   = user_data["occC_2B"]
   531         1          1.0      1.0      0.0    occphA_2B = user_data["occphA_2B"]
   532                                           
   533                                             #############################        
   534                                             # zero-body flow equation
   535         1          1.0      1.0      0.0    dE = 0.0
   536                                           
   537         7          9.0      1.3      0.0    for i in holes:
   538        42         44.0      1.0      0.0      for a in particles:
   539        36         66.0      1.8      0.0        dE += eta1B[i,a] * f[a,i] - eta1B[a,i] * f[i,a]
   540                                           
   541         7          6.0      0.9      0.0    for i in holes:
   542        42         34.0      0.8      0.0      for j in holes:
   543       252        246.0      1.0      0.0        for a in particles:
   544      1512       1423.0      0.9      0.0          for b in particles:
   545      1296       2564.0      2.0      0.1            dE += 0.5 * eta2B[idx2B[(i,j)], idx2B[(a,b)]] * Gamma[idx2B[(a,b)], idx2B[(i,j)]]
   546                                           
   547                                           
   548                                             #############################        
   549                                             # one-body flow equation  
   550         1         38.0     38.0      0.0    df  = np.zeros_like(f)
   551                                           
   552                                             # 1B - 1B
   553         1         26.0     26.0      0.0    df += commutator(eta1B, f)
   554                                           
   555                                             # 1B - 2B
   556        13         15.0      1.2      0.0    for p in range(dim1B):
   557       156        129.0      0.8      0.0      for q in range(dim1B):
   558      1008        937.0      0.9      0.0        for i in holes:
   559      6048       5716.0      0.9      0.2          for a in particles:
   560      5184       4637.0      0.9      0.1            df[p,q] += (
   561                                                       eta1B[i,a] * Gamma[idx2B[(a, p)], idx2B[(i, q)]] 
   562                                                       - eta1B[a,i] * Gamma[idx2B[(i, p)], idx2B[(a, q)]] 
   563                                                       - f[i,a] * eta2B[idx2B[(a, p)], idx2B[(i, q)]] 
   564      5184      24890.0      4.8      0.7              + f[a,i] * eta2B[idx2B[(i, p)], idx2B[(a, q)]]
   565                                                     )
   566                                           
   567                                             # 2B - 2B
   568                                             # n_a n_b nn_c + nn_a nn_b n_c = n_a n_b + (1 - n_a - n_b) * n_c
   569         1        397.0    397.0      0.0    etaGamma = dot(eta2B, dot(occB_2B, Gamma))
   570        13         20.0      1.5      0.0    for p in range(dim1B):
   571       156        229.0      1.5      0.0      for q in range(dim1B):
   572      1008       1728.0      1.7      0.0        for i in holes:
   573       864       1465.0      1.7      0.0          df[p,q] += 0.5*(
   574       864       2286.0      2.6      0.1            etaGamma[idx2B[(i,p)], idx2B[(i,q)]] 
   575       864       4722.0      5.5      0.1            + transpose(etaGamma)[idx2B[(i,p)], idx2B[(i,q)]]
   576                                                   )
   577                                           
   578         1        272.0    272.0      0.0    etaGamma = dot(eta2B, dot(occC_2B, Gamma))
   579        13         19.0      1.5      0.0    for p in range(dim1B):
   580       156        233.0      1.5      0.0      for q in range(dim1B):
   581      1872       2739.0      1.5      0.1        for r in range(dim1B):
   582      1728       2881.0      1.7      0.1          df[p,q] += 0.5*(
   583      1728       5132.0      3.0      0.1            etaGamma[idx2B[(r,p)], idx2B[(r,q)]] 
   584      1728      10071.0      5.8      0.3            + transpose(etaGamma)[idx2B[(r,p)], idx2B[(r,q)]] 
   585                                                   )
   586                                           
   587                                           
   588                                             #############################        
   589                                             # two-body flow equation  
   590         1         32.0     32.0      0.0    dGamma = np.zeros_like(Gamma)
   591                                           
   592                                             # 1B - 2B
   593        13         14.0      1.1      0.0    for p in range(dim1B):
   594       156        183.0      1.2      0.0      for q in range(dim1B):
   595      1872       1662.0      0.9      0.0        for r in range(dim1B):
   596     22464      19902.0      0.9      0.5          for s in range(dim1B):
   597    269568     246743.0      0.9      6.7            for t in range(dim1B):
   598    248832     440549.0      1.8     11.9              dGamma[idx2B[(p,q)],idx2B[(r,s)]] += (
   599                                                         eta1B[p,t] * Gamma[idx2B[(t,q)],idx2B[(r,s)]] 
   600                                                         + eta1B[q,t] * Gamma[idx2B[(p,t)],idx2B[(r,s)]] 
   601                                                         - eta1B[t,r] * Gamma[idx2B[(p,q)],idx2B[(t,s)]] 
   602                                                         - eta1B[t,s] * Gamma[idx2B[(p,q)],idx2B[(r,t)]]
   603                                                         - f[p,t] * eta2B[idx2B[(t,q)],idx2B[(r,s)]] 
   604                                                         - f[q,t] * eta2B[idx2B[(p,t)],idx2B[(r,s)]] 
   605                                                         + f[t,r] * eta2B[idx2B[(p,q)],idx2B[(t,s)]] 
   606    248832    2584818.0     10.4     69.9                + f[t,s] * eta2B[idx2B[(p,q)],idx2B[(r,t)]]
   607                                                       )
   608                                           
   609                                             
   610                                             # 2B - 2B - particle and hole ladders
   611                                             # eta2B.occB.Gamma
   612         1        335.0    335.0      0.0    etaGamma = dot(eta2B, dot(occB_2B, Gamma))
   613                                           
   614         1        136.0    136.0      0.0    dGamma += 0.5 * (etaGamma + transpose(etaGamma))
   615                                           
   616                                             # 2B - 2B - particle-hole chain
   617                                             
   618                                             # transform matrices to particle-hole representation and calculate 
   619                                             # eta2B_ph.occA_ph.Gamma_ph
   620         1      92084.0  92084.0      2.5    eta2B_ph = ph_transform_2B(eta2B, bas2B, idx2B, basph2B, idxph2B)
   621         1      55709.0  55709.0      1.5    Gamma_ph = ph_transform_2B(Gamma, bas2B, idx2B, basph2B, idxph2B)
   622                                           
   623         1        335.0    335.0      0.0    etaGamma_ph = dot(eta2B_ph, dot(occphA_2B, Gamma_ph))
   624                                           
   625                                             # transform back to standard representation
   626         1      87737.0  87737.0      2.4    etaGamma    = inverse_ph_transform_2B(etaGamma_ph, bas2B, idx2B, basph2B, idxph2B)
   627                                           
   628                                             # commutator / antisymmetrization
   629         1         45.0     45.0      0.0    work = np.zeros_like(etaGamma)
   630       145        131.0      0.9      0.0    for i1, (i,j) in enumerate(bas2B):
   631     20880      18952.0      0.9      0.5      for i2, (k,l) in enumerate(bas2B):
   632     20736      20010.0      1.0      0.5        work[i1, i2] -= (
   633                                                   etaGamma[i1, i2] 
   634                                                   - etaGamma[idx2B[(j,i)], i2] 
   635                                                   - etaGamma[i1, idx2B[(l,k)]] 
   636     20736      54811.0      2.6      1.5          + etaGamma[idx2B[(j,i)], idx2B[(l,k)]]
   637                                                 )
   638         1          1.0      1.0      0.0    etaGamma = work
   639                                           
   640         1         38.0     38.0      0.0    dGamma += etaGamma
   641                                           
   642                                           
   643         1          1.0      1.0      0.0    return dE, df, dGamma

Total time: 3.1e-05 s
File: imsrg_pairing_bench.py
Function: get_operator_from_y at line 649

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   649                                           @profile
   650                                           def get_operator_from_y(y, dim1B, dim2B):
   651                                             
   652                                             # reshape the solution vector into 0B, 1B, 2B pieces
   653         2          2.0      1.0      6.5    ptr = 0
   654         2          3.0      1.5      9.7    zero_body = y[ptr]
   655                                           
   656         2          2.0      1.0      6.5    ptr += 1
   657         2         14.0      7.0     45.2    one_body = reshape(y[ptr:ptr+dim1B*dim1B], (dim1B, dim1B))
   658                                           
   659         2          2.0      1.0      6.5    ptr += dim1B*dim1B
   660         2          7.0      3.5     22.6    two_body = reshape(y[ptr:ptr+dim2B*dim2B], (dim2B, dim2B))
   661                                           
   662         2          1.0      0.5      3.2    return zero_body,one_body,two_body

Total time: 0.001761 s
File: imsrg_pairing_bench.py
Function: pairing_hamiltonian at line 707

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   707                                           @profile
   708                                           def pairing_hamiltonian(delta, g, user_data):
   709         1          1.0      1.0      0.1    bas1B = user_data["bas1B"]
   710         1          1.0      1.0      0.1    bas2B = user_data["bas2B"]
   711         1          1.0      1.0      0.1    idx2B = user_data["idx2B"]
   712                                           
   713         1          0.0      0.0      0.0    dim = len(bas1B)
   714         1          2.0      2.0      0.1    H1B = np.zeros((dim,dim))
   715                                           
   716        13          2.0      0.2      0.1    for i in bas1B:
   717        12         34.0      2.8      1.9      H1B[i,i] = delta*np.floor_divide(i, 2)
   718                                           
   719         1          1.0      1.0      0.1    dim = len(bas2B)
   720         1         48.0     48.0      2.7    H2B = np.zeros((dim, dim))
   721                                           
   722                                             # spin up states have even indices, spin down the next odd index
   723       145         84.0      0.6      4.8    for (i, j) in bas2B:
   724       144        144.0      1.0      8.2      if (i % 2 == 0 and j == i+1):
   725       870        474.0      0.5     26.9        for (k, l) in bas2B:
   726       864        824.0      1.0     46.8          if (k % 2 == 0 and l == k+1):
   727        36         38.0      1.1      2.2            H2B[idx2B[(i,j)],idx2B[(k,l)]] = -0.5*g
   728        36         35.0      1.0      2.0            H2B[idx2B[(j,i)],idx2B[(k,l)]] = 0.5*g
   729        36         34.0      0.9      1.9            H2B[idx2B[(i,j)],idx2B[(l,k)]] = 0.5*g
   730        36         37.0      1.0      2.1            H2B[idx2B[(j,i)],idx2B[(l,k)]] = -0.5*g
   731                                             
   732         1          1.0      1.0      0.1    return H1B, H2B

Total time: 0.002185 s
File: imsrg_pairing_bench.py
Function: normal_order at line 737

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   737                                           @profile
   738                                           def normal_order(H1B, H2B, user_data):
   739         1          1.0      1.0      0.0    bas1B     = user_data["bas1B"]
   740         1          1.0      1.0      0.0    bas2B     = user_data["bas2B"]
   741         1          0.0      0.0      0.0    idx2B     = user_data["idx2B"]
   742         1          1.0      1.0      0.0    particles = user_data["particles"]
   743         1          1.0      1.0      0.0    holes     = user_data["holes"]
   744                                           
   745                                             # 0B part
   746         1          1.0      1.0      0.0    E = 0.0
   747         7          6.0      0.9      0.3    for i in holes:
   748         6          6.0      1.0      0.3      E += H1B[i,i]
   749                                           
   750         7          5.0      0.7      0.2    for i in holes:
   751        42         27.0      0.6      1.2      for j in holes:
   752        36         41.0      1.1      1.9        E += 0.5*H2B[idx2B[(i,j)],idx2B[(i,j)]]  
   753                                           
   754                                             # 1B part
   755         1          0.0      0.0      0.0    f = H1B
   756        13          7.0      0.5      0.3    for i in bas1B:
   757       156         83.0      0.5      3.8      for j in bas1B:
   758      1008        671.0      0.7     30.7        for h in holes:
   759       864       1332.0      1.5     61.0          f[i,j] += H2B[idx2B[(i,h)],idx2B[(j,h)]]  
   760                                           
   761                                             # 2B part
   762         1          1.0      1.0      0.0    Gamma = H2B
   763                                           
   764         1          1.0      1.0      0.0    return E, f, Gamma

Total time: 8.97488 s
File: imsrg_pairing_bench.py
Function: main at line 831

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   831                                           @profile
   832                                           def main(n_holes):
   833                                             # grab delta and g from the command line
   834                                             # delta      = float(argv[1])
   835                                             # g          = float(argv[2])
   836         1          7.0      7.0      0.0    delta = 1
   837         1          2.0      2.0      0.0    g = 0.5
   838                                             
   839         1          2.0      2.0      0.0    particles  = n_holes
   840                                           
   841                                             # setup shared data
   842         1          1.0      1.0      0.0    dim1B     = n_holes*2
   843                                           
   844                                             # this defines the reference state
   845                                             # 1st state
   846         1          7.0      7.0      0.0    holes = np.arange(particles)
   847         1          3.0      3.0      0.0    particles = np.arange(particles,dim1B)
   848                                           
   849                                             # 2nd state
   850                                             # holes     = [0,1,4,5]
   851                                             # particles = [2,3,6,7]
   852                                           
   853                                             # 3rd state
   854                                             # holes     = [0,1,6,7]
   855                                             # particles = [2,3,4,5]
   856                                           
   857                                             # basis definitions
   858         1          3.0      3.0      0.0    bas1B     = list(range(dim1B))
   859         1        267.0    267.0      0.0    bas2B     = construct_basis_2B(holes, particles)
   860         1        259.0    259.0      0.0    basph2B   = construct_basis_ph2B(holes, particles)
   861                                           
   862         1        176.0    176.0      0.0    idx2B     = construct_index_2B(bas2B)
   863         1        172.0    172.0      0.0    idxph2B   = construct_index_2B(basph2B)
   864                                           
   865                                             # occupation number matrices
   866         1         25.0     25.0      0.0    occ1B     = construct_occupation_1B(bas1B, holes, particles)
   867         1        326.0    326.0      0.0    occA_2B   = construct_occupationA_2B(bas2B, occ1B)
   868         1        376.0    376.0      0.0    occB_2B   = construct_occupationB_2B(bas2B, occ1B)
   869         1        318.0    318.0      0.0    occC_2B   = construct_occupationC_2B(bas2B, occ1B)
   870                                           
   871         1        317.0    317.0      0.0    occphA_2B = construct_occupationA_2B(basph2B, occ1B)
   872                                           
   873                                             # store shared data in a dictionary, so we can avoid passing the basis
   874                                             # lookups etc. as separate parameters all the time
   875                                             user_data  = {
   876         1          1.0      1.0      0.0      "dim1B":      dim1B, 
   877         1          1.0      1.0      0.0      "holes":      holes,
   878         1          1.0      1.0      0.0      "particles":  particles,
   879         1          1.0      1.0      0.0      "bas1B":      bas1B,
   880         1          1.0      1.0      0.0      "bas2B":      bas2B,
   881         1          1.0      1.0      0.0      "basph2B":    basph2B,
   882         1          1.0      1.0      0.0      "idx2B":      idx2B,
   883         1          0.0      0.0      0.0      "idxph2B":    idxph2B,
   884         1          0.0      0.0      0.0      "occ1B":      occ1B,
   885         1          0.0      0.0      0.0      "occA_2B":    occA_2B,
   886         1          1.0      1.0      0.0      "occB_2B":    occB_2B,
   887         1          1.0      1.0      0.0      "occC_2B":    occC_2B,
   888         1          1.0      1.0      0.0      "occphA_2B":  occphA_2B,
   889                                           
   890         1          1.0      1.0      0.0      "eta_norm":   0.0,                # variables for sharing data between ODE solver
   891         1          1.0      1.0      0.0      "dE":         0.0,                # and main routine
   892                                           
   893                                           
   894         1          1.0      1.0      0.0      "calc_eta":   eta_wegner,          # specify the generator (function object)
   895         1          2.0      2.0      0.0      "calc_rhs":   flow_imsrg2         # specify the right-hand side and truncation
   896                                             }
   897                                           
   898                                             # set up initial Hamiltonian
   899         1       3187.0   3187.0      0.0    H1B, H2B = pairing_hamiltonian(delta, g, user_data)
   900                                             
   901         1       3479.0   3479.0      0.0    E, f, Gamma = normal_order(H1B, H2B, user_data) 
   902                                           
   903                                             # reshape Hamiltonian into a linear array (initial ODE vector)
   904         1        210.0    210.0      0.0    y0   = np.append([E], np.append(reshape(f, -1), reshape(Gamma, -1)))
   905                                           
   906         1          1.0      1.0      0.0    t = 1
   907         1    8965659.0 8965659.0     99.9    dy = derivative_wrapper(t, y0, user_data)
   908         1         45.0     45.0      0.0    dE, df, dG = get_operator_from_y(dy, dim1B, dim1B*dim1B)
   909         1         20.0     20.0      0.0    print(dE)

-5.625
Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
    30   76.348 MiB   76.348 MiB   @profile
    31                             def construct_basis_2B(holes, particles):
    32   76.348 MiB    0.000 MiB     basis = []
    33   76.348 MiB    0.000 MiB     for i in holes:
    34   76.348 MiB    0.000 MiB       for j in holes:
    35   76.348 MiB    0.000 MiB         basis.append((i, j)) # hole, hole
    36                             
    37   76.348 MiB    0.000 MiB     for i in holes:
    38   76.348 MiB    0.000 MiB       for a in particles:
    39   76.348 MiB    0.000 MiB         basis.append((i, a)) # hole, particle
    40                             
    41   76.348 MiB    0.000 MiB     for a in particles:
    42   76.348 MiB    0.000 MiB       for i in holes:
    43   76.348 MiB    0.000 MiB         basis.append((a, i)) # particle, hole
    44                             
    45   76.348 MiB    0.000 MiB     for a in particles:
    46   76.348 MiB    0.000 MiB       for b in particles:
    47   76.348 MiB    0.000 MiB         basis.append((a, b)) # particle, particle
    48                             
    49   76.348 MiB    0.000 MiB     return basis


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
    52   76.348 MiB   76.348 MiB   @profile
    53                             def construct_basis_ph2B(holes, particles):
    54   76.348 MiB    0.000 MiB     basis = []
    55   76.348 MiB    0.000 MiB     for i in holes:
    56   76.348 MiB    0.000 MiB       for j in holes:
    57   76.348 MiB    0.000 MiB         basis.append((i, j))
    58                             
    59   76.348 MiB    0.000 MiB     for i in holes:
    60   76.348 MiB    0.000 MiB       for a in particles:
    61   76.348 MiB    0.000 MiB         basis.append((i, a))
    62                             
    63   76.348 MiB    0.000 MiB     for a in particles:
    64   76.348 MiB    0.000 MiB       for i in holes:
    65   76.348 MiB    0.000 MiB         basis.append((a, i))
    66                             
    67   76.348 MiB    0.000 MiB     for a in particles:
    68   76.348 MiB    0.000 MiB       for b in particles:
    69   76.348 MiB    0.000 MiB         basis.append((a, b))
    70                             
    71   76.348 MiB    0.000 MiB     return basis


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
    77   76.348 MiB   76.348 MiB   @profile
    78                             def construct_index_2B(bas2B):
    79   76.348 MiB    0.000 MiB     index = { }
    80   76.348 MiB    0.000 MiB     for i, state in enumerate(bas2B):
    81   76.348 MiB    0.000 MiB       index[state] = i
    82                             
    83   76.348 MiB    0.000 MiB     return index


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
    90   79.191 MiB   79.191 MiB   @profile
    91                             def ph_transform_2B(Gamma, bas2B, idx2B, basph2B, idxph2B):
    92   79.191 MiB    0.000 MiB     dim = len(basph2B)
    93   79.191 MiB    0.000 MiB     Gamma_ph = np.zeros((dim, dim))
    94                             
    95   79.191 MiB    0.000 MiB     for i1, (a,b) in enumerate(basph2B):
    96   79.191 MiB    0.000 MiB       for i2, (c, d) in enumerate(basph2B):
    97   79.191 MiB    0.000 MiB         Gamma_ph[i1, i2] -= Gamma[idx2B[(a,d)], idx2B[(c,b)]]
    98                             
    99   79.191 MiB    0.000 MiB     return Gamma_ph


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   101   79.191 MiB   79.191 MiB   @profile
   102                             def inverse_ph_transform_2B(Gamma_ph, bas2B, idx2B, basph2B, idxph2B):
   103   79.191 MiB    0.000 MiB     dim = len(bas2B)
   104   79.191 MiB    0.000 MiB     Gamma = np.zeros((dim, dim))
   105                             
   106   79.191 MiB    0.000 MiB     for i1, (a,b) in enumerate(bas2B):
   107   79.191 MiB    0.000 MiB       for i2, (c, d) in enumerate(bas2B):
   108   79.191 MiB    0.000 MiB         Gamma[i1, i2] -= Gamma_ph[idxph2B[(a,d)], idxph2B[(c,b)]]
   109                               
   110   79.191 MiB    0.000 MiB     return Gamma


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   115   79.191 MiB   79.191 MiB   @profile
   116                             def commutator(a,b):
   117   79.191 MiB    0.000 MiB     return dot(a,b) - dot(b,a)


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   150   76.348 MiB   76.348 MiB   @profile
   151                             def construct_occupation_1B(bas1B, holes, particles):
   152   76.348 MiB    0.000 MiB     dim = len(bas1B)
   153   76.348 MiB    0.000 MiB     occ = np.zeros(dim)
   154                             
   155   76.348 MiB    0.000 MiB     for i in holes:
   156   76.348 MiB    0.000 MiB       occ[i] = 1.
   157                             
   158   76.348 MiB    0.000 MiB     return occ


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   161   76.820 MiB   76.820 MiB   @profile
   162                             def construct_occupationA_2B(bas2B, occ1B):
   163   76.820 MiB    0.000 MiB     dim = len(bas2B)
   164   76.820 MiB    0.000 MiB     occ = np.zeros((dim,dim))
   165                             
   166   76.820 MiB    0.000 MiB     for i1, (i,j) in enumerate(bas2B):
   167   76.820 MiB    0.000 MiB       occ[i1, i1] = occ1B[i] - occ1B[j]
   168                             
   169   76.820 MiB    0.000 MiB     return occ


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   173   76.348 MiB   76.348 MiB   @profile
   174                             def construct_occupationB_2B(bas2B, occ1B):
   175   76.348 MiB    0.000 MiB     dim = len(bas2B)
   176   76.562 MiB    0.215 MiB     occ = np.zeros((dim,dim))
   177                             
   178   76.562 MiB    0.000 MiB     for i1, (i,j) in enumerate(bas2B):
   179   76.562 MiB    0.000 MiB       occ[i1, i1] = 1. - occ1B[i] - occ1B[j]
   180                             
   181   76.562 MiB    0.000 MiB     return occ


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   184   76.562 MiB   76.562 MiB   @profile
   185                             def construct_occupationC_2B(bas2B, occ1B):
   186   76.562 MiB    0.000 MiB     dim = len(bas2B)
   187   76.820 MiB    0.258 MiB     occ = np.zeros((dim,dim))
   188                             
   189   76.820 MiB    0.000 MiB     for i1, (i,j) in enumerate(bas2B):
   190   76.820 MiB    0.000 MiB       occ[i1, i1] = occ1B[i] * occ1B[j]
   191                             
   192   76.820 MiB    0.000 MiB     return occ


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   382   77.383 MiB   77.383 MiB   @profile
   383                             def eta_wegner(f, Gamma, user_data):
   384                             
   385   77.383 MiB    0.000 MiB     dim1B     = user_data["dim1B"]
   386   77.383 MiB    0.000 MiB     holes     = user_data["holes"]
   387   77.383 MiB    0.000 MiB     particles = user_data["particles"]
   388   77.383 MiB    0.000 MiB     bas2B     = user_data["bas2B"]
   389   77.383 MiB    0.000 MiB     basph2B   = user_data["basph2B"]
   390   77.383 MiB    0.000 MiB     idx2B     = user_data["idx2B"]
   391   77.383 MiB    0.000 MiB     idxph2B   = user_data["idxph2B"]
   392   77.383 MiB    0.000 MiB     occB_2B   = user_data["occB_2B"]
   393   77.383 MiB    0.000 MiB     occC_2B   = user_data["occC_2B"]
   394   77.383 MiB    0.000 MiB     occphA_2B = user_data["occphA_2B"]
   395                             
   396                             
   397                               # split Hamiltonian in diagonal and off-diagonal parts
   398   77.383 MiB    0.000 MiB     fd      = np.zeros_like(f)
   399   77.383 MiB    0.000 MiB     fod     = np.zeros_like(f)
   400   77.383 MiB    0.000 MiB     Gammad  = np.zeros_like(Gamma)
   401   77.641 MiB    0.258 MiB     Gammaod = np.zeros_like(Gamma)
   402                             
   403   77.641 MiB    0.000 MiB     for a in particles:
   404   77.641 MiB    0.000 MiB       for i in holes:
   405   77.641 MiB    0.000 MiB         fod[a, i] = f[a,i]
   406   77.641 MiB    0.000 MiB         fod[i, a] = f[i,a]
   407   77.641 MiB    0.000 MiB     fd = f - fod
   408                             
   409   77.641 MiB    0.000 MiB     for a in particles:
   410   77.641 MiB    0.000 MiB       for b in particles:
   411   77.641 MiB    0.000 MiB         for i in holes:
   412   77.641 MiB    0.000 MiB           for j in holes:
   413   77.641 MiB    0.000 MiB             Gammaod[idx2B[(a,b)], idx2B[(i,j)]] = Gamma[idx2B[(a,b)], idx2B[(i,j)]]
   414   77.641 MiB    0.000 MiB             Gammaod[idx2B[(i,j)], idx2B[(a,b)]] = Gamma[idx2B[(i,j)], idx2B[(a,b)]]
   415   77.641 MiB    0.000 MiB     Gammad = Gamma - Gammaod
   416                             
   417                             
   418                               #############################        
   419                               # one-body flow equation  
   420   77.641 MiB    0.000 MiB     eta1B  = np.zeros_like(f)
   421                             
   422                               # 1B - 1B
   423   77.641 MiB   77.641 MiB     eta1B += commutator(fd, fod)
   424                             
   425                               # 1B - 2B
   426   77.641 MiB    0.000 MiB     for p in range(dim1B):
   427   77.641 MiB    0.000 MiB       for q in range(dim1B):
   428   77.641 MiB    0.000 MiB         for i in holes:
   429   77.641 MiB    0.000 MiB           for a in particles:
   430   77.641 MiB    0.000 MiB             eta1B[p,q] += (
   431                                         fd[i,a]  * Gammaod[idx2B[(a, p)], idx2B[(i, q)]] 
   432                                         - fd[a,i]  * Gammaod[idx2B[(i, p)], idx2B[(a, q)]] 
   433                                         - fod[i,a] * Gammad[idx2B[(a, p)], idx2B[(i, q)]] 
   434   77.641 MiB    0.000 MiB               + fod[a,i] * Gammad[idx2B[(i, p)], idx2B[(a, q)]]
   435                                       )
   436                             
   437                               # 2B - 2B
   438                               # n_a n_b nn_c + nn_a nn_b n_c = n_a n_b + (1 - n_a - n_b) * n_c
   439   78.359 MiB    0.719 MiB     GammaGamma = dot(Gammad, dot(occB_2B, Gammaod))
   440   78.359 MiB    0.000 MiB     for p in range(dim1B):
   441   78.359 MiB    0.000 MiB       for q in range(dim1B):
   442   78.359 MiB    0.000 MiB         for i in holes:
   443   78.359 MiB    0.000 MiB           eta1B[p,q] += (
   444   78.359 MiB    0.000 MiB             0.5*GammaGamma[idx2B[(i,p)], idx2B[(i,q)]] 
   445   78.359 MiB    0.000 MiB             - transpose(GammaGamma)[idx2B[(i,p)], idx2B[(i,q)]]
   446                                     )
   447                             
   448   78.617 MiB    0.258 MiB     GammaGamma = dot(Gammad, dot(occC_2B, Gammaod))
   449   78.617 MiB    0.000 MiB     for p in range(dim1B):
   450   78.617 MiB    0.000 MiB       for q in range(dim1B):
   451   78.617 MiB    0.000 MiB         for r in range(dim1B):
   452   78.617 MiB    0.000 MiB           eta1B[p,q] += (
   453   78.617 MiB    0.000 MiB             0.5*GammaGamma[idx2B[(r,p)], idx2B[(r,q)]] 
   454   78.617 MiB    0.000 MiB             + transpose(GammaGamma)[idx2B[(r,p)], idx2B[(r,q)]] 
   455                                     )
   456                             
   457                             
   458                               #############################        
   459                               # two-body flow equation  
   460   78.617 MiB    0.000 MiB     eta2B = np.zeros_like(Gamma)
   461                             
   462                               # 1B - 2B
   463   78.617 MiB    0.000 MiB     for p in range(dim1B):
   464   78.617 MiB    0.000 MiB       for q in range(dim1B):
   465   78.617 MiB    0.000 MiB         for r in range(dim1B):
   466   78.617 MiB    0.000 MiB           for s in range(dim1B):
   467   78.617 MiB    0.000 MiB             for t in range(dim1B):
   468   78.617 MiB    0.000 MiB               eta2B[idx2B[(p,q)],idx2B[(r,s)]] += (
   469                                           fd[p,t] * Gammaod[idx2B[(t,q)],idx2B[(r,s)]] 
   470                                           + fd[q,t] * Gammaod[idx2B[(p,t)],idx2B[(r,s)]] 
   471                                           - fd[t,r] * Gammaod[idx2B[(p,q)],idx2B[(t,s)]] 
   472                                           - fd[t,s] * Gammaod[idx2B[(p,q)],idx2B[(r,t)]]
   473                                           - fod[p,t] * Gammad[idx2B[(t,q)],idx2B[(r,s)]] 
   474                                           - fod[q,t] * Gammad[idx2B[(p,t)],idx2B[(r,s)]] 
   475                                           + fod[t,r] * Gammad[idx2B[(p,q)],idx2B[(t,s)]] 
   476   78.617 MiB    0.000 MiB                 + fod[t,s] * Gammad[idx2B[(p,q)],idx2B[(r,t)]]
   477                                         )
   478                             
   479                               
   480                               # 2B - 2B - particle and hole ladders
   481                               # Gammad.occB.Gammaod
   482   78.617 MiB    0.000 MiB     GammaGamma = dot(Gammad, dot(occB_2B, Gammaod))
   483                             
   484   78.617 MiB    0.000 MiB     eta2B += 0.5 * (GammaGamma - transpose(GammaGamma))
   485                             
   486                               # 2B - 2B - particle-hole chain
   487                               
   488                               # transform matrices to particle-hole representation and calculate 
   489                               # Gammad_ph.occA_ph.Gammaod_ph
   490   78.617 MiB   78.617 MiB     Gammad_ph = ph_transform_2B(Gammad, bas2B, idx2B, basph2B, idxph2B)
   491   78.617 MiB   78.617 MiB     Gammaod_ph = ph_transform_2B(Gammaod, bas2B, idx2B, basph2B, idxph2B)
   492                             
   493   79.191 MiB    0.574 MiB     GammaGamma_ph = dot(Gammad_ph, dot(occphA_2B, Gammaod_ph))
   494                             
   495                               # transform back to standard representation
   496   79.191 MiB   79.191 MiB     GammaGamma    = inverse_ph_transform_2B(GammaGamma_ph, bas2B, idx2B, basph2B, idxph2B)
   497                             
   498                               # commutator / antisymmetrization
   499   79.191 MiB    0.000 MiB     work = np.zeros_like(GammaGamma)
   500   79.191 MiB    0.000 MiB     for i1, (i,j) in enumerate(bas2B):
   501   79.191 MiB    0.000 MiB       for i2, (k,l) in enumerate(bas2B):
   502   79.191 MiB    0.000 MiB         work[i1, i2] -= (
   503                                     GammaGamma[i1, i2] 
   504                                     - GammaGamma[idx2B[(j,i)], i2] 
   505                                     - GammaGamma[i1, idx2B[(l,k)]] 
   506   79.191 MiB    0.000 MiB           + GammaGamma[idx2B[(j,i)], idx2B[(l,k)]]
   507                                   )
   508   79.191 MiB    0.000 MiB     GammaGamma = work
   509                             
   510   79.191 MiB    0.000 MiB     eta2B += GammaGamma
   511                             
   512                             
   513   79.191 MiB    0.000 MiB     return eta1B, eta2B


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   519   79.191 MiB   79.191 MiB   @profile
   520                             def flow_imsrg2(eta1B, eta2B, f, Gamma, user_data):
   521                             
   522   79.191 MiB    0.000 MiB     dim1B     = user_data["dim1B"]
   523   79.191 MiB    0.000 MiB     holes     = user_data["holes"]
   524   79.191 MiB    0.000 MiB     particles = user_data["particles"]
   525   79.191 MiB    0.000 MiB     bas2B     = user_data["bas2B"]
   526   79.191 MiB    0.000 MiB     idx2B     = user_data["idx2B"]
   527   79.191 MiB    0.000 MiB     basph2B   = user_data["basph2B"]
   528   79.191 MiB    0.000 MiB     idxph2B   = user_data["idxph2B"]
   529   79.191 MiB    0.000 MiB     occB_2B   = user_data["occB_2B"]
   530   79.191 MiB    0.000 MiB     occC_2B   = user_data["occC_2B"]
   531   79.191 MiB    0.000 MiB     occphA_2B = user_data["occphA_2B"]
   532                             
   533                               #############################        
   534                               # zero-body flow equation
   535   79.191 MiB    0.000 MiB     dE = 0.0
   536                             
   537   79.191 MiB    0.000 MiB     for i in holes:
   538   79.191 MiB    0.000 MiB       for a in particles:
   539   79.191 MiB    0.000 MiB         dE += eta1B[i,a] * f[a,i] - eta1B[a,i] * f[i,a]
   540                             
   541   79.191 MiB    0.000 MiB     for i in holes:
   542   79.191 MiB    0.000 MiB       for j in holes:
   543   79.191 MiB    0.000 MiB         for a in particles:
   544   79.191 MiB    0.000 MiB           for b in particles:
   545   79.191 MiB    0.000 MiB             dE += 0.5 * eta2B[idx2B[(i,j)], idx2B[(a,b)]] * Gamma[idx2B[(a,b)], idx2B[(i,j)]]
   546                             
   547                             
   548                               #############################        
   549                               # one-body flow equation  
   550   79.191 MiB    0.000 MiB     df  = np.zeros_like(f)
   551                             
   552                               # 1B - 1B
   553   79.191 MiB   79.191 MiB     df += commutator(eta1B, f)
   554                             
   555                               # 1B - 2B
   556   79.191 MiB    0.000 MiB     for p in range(dim1B):
   557   79.191 MiB    0.000 MiB       for q in range(dim1B):
   558   79.191 MiB    0.000 MiB         for i in holes:
   559   79.191 MiB    0.000 MiB           for a in particles:
   560   79.191 MiB    0.000 MiB             df[p,q] += (
   561                                         eta1B[i,a] * Gamma[idx2B[(a, p)], idx2B[(i, q)]] 
   562                                         - eta1B[a,i] * Gamma[idx2B[(i, p)], idx2B[(a, q)]] 
   563                                         - f[i,a] * eta2B[idx2B[(a, p)], idx2B[(i, q)]] 
   564   79.191 MiB    0.000 MiB               + f[a,i] * eta2B[idx2B[(i, p)], idx2B[(a, q)]]
   565                                       )
   566                             
   567                               # 2B - 2B
   568                               # n_a n_b nn_c + nn_a nn_b n_c = n_a n_b + (1 - n_a - n_b) * n_c
   569   79.191 MiB    0.000 MiB     etaGamma = dot(eta2B, dot(occB_2B, Gamma))
   570   79.191 MiB    0.000 MiB     for p in range(dim1B):
   571   79.191 MiB    0.000 MiB       for q in range(dim1B):
   572   79.191 MiB    0.000 MiB         for i in holes:
   573   79.191 MiB    0.000 MiB           df[p,q] += 0.5*(
   574   79.191 MiB    0.000 MiB             etaGamma[idx2B[(i,p)], idx2B[(i,q)]] 
   575   79.191 MiB    0.000 MiB             + transpose(etaGamma)[idx2B[(i,p)], idx2B[(i,q)]]
   576                                     )
   577                             
   578   79.191 MiB    0.000 MiB     etaGamma = dot(eta2B, dot(occC_2B, Gamma))
   579   79.191 MiB    0.000 MiB     for p in range(dim1B):
   580   79.191 MiB    0.000 MiB       for q in range(dim1B):
   581   79.191 MiB    0.000 MiB         for r in range(dim1B):
   582   79.191 MiB    0.000 MiB           df[p,q] += 0.5*(
   583   79.191 MiB    0.000 MiB             etaGamma[idx2B[(r,p)], idx2B[(r,q)]] 
   584   79.191 MiB    0.000 MiB             + transpose(etaGamma)[idx2B[(r,p)], idx2B[(r,q)]] 
   585                                     )
   586                             
   587                             
   588                               #############################        
   589                               # two-body flow equation  
   590   79.191 MiB    0.000 MiB     dGamma = np.zeros_like(Gamma)
   591                             
   592                               # 1B - 2B
   593   79.191 MiB    0.000 MiB     for p in range(dim1B):
   594   79.191 MiB    0.000 MiB       for q in range(dim1B):
   595   79.191 MiB    0.000 MiB         for r in range(dim1B):
   596   79.191 MiB    0.000 MiB           for s in range(dim1B):
   597   79.191 MiB    0.000 MiB             for t in range(dim1B):
   598   79.191 MiB    0.000 MiB               dGamma[idx2B[(p,q)],idx2B[(r,s)]] += (
   599                                           eta1B[p,t] * Gamma[idx2B[(t,q)],idx2B[(r,s)]] 
   600                                           + eta1B[q,t] * Gamma[idx2B[(p,t)],idx2B[(r,s)]] 
   601                                           - eta1B[t,r] * Gamma[idx2B[(p,q)],idx2B[(t,s)]] 
   602                                           - eta1B[t,s] * Gamma[idx2B[(p,q)],idx2B[(r,t)]]
   603                                           - f[p,t] * eta2B[idx2B[(t,q)],idx2B[(r,s)]] 
   604                                           - f[q,t] * eta2B[idx2B[(p,t)],idx2B[(r,s)]] 
   605                                           + f[t,r] * eta2B[idx2B[(p,q)],idx2B[(t,s)]] 
   606   79.191 MiB    0.000 MiB                 + f[t,s] * eta2B[idx2B[(p,q)],idx2B[(r,t)]]
   607                                         )
   608                             
   609                               
   610                               # 2B - 2B - particle and hole ladders
   611                               # eta2B.occB.Gamma
   612   79.191 MiB    0.000 MiB     etaGamma = dot(eta2B, dot(occB_2B, Gamma))
   613                             
   614   79.191 MiB    0.000 MiB     dGamma += 0.5 * (etaGamma + transpose(etaGamma))
   615                             
   616                               # 2B - 2B - particle-hole chain
   617                               
   618                               # transform matrices to particle-hole representation and calculate 
   619                               # eta2B_ph.occA_ph.Gamma_ph
   620   79.191 MiB   79.191 MiB     eta2B_ph = ph_transform_2B(eta2B, bas2B, idx2B, basph2B, idxph2B)
   621   79.191 MiB   79.191 MiB     Gamma_ph = ph_transform_2B(Gamma, bas2B, idx2B, basph2B, idxph2B)
   622                             
   623   79.191 MiB    0.000 MiB     etaGamma_ph = dot(eta2B_ph, dot(occphA_2B, Gamma_ph))
   624                             
   625                               # transform back to standard representation
   626   79.191 MiB   79.191 MiB     etaGamma    = inverse_ph_transform_2B(etaGamma_ph, bas2B, idx2B, basph2B, idxph2B)
   627                             
   628                               # commutator / antisymmetrization
   629   79.191 MiB    0.000 MiB     work = np.zeros_like(etaGamma)
   630   79.191 MiB    0.000 MiB     for i1, (i,j) in enumerate(bas2B):
   631   79.191 MiB    0.000 MiB       for i2, (k,l) in enumerate(bas2B):
   632   79.191 MiB    0.000 MiB         work[i1, i2] -= (
   633                                     etaGamma[i1, i2] 
   634                                     - etaGamma[idx2B[(j,i)], i2] 
   635                                     - etaGamma[i1, idx2B[(l,k)]] 
   636   79.191 MiB    0.000 MiB           + etaGamma[idx2B[(j,i)], idx2B[(l,k)]]
   637                                   )
   638   79.191 MiB    0.000 MiB     etaGamma = work
   639                             
   640   79.191 MiB    0.000 MiB     dGamma += etaGamma
   641                             
   642                             
   643   79.191 MiB    0.000 MiB     return dE, df, dGamma


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   649   79.191 MiB   79.191 MiB   @profile
   650                             def get_operator_from_y(y, dim1B, dim2B):
   651                               
   652                               # reshape the solution vector into 0B, 1B, 2B pieces
   653   79.191 MiB    0.000 MiB     ptr = 0
   654   79.191 MiB    0.000 MiB     zero_body = y[ptr]
   655                             
   656   79.191 MiB    0.000 MiB     ptr += 1
   657   79.191 MiB    0.000 MiB     one_body = reshape(y[ptr:ptr+dim1B*dim1B], (dim1B, dim1B))
   658                             
   659   79.191 MiB    0.000 MiB     ptr += dim1B*dim1B
   660   79.191 MiB    0.000 MiB     two_body = reshape(y[ptr:ptr+dim2B*dim2B], (dim2B, dim2B))
   661                             
   662   79.191 MiB    0.000 MiB     return zero_body,one_body,two_body


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   707   76.820 MiB   76.820 MiB   @profile
   708                             def pairing_hamiltonian(delta, g, user_data):
   709   76.820 MiB    0.000 MiB     bas1B = user_data["bas1B"]
   710   76.820 MiB    0.000 MiB     bas2B = user_data["bas2B"]
   711   76.820 MiB    0.000 MiB     idx2B = user_data["idx2B"]
   712                             
   713   76.820 MiB    0.000 MiB     dim = len(bas1B)
   714   76.820 MiB    0.000 MiB     H1B = np.zeros((dim,dim))
   715                             
   716   76.820 MiB    0.000 MiB     for i in bas1B:
   717   76.820 MiB    0.000 MiB       H1B[i,i] = delta*np.floor_divide(i, 2)
   718                             
   719   76.820 MiB    0.000 MiB     dim = len(bas2B)
   720   77.133 MiB    0.312 MiB     H2B = np.zeros((dim, dim))
   721                             
   722                               # spin up states have even indices, spin down the next odd index
   723   77.133 MiB    0.000 MiB     for (i, j) in bas2B:
   724   77.133 MiB    0.000 MiB       if (i % 2 == 0 and j == i+1):
   725   77.133 MiB    0.000 MiB         for (k, l) in bas2B:
   726   77.133 MiB    0.000 MiB           if (k % 2 == 0 and l == k+1):
   727   77.133 MiB    0.000 MiB             H2B[idx2B[(i,j)],idx2B[(k,l)]] = -0.5*g
   728   77.133 MiB    0.000 MiB             H2B[idx2B[(j,i)],idx2B[(k,l)]] = 0.5*g
   729   77.133 MiB    0.000 MiB             H2B[idx2B[(i,j)],idx2B[(l,k)]] = 0.5*g
   730   77.133 MiB    0.000 MiB             H2B[idx2B[(j,i)],idx2B[(l,k)]] = -0.5*g
   731                               
   732   77.133 MiB    0.000 MiB     return H1B, H2B


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   737   77.133 MiB   77.133 MiB   @profile
   738                             def normal_order(H1B, H2B, user_data):
   739   77.133 MiB    0.000 MiB     bas1B     = user_data["bas1B"]
   740   77.133 MiB    0.000 MiB     bas2B     = user_data["bas2B"]
   741   77.133 MiB    0.000 MiB     idx2B     = user_data["idx2B"]
   742   77.133 MiB    0.000 MiB     particles = user_data["particles"]
   743   77.133 MiB    0.000 MiB     holes     = user_data["holes"]
   744                             
   745                               # 0B part
   746   77.133 MiB    0.000 MiB     E = 0.0
   747   77.133 MiB    0.000 MiB     for i in holes:
   748   77.133 MiB    0.000 MiB       E += H1B[i,i]
   749                             
   750   77.133 MiB    0.000 MiB     for i in holes:
   751   77.133 MiB    0.000 MiB       for j in holes:
   752   77.133 MiB    0.000 MiB         E += 0.5*H2B[idx2B[(i,j)],idx2B[(i,j)]]  
   753                             
   754                               # 1B part
   755   77.133 MiB    0.000 MiB     f = H1B
   756   77.133 MiB    0.000 MiB     for i in bas1B:
   757   77.133 MiB    0.000 MiB       for j in bas1B:
   758   77.133 MiB    0.000 MiB         for h in holes:
   759   77.133 MiB    0.000 MiB           f[i,j] += H2B[idx2B[(i,h)],idx2B[(j,h)]]  
   760                             
   761                               # 2B part
   762   77.133 MiB    0.000 MiB     Gamma = H2B
   763                             
   764   77.133 MiB    0.000 MiB     return E, f, Gamma


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   831   76.348 MiB   76.348 MiB   @profile
   832                             def main(n_holes):
   833                               # grab delta and g from the command line
   834                               # delta      = float(argv[1])
   835                               # g          = float(argv[2])
   836   76.348 MiB    0.000 MiB     delta = 1
   837   76.348 MiB    0.000 MiB     g = 0.5
   838                               
   839   76.348 MiB    0.000 MiB     particles  = n_holes
   840                             
   841                               # setup shared data
   842   76.348 MiB    0.000 MiB     dim1B     = n_holes*2
   843                             
   844                               # this defines the reference state
   845                               # 1st state
   846   76.348 MiB    0.000 MiB     holes = np.arange(particles)
   847   76.348 MiB    0.000 MiB     particles = np.arange(particles,dim1B)
   848                             
   849                               # 2nd state
   850                               # holes     = [0,1,4,5]
   851                               # particles = [2,3,6,7]
   852                             
   853                               # 3rd state
   854                               # holes     = [0,1,6,7]
   855                               # particles = [2,3,4,5]
   856                             
   857                               # basis definitions
   858   76.348 MiB    0.000 MiB     bas1B     = list(range(dim1B))
   859   76.348 MiB   76.348 MiB     bas2B     = construct_basis_2B(holes, particles)
   860   76.348 MiB   76.348 MiB     basph2B   = construct_basis_ph2B(holes, particles)
   861                             
   862   76.348 MiB   76.348 MiB     idx2B     = construct_index_2B(bas2B)
   863   76.348 MiB   76.348 MiB     idxph2B   = construct_index_2B(basph2B)
   864                             
   865                               # occupation number matrices
   866   76.348 MiB   76.348 MiB     occ1B     = construct_occupation_1B(bas1B, holes, particles)
   867   76.348 MiB   76.348 MiB     occA_2B   = construct_occupationA_2B(bas2B, occ1B)
   868   76.562 MiB   76.562 MiB     occB_2B   = construct_occupationB_2B(bas2B, occ1B)
   869   76.820 MiB   76.820 MiB     occC_2B   = construct_occupationC_2B(bas2B, occ1B)
   870                             
   871   76.820 MiB   76.820 MiB     occphA_2B = construct_occupationA_2B(basph2B, occ1B)
   872                             
   873                               # store shared data in a dictionary, so we can avoid passing the basis
   874                               # lookups etc. as separate parameters all the time
   875                               user_data  = {
   876   76.820 MiB    0.000 MiB       "dim1B":      dim1B, 
   877   76.820 MiB    0.000 MiB       "holes":      holes,
   878   76.820 MiB    0.000 MiB       "particles":  particles,
   879   76.820 MiB    0.000 MiB       "bas1B":      bas1B,
   880   76.820 MiB    0.000 MiB       "bas2B":      bas2B,
   881   76.820 MiB    0.000 MiB       "basph2B":    basph2B,
   882   76.820 MiB    0.000 MiB       "idx2B":      idx2B,
   883   76.820 MiB    0.000 MiB       "idxph2B":    idxph2B,
   884   76.820 MiB    0.000 MiB       "occ1B":      occ1B,
   885   76.820 MiB    0.000 MiB       "occA_2B":    occA_2B,
   886   76.820 MiB    0.000 MiB       "occB_2B":    occB_2B,
   887   76.820 MiB    0.000 MiB       "occC_2B":    occC_2B,
   888   76.820 MiB    0.000 MiB       "occphA_2B":  occphA_2B,
   889                             
   890   76.820 MiB    0.000 MiB       "eta_norm":   0.0,                # variables for sharing data between ODE solver
   891   76.820 MiB    0.000 MiB       "dE":         0.0,                # and main routine
   892                             
   893                             
   894   76.820 MiB    0.000 MiB       "calc_eta":   eta_wegner,          # specify the generator (function object)
   895   76.820 MiB    0.000 MiB       "calc_rhs":   flow_imsrg2         # specify the right-hand side and truncation
   896                               }
   897                             
   898                               # set up initial Hamiltonian
   899   77.133 MiB   77.133 MiB     H1B, H2B = pairing_hamiltonian(delta, g, user_data)
   900                               
   901   77.133 MiB   77.133 MiB     E, f, Gamma = normal_order(H1B, H2B, user_data) 
   902                             
   903                               # reshape Hamiltonian into a linear array (initial ODE vector)
   904   77.383 MiB    0.250 MiB     y0   = np.append([E], np.append(reshape(f, -1), reshape(Gamma, -1)))
   905                             
   906   77.383 MiB    0.000 MiB     t = 1
   907   79.191 MiB   79.191 MiB     dy = derivative_wrapper(t, y0, user_data)
   908   79.191 MiB   79.191 MiB     dE, df, dG = get_operator_from_y(dy, dim1B, dim1B*dim1B)
   909   79.191 MiB    0.000 MiB     print(dE)


---------------------------------------------

Executing NP on n_holes=8 ---------------------------
-13.0
Wrote profile results to imsrg_pairing_bench.py.lprof
Timer unit: 1e-06 s

Total time: 0.000263 s
File: imsrg_pairing_bench.py
Function: construct_basis_2B at line 30

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    30                                           @profile
    31                                           def construct_basis_2B(holes, particles):
    32         1          1.0      1.0      0.4    basis = []
    33         9          5.0      0.6      1.9    for i in holes:
    34        72         36.0      0.5     13.7      for j in holes:
    35        64         25.0      0.4      9.5        basis.append((i, j)) # hole, hole
    36                                           
    37         9          3.0      0.3      1.1    for i in holes:
    38        72         34.0      0.5     12.9      for a in particles:
    39        64         28.0      0.4     10.6        basis.append((i, a)) # hole, particle
    40                                           
    41         9          3.0      0.3      1.1    for a in particles:
    42        72         34.0      0.5     12.9      for i in holes:
    43        64         29.0      0.5     11.0        basis.append((a, i)) # particle, hole
    44                                           
    45         9          5.0      0.6      1.9    for a in particles:
    46        72         35.0      0.5     13.3      for b in particles:
    47        64         25.0      0.4      9.5        basis.append((a, b)) # particle, particle
    48                                           
    49         1          0.0      0.0      0.0    return basis

Total time: 0.000262 s
File: imsrg_pairing_bench.py
Function: construct_basis_ph2B at line 52

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    52                                           @profile
    53                                           def construct_basis_ph2B(holes, particles):
    54         1          1.0      1.0      0.4    basis = []
    55         9          3.0      0.3      1.1    for i in holes:
    56        72         34.0      0.5     13.0      for j in holes:
    57        64         27.0      0.4     10.3        basis.append((i, j))
    58                                           
    59         9          6.0      0.7      2.3    for i in holes:
    60        72         31.0      0.4     11.8      for a in particles:
    61        64         26.0      0.4      9.9        basis.append((i, a))
    62                                           
    63         9          4.0      0.4      1.5    for a in particles:
    64        72         34.0      0.5     13.0      for i in holes:
    65        64         30.0      0.5     11.5        basis.append((a, i))
    66                                           
    67         9          7.0      0.8      2.7    for a in particles:
    68        72         34.0      0.5     13.0      for b in particles:
    69        64         25.0      0.4      9.5        basis.append((a, b))
    70                                           
    71         1          0.0      0.0      0.0    return basis

Total time: 0.000357 s
File: imsrg_pairing_bench.py
Function: construct_index_2B at line 77

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    77                                           @profile
    78                                           def construct_index_2B(bas2B):
    79         2          1.0      0.5      0.3    index = { }
    80       514        161.0      0.3     45.1    for i, state in enumerate(bas2B):
    81       512        195.0      0.4     54.6      index[state] = i
    82                                           
    83         2          0.0      0.0      0.0    return index

Total time: 0.461231 s
File: imsrg_pairing_bench.py
Function: ph_transform_2B at line 90

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    90                                           @profile
    91                                           def ph_transform_2B(Gamma, bas2B, idx2B, basph2B, idxph2B):
    92         4          9.0      2.2      0.0    dim = len(basph2B)
    93         4        179.0     44.8      0.0    Gamma_ph = np.zeros((dim, dim))
    94                                           
    95      1028        516.0      0.5      0.1    for i1, (a,b) in enumerate(basph2B):
    96    263168     126295.0      0.5     27.4      for i2, (c, d) in enumerate(basph2B):
    97    262144     334230.0      1.3     72.5        Gamma_ph[i1, i2] -= Gamma[idx2B[(a,d)], idx2B[(c,b)]]
    98                                           
    99         4          2.0      0.5      0.0    return Gamma_ph

Total time: 0.265463 s
File: imsrg_pairing_bench.py
Function: inverse_ph_transform_2B at line 101

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   101                                           @profile
   102                                           def inverse_ph_transform_2B(Gamma_ph, bas2B, idx2B, basph2B, idxph2B):
   103         2          4.0      2.0      0.0    dim = len(bas2B)
   104         2         59.0     29.5      0.0    Gamma = np.zeros((dim, dim))
   105                                           
   106       514        265.0      0.5      0.1    for i1, (a,b) in enumerate(bas2B):
   107    131584      72097.0      0.5     27.2      for i2, (c, d) in enumerate(bas2B):
   108    131072     193036.0      1.5     72.7        Gamma[i1, i2] -= Gamma_ph[idxph2B[(a,d)], idxph2B[(c,b)]]
   109                                             
   110         2          2.0      1.0      0.0    return Gamma

Total time: 5.7e-05 s
File: imsrg_pairing_bench.py
Function: commutator at line 115

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   115                                           @profile
   116                                           def commutator(a,b):
   117         2         57.0     28.5    100.0    return dot(a,b) - dot(b,a)

Total time: 1.8e-05 s
File: imsrg_pairing_bench.py
Function: construct_occupation_1B at line 150

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   150                                           @profile
   151                                           def construct_occupation_1B(bas1B, holes, particles):
   152         1          1.0      1.0      5.6    dim = len(bas1B)
   153         1          5.0      5.0     27.8    occ = np.zeros(dim)
   154                                           
   155         9          5.0      0.6     27.8    for i in holes:
   156         8          6.0      0.8     33.3      occ[i] = 1.
   157                                           
   158         1          1.0      1.0      5.6    return occ

Total time: 0.001003 s
File: imsrg_pairing_bench.py
Function: construct_occupationA_2B at line 161

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   161                                           @profile
   162                                           def construct_occupationA_2B(bas2B, occ1B):
   163         2          1.0      0.5      0.1    dim = len(bas2B)
   164         2         91.0     45.5      9.1    occ = np.zeros((dim,dim))
   165                                           
   166       514        223.0      0.4     22.2    for i1, (i,j) in enumerate(bas2B):
   167       512        686.0      1.3     68.4      occ[i1, i1] = occ1B[i] - occ1B[j]
   168                                           
   169         2          2.0      1.0      0.2    return occ

Total time: 0.000513 s
File: imsrg_pairing_bench.py
Function: construct_occupationB_2B at line 173

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   173                                           @profile
   174                                           def construct_occupationB_2B(bas2B, occ1B):
   175         1          1.0      1.0      0.2    dim = len(bas2B)
   176         1         52.0     52.0     10.1    occ = np.zeros((dim,dim))
   177                                           
   178       257        114.0      0.4     22.2    for i1, (i,j) in enumerate(bas2B):
   179       256        346.0      1.4     67.4      occ[i1, i1] = 1. - occ1B[i] - occ1B[j]
   180                                           
   181         1          0.0      0.0      0.0    return occ

Total time: 0.000473 s
File: imsrg_pairing_bench.py
Function: construct_occupationC_2B at line 184

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   184                                           @profile
   185                                           def construct_occupationC_2B(bas2B, occ1B):
   186         1          0.0      0.0      0.0    dim = len(bas2B)
   187         1         51.0     51.0     10.8    occ = np.zeros((dim,dim))
   188                                           
   189       257         98.0      0.4     20.7    for i1, (i,j) in enumerate(bas2B):
   190       256        323.0      1.3     68.3      occ[i1, i1] = occ1B[i] * occ1B[j]
   191                                           
   192         1          1.0      1.0      0.2    return occ

Total time: 13.9042 s
File: imsrg_pairing_bench.py
Function: eta_wegner at line 382

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   382                                           @profile
   383                                           def eta_wegner(f, Gamma, user_data):
   384                                           
   385         1          1.0      1.0      0.0    dim1B     = user_data["dim1B"]
   386         1          1.0      1.0      0.0    holes     = user_data["holes"]
   387         1          1.0      1.0      0.0    particles = user_data["particles"]
   388         1          1.0      1.0      0.0    bas2B     = user_data["bas2B"]
   389         1          1.0      1.0      0.0    basph2B   = user_data["basph2B"]
   390         1          1.0      1.0      0.0    idx2B     = user_data["idx2B"]
   391         1          1.0      1.0      0.0    idxph2B   = user_data["idxph2B"]
   392         1          1.0      1.0      0.0    occB_2B   = user_data["occB_2B"]
   393         1          0.0      0.0      0.0    occC_2B   = user_data["occC_2B"]
   394         1          1.0      1.0      0.0    occphA_2B = user_data["occphA_2B"]
   395                                           
   396                                           
   397                                             # split Hamiltonian in diagonal and off-diagonal parts
   398         1         16.0     16.0      0.0    fd      = np.zeros_like(f)
   399         1          6.0      6.0      0.0    fod     = np.zeros_like(f)
   400         1        179.0    179.0      0.0    Gammad  = np.zeros_like(Gamma)
   401         1        204.0    204.0      0.0    Gammaod = np.zeros_like(Gamma)
   402                                           
   403         9          9.0      1.0      0.0    for a in particles:
   404        72         73.0      1.0      0.0      for i in holes:
   405        64         67.0      1.0      0.0        fod[a, i] = f[a,i]
   406        64         67.0      1.0      0.0        fod[i, a] = f[i,a]
   407         1          8.0      8.0      0.0    fd = f - fod
   408                                           
   409         9          8.0      0.9      0.0    for a in particles:
   410        72         68.0      0.9      0.0      for b in particles:
   411       576        495.0      0.9      0.0        for i in holes:
   412      4608       4092.0      0.9      0.0          for j in holes:
   413      4096       6715.0      1.6      0.0            Gammaod[idx2B[(a,b)], idx2B[(i,j)]] = Gamma[idx2B[(a,b)], idx2B[(i,j)]]
   414      4096       6775.0      1.7      0.0            Gammaod[idx2B[(i,j)], idx2B[(a,b)]] = Gamma[idx2B[(i,j)], idx2B[(a,b)]]
   415         1        228.0    228.0      0.0    Gammad = Gamma - Gammaod
   416                                           
   417                                           
   418                                             #############################        
   419                                             # one-body flow equation  
   420         1         14.0     14.0      0.0    eta1B  = np.zeros_like(f)
   421                                           
   422                                             # 1B - 1B
   423         1         64.0     64.0      0.0    eta1B += commutator(fd, fod)
   424                                           
   425                                             # 1B - 2B
   426        17         21.0      1.2      0.0    for p in range(dim1B):
   427       272        355.0      1.3      0.0      for q in range(dim1B):
   428      2304       2718.0      1.2      0.0        for i in holes:
   429     18432      22102.0      1.2      0.2          for a in particles:
   430     16384      17147.0      1.0      0.1            eta1B[p,q] += (
   431                                                       fd[i,a]  * Gammaod[idx2B[(a, p)], idx2B[(i, q)]] 
   432                                                       - fd[a,i]  * Gammaod[idx2B[(i, p)], idx2B[(a, q)]] 
   433                                                       - fod[i,a] * Gammad[idx2B[(a, p)], idx2B[(i, q)]] 
   434     16384      95508.0      5.8      0.7              + fod[a,i] * Gammad[idx2B[(i, p)], idx2B[(a, q)]]
   435                                                     )
   436                                           
   437                                             # 2B - 2B
   438                                             # n_a n_b nn_c + nn_a nn_b n_c = n_a n_b + (1 - n_a - n_b) * n_c
   439         1       5660.0   5660.0      0.0    GammaGamma = dot(Gammad, dot(occB_2B, Gammaod))
   440        17         36.0      2.1      0.0    for p in range(dim1B):
   441       272        597.0      2.2      0.0      for q in range(dim1B):
   442      2304       5681.0      2.5      0.0        for i in holes:
   443      2048       3976.0      1.9      0.0          eta1B[p,q] += (
   444      2048       8059.0      3.9      0.1            0.5*GammaGamma[idx2B[(i,p)], idx2B[(i,q)]] 
   445      2048      16611.0      8.1      0.1            - transpose(GammaGamma)[idx2B[(i,p)], idx2B[(i,q)]]
   446                                                   )
   447                                           
   448         1       1551.0   1551.0      0.0    GammaGamma = dot(Gammad, dot(occC_2B, Gammaod))
   449        17         31.0      1.8      0.0    for p in range(dim1B):
   450       272        460.0      1.7      0.0      for q in range(dim1B):
   451      4352       8240.0      1.9      0.1        for r in range(dim1B):
   452      4096       8007.0      2.0      0.1          eta1B[p,q] += (
   453      4096      18245.0      4.5      0.1            0.5*GammaGamma[idx2B[(r,p)], idx2B[(r,q)]] 
   454      4096      34202.0      8.4      0.2            + transpose(GammaGamma)[idx2B[(r,p)], idx2B[(r,q)]] 
   455                                                   )
   456                                           
   457                                           
   458                                             #############################        
   459                                             # two-body flow equation  
   460         1        105.0    105.0      0.0    eta2B = np.zeros_like(Gamma)
   461                                           
   462                                             # 1B - 2B
   463        17         17.0      1.0      0.0    for p in range(dim1B):
   464       272        218.0      0.8      0.0      for q in range(dim1B):
   465      4352       3639.0      0.8      0.0        for r in range(dim1B):
   466     69632      57400.0      0.8      0.4          for s in range(dim1B):
   467   1114112     916121.0      0.8      6.6            for t in range(dim1B):
   468   1048576    1716615.0      1.6     12.3              eta2B[idx2B[(p,q)],idx2B[(r,s)]] += (
   469                                                         fd[p,t] * Gammaod[idx2B[(t,q)],idx2B[(r,s)]] 
   470                                                         + fd[q,t] * Gammaod[idx2B[(p,t)],idx2B[(r,s)]] 
   471                                                         - fd[t,r] * Gammaod[idx2B[(p,q)],idx2B[(t,s)]] 
   472                                                         - fd[t,s] * Gammaod[idx2B[(p,q)],idx2B[(r,t)]]
   473                                                         - fod[p,t] * Gammad[idx2B[(t,q)],idx2B[(r,s)]] 
   474                                                         - fod[q,t] * Gammad[idx2B[(p,t)],idx2B[(r,s)]] 
   475                                                         + fod[t,r] * Gammad[idx2B[(p,q)],idx2B[(t,s)]] 
   476   1048576   10130566.0      9.7     72.9                + fod[t,s] * Gammad[idx2B[(p,q)],idx2B[(r,t)]]
   477                                                       )
   478                                           
   479                                             
   480                                             # 2B - 2B - particle and hole ladders
   481                                             # Gammad.occB.Gammaod
   482         1       1544.0   1544.0      0.0    GammaGamma = dot(Gammad, dot(occB_2B, Gammaod))
   483                                           
   484         1        654.0    654.0      0.0    eta2B += 0.5 * (GammaGamma - transpose(GammaGamma))
   485                                           
   486                                             # 2B - 2B - particle-hole chain
   487                                             
   488                                             # transform matrices to particle-hole representation and calculate 
   489                                             # Gammad_ph.occA_ph.Gammaod_ph
   490         1     193837.0 193837.0      1.4    Gammad_ph = ph_transform_2B(Gammad, bas2B, idx2B, basph2B, idxph2B)
   491         1     146415.0 146415.0      1.1    Gammaod_ph = ph_transform_2B(Gammaod, bas2B, idx2B, basph2B, idxph2B)
   492                                           
   493         1       1688.0   1688.0      0.0    GammaGamma_ph = dot(Gammad_ph, dot(occphA_2B, Gammaod_ph))
   494                                           
   495                                             # transform back to standard representation
   496         1     194564.0 194564.0      1.4    GammaGamma    = inverse_ph_transform_2B(GammaGamma_ph, bas2B, idx2B, basph2B, idxph2B)
   497                                           
   498                                             # commutator / antisymmetrization
   499         1         85.0     85.0      0.0    work = np.zeros_like(GammaGamma)
   500       257        222.0      0.9      0.0    for i1, (i,j) in enumerate(bas2B):
   501     65792      55448.0      0.8      0.4      for i2, (k,l) in enumerate(bas2B):
   502     65536      60166.0      0.9      0.4        work[i1, i2] -= (
   503                                                   GammaGamma[i1, i2] 
   504                                                   - GammaGamma[idx2B[(j,i)], i2] 
   505                                                   - GammaGamma[i1, idx2B[(l,k)]] 
   506     65536     156487.0      2.4      1.1          + GammaGamma[idx2B[(j,i)], idx2B[(l,k)]]
   507                                                 )
   508         1          3.0      3.0      0.0    GammaGamma = work
   509                                           
   510         1        117.0    117.0      0.0    eta2B += GammaGamma
   511                                           
   512                                           
   513         1          1.0      1.0      0.0    return eta1B, eta2B

Total time: 13.9832 s
File: imsrg_pairing_bench.py
Function: flow_imsrg2 at line 519

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   519                                           @profile
   520                                           def flow_imsrg2(eta1B, eta2B, f, Gamma, user_data):
   521                                           
   522         1          2.0      2.0      0.0    dim1B     = user_data["dim1B"]
   523         1          1.0      1.0      0.0    holes     = user_data["holes"]
   524         1          1.0      1.0      0.0    particles = user_data["particles"]
   525         1          1.0      1.0      0.0    bas2B     = user_data["bas2B"]
   526         1          1.0      1.0      0.0    idx2B     = user_data["idx2B"]
   527         1          0.0      0.0      0.0    basph2B   = user_data["basph2B"]
   528         1          1.0      1.0      0.0    idxph2B   = user_data["idxph2B"]
   529         1          0.0      0.0      0.0    occB_2B   = user_data["occB_2B"]
   530         1          1.0      1.0      0.0    occC_2B   = user_data["occC_2B"]
   531         1          1.0      1.0      0.0    occphA_2B = user_data["occphA_2B"]
   532                                           
   533                                             #############################        
   534                                             # zero-body flow equation
   535         1          1.0      1.0      0.0    dE = 0.0
   536                                           
   537         9         13.0      1.4      0.0    for i in holes:
   538        72         68.0      0.9      0.0      for a in particles:
   539        64        115.0      1.8      0.0        dE += eta1B[i,a] * f[a,i] - eta1B[a,i] * f[i,a]
   540                                           
   541         9          8.0      0.9      0.0    for i in holes:
   542        72         61.0      0.8      0.0      for j in holes:
   543       576        537.0      0.9      0.0        for a in particles:
   544      4608       4069.0      0.9      0.0          for b in particles:
   545      4096       7833.0      1.9      0.1            dE += 0.5 * eta2B[idx2B[(i,j)], idx2B[(a,b)]] * Gamma[idx2B[(a,b)], idx2B[(i,j)]]
   546                                           
   547                                           
   548                                             #############################        
   549                                             # one-body flow equation  
   550         1         24.0     24.0      0.0    df  = np.zeros_like(f)
   551                                           
   552                                             # 1B - 1B
   553         1         30.0     30.0      0.0    df += commutator(eta1B, f)
   554                                           
   555                                             # 1B - 2B
   556        17         16.0      0.9      0.0    for p in range(dim1B):
   557       272        231.0      0.8      0.0      for q in range(dim1B):
   558      2304       2066.0      0.9      0.0        for i in holes:
   559     18432      16688.0      0.9      0.1          for a in particles:
   560     16384      14481.0      0.9      0.1            df[p,q] += (
   561                                                       eta1B[i,a] * Gamma[idx2B[(a, p)], idx2B[(i, q)]] 
   562                                                       - eta1B[a,i] * Gamma[idx2B[(i, p)], idx2B[(a, q)]] 
   563                                                       - f[i,a] * eta2B[idx2B[(a, p)], idx2B[(i, q)]] 
   564     16384      79372.0      4.8      0.6              + f[a,i] * eta2B[idx2B[(i, p)], idx2B[(a, q)]]
   565                                                     )
   566                                           
   567                                             # 2B - 2B
   568                                             # n_a n_b nn_c + nn_a nn_b n_c = n_a n_b + (1 - n_a - n_b) * n_c
   569         1       1277.0   1277.0      0.0    etaGamma = dot(eta2B, dot(occB_2B, Gamma))
   570        17         27.0      1.6      0.0    for p in range(dim1B):
   571       272        378.0      1.4      0.0      for q in range(dim1B):
   572      2304       3727.0      1.6      0.0        for i in holes:
   573      2048       3325.0      1.6      0.0          df[p,q] += 0.5*(
   574      2048       5337.0      2.6      0.0            etaGamma[idx2B[(i,p)], idx2B[(i,q)]] 
   575      2048      11094.0      5.4      0.1            + transpose(etaGamma)[idx2B[(i,p)], idx2B[(i,q)]]
   576                                                   )
   577                                           
   578         1       1267.0   1267.0      0.0    etaGamma = dot(eta2B, dot(occC_2B, Gamma))
   579        17         20.0      1.2      0.0    for p in range(dim1B):
   580       272        374.0      1.4      0.0      for q in range(dim1B):
   581      4352       5980.0      1.4      0.0        for r in range(dim1B):
   582      4096       6607.0      1.6      0.0          df[p,q] += 0.5*(
   583      4096      12039.0      2.9      0.1            etaGamma[idx2B[(r,p)], idx2B[(r,q)]] 
   584      4096      23636.0      5.8      0.2            + transpose(etaGamma)[idx2B[(r,p)], idx2B[(r,q)]] 
   585                                                   )
   586                                           
   587                                           
   588                                             #############################        
   589                                             # two-body flow equation  
   590         1         93.0     93.0      0.0    dGamma = np.zeros_like(Gamma)
   591                                           
   592                                             # 1B - 2B
   593        17         14.0      0.8      0.0    for p in range(dim1B):
   594       272        234.0      0.9      0.0      for q in range(dim1B):
   595      4352       3570.0      0.8      0.0        for r in range(dim1B):
   596     69632      57568.0      0.8      0.4          for s in range(dim1B):
   597   1114112     920658.0      0.8      6.6            for t in range(dim1B):
   598   1048576    1711774.0      1.6     12.2              dGamma[idx2B[(p,q)],idx2B[(r,s)]] += (
   599                                                         eta1B[p,t] * Gamma[idx2B[(t,q)],idx2B[(r,s)]] 
   600                                                         + eta1B[q,t] * Gamma[idx2B[(p,t)],idx2B[(r,s)]] 
   601                                                         - eta1B[t,r] * Gamma[idx2B[(p,q)],idx2B[(t,s)]] 
   602                                                         - eta1B[t,s] * Gamma[idx2B[(p,q)],idx2B[(r,t)]]
   603                                                         - f[p,t] * eta2B[idx2B[(t,q)],idx2B[(r,s)]] 
   604                                                         - f[q,t] * eta2B[idx2B[(p,t)],idx2B[(r,s)]] 
   605                                                         + f[t,r] * eta2B[idx2B[(p,q)],idx2B[(t,s)]] 
   606   1048576   10273617.0      9.8     73.5                + f[t,s] * eta2B[idx2B[(p,q)],idx2B[(r,t)]]
   607                                                       )
   608                                           
   609                                             
   610                                             # 2B - 2B - particle and hole ladders
   611                                             # eta2B.occB.Gamma
   612         1       1440.0   1440.0      0.0    etaGamma = dot(eta2B, dot(occB_2B, Gamma))
   613                                           
   614         1        403.0    403.0      0.0    dGamma += 0.5 * (etaGamma + transpose(etaGamma))
   615                                           
   616                                             # 2B - 2B - particle-hole chain
   617                                             
   618                                             # transform matrices to particle-hole representation and calculate 
   619                                             # eta2B_ph.occA_ph.Gamma_ph
   620         1     192412.0 192412.0      1.4    eta2B_ph = ph_transform_2B(eta2B, bas2B, idx2B, basph2B, idxph2B)
   621         1     146214.0 146214.0      1.0    Gamma_ph = ph_transform_2B(Gamma, bas2B, idx2B, basph2B, idxph2B)
   622                                           
   623         1       1724.0   1724.0      0.0    etaGamma_ph = dot(eta2B_ph, dot(occphA_2B, Gamma_ph))
   624                                           
   625                                             # transform back to standard representation
   626         1     198933.0 198933.0      1.4    etaGamma    = inverse_ph_transform_2B(etaGamma_ph, bas2B, idx2B, basph2B, idxph2B)
   627                                           
   628                                             # commutator / antisymmetrization
   629         1         86.0     86.0      0.0    work = np.zeros_like(etaGamma)
   630       257        226.0      0.9      0.0    for i1, (i,j) in enumerate(bas2B):
   631     65792      56003.0      0.9      0.4      for i2, (k,l) in enumerate(bas2B):
   632     65536      59593.0      0.9      0.4        work[i1, i2] -= (
   633                                                   etaGamma[i1, i2] 
   634                                                   - etaGamma[idx2B[(j,i)], i2] 
   635                                                   - etaGamma[i1, idx2B[(l,k)]] 
   636     65536     157751.0      2.4      1.1          + etaGamma[idx2B[(j,i)], idx2B[(l,k)]]
   637                                                 )
   638         1          3.0      3.0      0.0    etaGamma = work
   639                                           
   640         1        134.0    134.0      0.0    dGamma += etaGamma
   641                                           
   642                                           
   643         1          1.0      1.0      0.0    return dE, df, dGamma

Total time: 3.7e-05 s
File: imsrg_pairing_bench.py
Function: get_operator_from_y at line 649

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   649                                           @profile
   650                                           def get_operator_from_y(y, dim1B, dim2B):
   651                                             
   652                                             # reshape the solution vector into 0B, 1B, 2B pieces
   653         2          2.0      1.0      5.4    ptr = 0
   654         2          3.0      1.5      8.1    zero_body = y[ptr]
   655                                           
   656         2          2.0      1.0      5.4    ptr += 1
   657         2         18.0      9.0     48.6    one_body = reshape(y[ptr:ptr+dim1B*dim1B], (dim1B, dim1B))
   658                                           
   659         2          2.0      1.0      5.4    ptr += dim1B*dim1B
   660         2          8.0      4.0     21.6    two_body = reshape(y[ptr:ptr+dim2B*dim2B], (dim2B, dim2B))
   661                                           
   662         2          2.0      1.0      5.4    return zero_body,one_body,two_body

Total time: 0.003836 s
File: imsrg_pairing_bench.py
Function: pairing_hamiltonian at line 707

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   707                                           @profile
   708                                           def pairing_hamiltonian(delta, g, user_data):
   709         1          1.0      1.0      0.0    bas1B = user_data["bas1B"]
   710         1          1.0      1.0      0.0    bas2B = user_data["bas2B"]
   711         1          1.0      1.0      0.0    idx2B = user_data["idx2B"]
   712                                           
   713         1          0.0      0.0      0.0    dim = len(bas1B)
   714         1          2.0      2.0      0.1    H1B = np.zeros((dim,dim))
   715                                           
   716        17          2.0      0.1      0.1    for i in bas1B:
   717        16         44.0      2.8      1.1      H1B[i,i] = delta*np.floor_divide(i, 2)
   718                                           
   719         1          1.0      1.0      0.0    dim = len(bas2B)
   720         1         50.0     50.0      1.3    H2B = np.zeros((dim, dim))
   721                                           
   722                                             # spin up states have even indices, spin down the next odd index
   723       257        148.0      0.6      3.9    for (i, j) in bas2B:
   724       256        247.0      1.0      6.4      if (i % 2 == 0 and j == i+1):
   725      2056       1097.0      0.5     28.6        for (k, l) in bas2B:
   726      2048       1972.0      1.0     51.4          if (k % 2 == 0 and l == k+1):
   727        64         69.0      1.1      1.8            H2B[idx2B[(i,j)],idx2B[(k,l)]] = -0.5*g
   728        64         72.0      1.1      1.9            H2B[idx2B[(j,i)],idx2B[(k,l)]] = 0.5*g
   729        64         63.0      1.0      1.6            H2B[idx2B[(i,j)],idx2B[(l,k)]] = 0.5*g
   730        64         65.0      1.0      1.7            H2B[idx2B[(j,i)],idx2B[(l,k)]] = -0.5*g
   731                                             
   732         1          1.0      1.0      0.0    return H1B, H2B

Total time: 0.004883 s
File: imsrg_pairing_bench.py
Function: normal_order at line 737

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   737                                           @profile
   738                                           def normal_order(H1B, H2B, user_data):
   739         1          1.0      1.0      0.0    bas1B     = user_data["bas1B"]
   740         1          1.0      1.0      0.0    bas2B     = user_data["bas2B"]
   741         1          0.0      0.0      0.0    idx2B     = user_data["idx2B"]
   742         1          1.0      1.0      0.0    particles = user_data["particles"]
   743         1          1.0      1.0      0.0    holes     = user_data["holes"]
   744                                           
   745                                             # 0B part
   746         1          1.0      1.0      0.0    E = 0.0
   747         9         16.0      1.8      0.3    for i in holes:
   748         8          6.0      0.8      0.1      E += H1B[i,i]
   749                                           
   750         9          7.0      0.8      0.1    for i in holes:
   751        72         48.0      0.7      1.0      for j in holes:
   752        64         72.0      1.1      1.5        E += 0.5*H2B[idx2B[(i,j)],idx2B[(i,j)]]  
   753                                           
   754                                             # 1B part
   755         1          1.0      1.0      0.0    f = H1B
   756        17          9.0      0.5      0.2    for i in bas1B:
   757       272        138.0      0.5      2.8      for j in bas1B:
   758      2304       1460.0      0.6     29.9        for h in holes:
   759      2048       3119.0      1.5     63.9          f[i,j] += H2B[idx2B[(i,h)],idx2B[(j,h)]]  
   760                                           
   761                                             # 2B part
   762         1          1.0      1.0      0.0    Gamma = H2B
   763                                           
   764         1          1.0      1.0      0.0    return E, f, Gamma

Total time: 34.6546 s
File: imsrg_pairing_bench.py
Function: main at line 831

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   831                                           @profile
   832                                           def main(n_holes):
   833                                             # grab delta and g from the command line
   834                                             # delta      = float(argv[1])
   835                                             # g          = float(argv[2])
   836         1          2.0      2.0      0.0    delta = 1
   837         1          1.0      1.0      0.0    g = 0.5
   838                                             
   839         1          1.0      1.0      0.0    particles  = n_holes
   840                                           
   841                                             # setup shared data
   842         1          1.0      1.0      0.0    dim1B     = n_holes*2
   843                                           
   844                                             # this defines the reference state
   845                                             # 1st state
   846         1          7.0      7.0      0.0    holes = np.arange(particles)
   847         1          2.0      2.0      0.0    particles = np.arange(particles,dim1B)
   848                                           
   849                                             # 2nd state
   850                                             # holes     = [0,1,4,5]
   851                                             # particles = [2,3,6,7]
   852                                           
   853                                             # 3rd state
   854                                             # holes     = [0,1,6,7]
   855                                             # particles = [2,3,4,5]
   856                                           
   857                                             # basis definitions
   858         1          3.0      3.0      0.0    bas1B     = list(range(dim1B))
   859         1        448.0    448.0      0.0    bas2B     = construct_basis_2B(holes, particles)
   860         1        431.0    431.0      0.0    basph2B   = construct_basis_ph2B(holes, particles)
   861                                           
   862         1        307.0    307.0      0.0    idx2B     = construct_index_2B(bas2B)
   863         1        301.0    301.0      0.0    idxph2B   = construct_index_2B(basph2B)
   864                                           
   865                                             # occupation number matrices
   866         1         28.0     28.0      0.0    occ1B     = construct_occupation_1B(bas1B, holes, particles)
   867         1        706.0    706.0      0.0    occA_2B   = construct_occupationA_2B(bas2B, occ1B)
   868         1        707.0    707.0      0.0    occB_2B   = construct_occupationB_2B(bas2B, occ1B)
   869         1        657.0    657.0      0.0    occC_2B   = construct_occupationC_2B(bas2B, occ1B)
   870                                           
   871         1        648.0    648.0      0.0    occphA_2B = construct_occupationA_2B(basph2B, occ1B)
   872                                           
   873                                             # store shared data in a dictionary, so we can avoid passing the basis
   874                                             # lookups etc. as separate parameters all the time
   875                                             user_data  = {
   876         1          1.0      1.0      0.0      "dim1B":      dim1B, 
   877         1          2.0      2.0      0.0      "holes":      holes,
   878         1          1.0      1.0      0.0      "particles":  particles,
   879         1          1.0      1.0      0.0      "bas1B":      bas1B,
   880         1          1.0      1.0      0.0      "bas2B":      bas2B,
   881         1          1.0      1.0      0.0      "basph2B":    basph2B,
   882         1          1.0      1.0      0.0      "idx2B":      idx2B,
   883         1          1.0      1.0      0.0      "idxph2B":    idxph2B,
   884         1          1.0      1.0      0.0      "occ1B":      occ1B,
   885         1          1.0      1.0      0.0      "occA_2B":    occA_2B,
   886         1          1.0      1.0      0.0      "occB_2B":    occB_2B,
   887         1          1.0      1.0      0.0      "occC_2B":    occC_2B,
   888         1          1.0      1.0      0.0      "occphA_2B":  occphA_2B,
   889                                           
   890         1          1.0      1.0      0.0      "eta_norm":   0.0,                # variables for sharing data between ODE solver
   891         1          1.0      1.0      0.0      "dE":         0.0,                # and main routine
   892                                           
   893                                           
   894         1          1.0      1.0      0.0      "calc_eta":   eta_wegner,          # specify the generator (function object)
   895         1          3.0      3.0      0.0      "calc_rhs":   flow_imsrg2         # specify the right-hand side and truncation
   896                                             }
   897                                           
   898                                             # set up initial Hamiltonian
   899         1       7023.0   7023.0      0.0    H1B, H2B = pairing_hamiltonian(delta, g, user_data)
   900                                             
   901         1       7731.0   7731.0      0.0    E, f, Gamma = normal_order(H1B, H2B, user_data) 
   902                                           
   903                                             # reshape Hamiltonian into a linear array (initial ODE vector)
   904         1        579.0    579.0      0.0    y0   = np.append([E], np.append(reshape(f, -1), reshape(Gamma, -1)))
   905                                           
   906         1          1.0      1.0      0.0    t = 1
   907         1   34634944.0 34634944.0     99.9    dy = derivative_wrapper(t, y0, user_data)
   908         1         36.0     36.0      0.0    dE, df, dG = get_operator_from_y(dy, dim1B, dim1B*dim1B)
   909         1         36.0     36.0      0.0    print(dE)

-13.0
Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
    30   76.273 MiB   76.273 MiB   @profile
    31                             def construct_basis_2B(holes, particles):
    32   76.273 MiB    0.000 MiB     basis = []
    33   76.273 MiB    0.000 MiB     for i in holes:
    34   76.273 MiB    0.000 MiB       for j in holes:
    35   76.273 MiB    0.000 MiB         basis.append((i, j)) # hole, hole
    36                             
    37   76.273 MiB    0.000 MiB     for i in holes:
    38   76.273 MiB    0.000 MiB       for a in particles:
    39   76.273 MiB    0.000 MiB         basis.append((i, a)) # hole, particle
    40                             
    41   76.273 MiB    0.000 MiB     for a in particles:
    42   76.273 MiB    0.000 MiB       for i in holes:
    43   76.273 MiB    0.000 MiB         basis.append((a, i)) # particle, hole
    44                             
    45   76.273 MiB    0.000 MiB     for a in particles:
    46   76.273 MiB    0.000 MiB       for b in particles:
    47   76.273 MiB    0.000 MiB         basis.append((a, b)) # particle, particle
    48                             
    49   76.273 MiB    0.000 MiB     return basis


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
    52   76.273 MiB   76.273 MiB   @profile
    53                             def construct_basis_ph2B(holes, particles):
    54   76.273 MiB    0.000 MiB     basis = []
    55   76.273 MiB    0.000 MiB     for i in holes:
    56   76.273 MiB    0.000 MiB       for j in holes:
    57   76.273 MiB    0.000 MiB         basis.append((i, j))
    58                             
    59   76.273 MiB    0.000 MiB     for i in holes:
    60   76.273 MiB    0.000 MiB       for a in particles:
    61   76.273 MiB    0.000 MiB         basis.append((i, a))
    62                             
    63   76.273 MiB    0.000 MiB     for a in particles:
    64   76.273 MiB    0.000 MiB       for i in holes:
    65   76.273 MiB    0.000 MiB         basis.append((a, i))
    66                             
    67   76.273 MiB    0.000 MiB     for a in particles:
    68   76.273 MiB    0.000 MiB       for b in particles:
    69   76.273 MiB    0.000 MiB         basis.append((a, b))
    70                             
    71   76.273 MiB    0.000 MiB     return basis


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
    77   76.273 MiB   76.273 MiB   @profile
    78                             def construct_index_2B(bas2B):
    79   76.273 MiB    0.000 MiB     index = { }
    80   76.273 MiB    0.000 MiB     for i, state in enumerate(bas2B):
    81   76.273 MiB    0.000 MiB       index[state] = i
    82                             
    83   76.273 MiB    0.000 MiB     return index


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
    90   83.586 MiB   83.586 MiB   @profile
    91                             def ph_transform_2B(Gamma, bas2B, idx2B, basph2B, idxph2B):
    92   83.586 MiB    0.000 MiB     dim = len(basph2B)
    93   83.586 MiB    0.000 MiB     Gamma_ph = np.zeros((dim, dim))
    94                             
    95   83.586 MiB    0.000 MiB     for i1, (a,b) in enumerate(basph2B):
    96   83.586 MiB    0.000 MiB       for i2, (c, d) in enumerate(basph2B):
    97   83.586 MiB    0.000 MiB         Gamma_ph[i1, i2] -= Gamma[idx2B[(a,d)], idx2B[(c,b)]]
    98                             
    99   83.586 MiB    0.000 MiB     return Gamma_ph


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   101   84.902 MiB   84.902 MiB   @profile
   102                             def inverse_ph_transform_2B(Gamma_ph, bas2B, idx2B, basph2B, idxph2B):
   103   84.902 MiB    0.000 MiB     dim = len(bas2B)
   104   84.902 MiB    0.000 MiB     Gamma = np.zeros((dim, dim))
   105                             
   106   84.902 MiB    0.000 MiB     for i1, (a,b) in enumerate(bas2B):
   107   84.902 MiB    0.000 MiB       for i2, (c, d) in enumerate(bas2B):
   108   84.902 MiB    0.000 MiB         Gamma[i1, i2] -= Gamma_ph[idxph2B[(a,d)], idxph2B[(c,b)]]
   109                               
   110   84.902 MiB    0.000 MiB     return Gamma


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   115   83.238 MiB   83.238 MiB   @profile
   116                             def commutator(a,b):
   117   83.238 MiB    0.000 MiB     return dot(a,b) - dot(b,a)


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   150   76.273 MiB   76.273 MiB   @profile
   151                             def construct_occupation_1B(bas1B, holes, particles):
   152   76.273 MiB    0.000 MiB     dim = len(bas1B)
   153   76.273 MiB    0.000 MiB     occ = np.zeros(dim)
   154                             
   155   76.273 MiB    0.000 MiB     for i in holes:
   156   76.273 MiB    0.000 MiB       occ[i] = 1.
   157                             
   158   76.273 MiB    0.000 MiB     return occ


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   161   77.770 MiB   77.770 MiB   @profile
   162                             def construct_occupationA_2B(bas2B, occ1B):
   163   77.770 MiB    0.000 MiB     dim = len(bas2B)
   164   77.770 MiB    0.000 MiB     occ = np.zeros((dim,dim))
   165                             
   166   78.285 MiB    0.000 MiB     for i1, (i,j) in enumerate(bas2B):
   167   78.285 MiB    0.258 MiB       occ[i1, i1] = occ1B[i] - occ1B[j]
   168                             
   169   78.285 MiB    0.000 MiB     return occ


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   173   76.738 MiB   76.738 MiB   @profile
   174                             def construct_occupationB_2B(bas2B, occ1B):
   175   76.738 MiB    0.000 MiB     dim = len(bas2B)
   176   76.738 MiB    0.000 MiB     occ = np.zeros((dim,dim))
   177                             
   178   77.254 MiB    0.000 MiB     for i1, (i,j) in enumerate(bas2B):
   179   77.254 MiB    0.258 MiB       occ[i1, i1] = 1. - occ1B[i] - occ1B[j]
   180                             
   181   77.254 MiB    0.000 MiB     return occ


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   184   77.254 MiB   77.254 MiB   @profile
   185                             def construct_occupationC_2B(bas2B, occ1B):
   186   77.254 MiB    0.000 MiB     dim = len(bas2B)
   187   77.254 MiB    0.000 MiB     occ = np.zeros((dim,dim))
   188                             
   189   77.770 MiB    0.000 MiB     for i1, (i,j) in enumerate(bas2B):
   190   77.770 MiB    0.258 MiB       occ[i1, i1] = occ1B[i] * occ1B[j]
   191                             
   192   77.770 MiB    0.000 MiB     return occ


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   382   79.254 MiB   79.254 MiB   @profile
   383                             def eta_wegner(f, Gamma, user_data):
   384                             
   385   79.254 MiB    0.000 MiB     dim1B     = user_data["dim1B"]
   386   79.254 MiB    0.000 MiB     holes     = user_data["holes"]
   387   79.254 MiB    0.000 MiB     particles = user_data["particles"]
   388   79.254 MiB    0.000 MiB     bas2B     = user_data["bas2B"]
   389   79.254 MiB    0.000 MiB     basph2B   = user_data["basph2B"]
   390   79.254 MiB    0.000 MiB     idx2B     = user_data["idx2B"]
   391   79.254 MiB    0.000 MiB     idxph2B   = user_data["idxph2B"]
   392   79.254 MiB    0.000 MiB     occB_2B   = user_data["occB_2B"]
   393   79.254 MiB    0.000 MiB     occC_2B   = user_data["occC_2B"]
   394   79.254 MiB    0.000 MiB     occphA_2B = user_data["occphA_2B"]
   395                             
   396                             
   397                               # split Hamiltonian in diagonal and off-diagonal parts
   398   79.254 MiB    0.000 MiB     fd      = np.zeros_like(f)
   399   79.254 MiB    0.000 MiB     fod     = np.zeros_like(f)
   400   79.770 MiB    0.516 MiB     Gammad  = np.zeros_like(Gamma)
   401   80.285 MiB    0.516 MiB     Gammaod = np.zeros_like(Gamma)
   402                             
   403   80.285 MiB    0.000 MiB     for a in particles:
   404   80.285 MiB    0.000 MiB       for i in holes:
   405   80.285 MiB    0.000 MiB         fod[a, i] = f[a,i]
   406   80.285 MiB    0.000 MiB         fod[i, a] = f[i,a]
   407   80.285 MiB    0.000 MiB     fd = f - fod
   408                             
   409   80.285 MiB    0.000 MiB     for a in particles:
   410   80.285 MiB    0.000 MiB       for b in particles:
   411   80.285 MiB    0.000 MiB         for i in holes:
   412   80.285 MiB    0.000 MiB           for j in holes:
   413   80.285 MiB    0.000 MiB             Gammaod[idx2B[(a,b)], idx2B[(i,j)]] = Gamma[idx2B[(a,b)], idx2B[(i,j)]]
   414   80.285 MiB    0.000 MiB             Gammaod[idx2B[(i,j)], idx2B[(a,b)]] = Gamma[idx2B[(i,j)], idx2B[(a,b)]]
   415   80.801 MiB    0.516 MiB     Gammad = Gamma - Gammaod
   416                             
   417                             
   418                               #############################        
   419                               # one-body flow equation  
   420   80.801 MiB    0.000 MiB     eta1B  = np.zeros_like(f)
   421                             
   422                               # 1B - 1B
   423   80.801 MiB   80.801 MiB     eta1B += commutator(fd, fod)
   424                             
   425                               # 1B - 2B
   426   80.801 MiB    0.000 MiB     for p in range(dim1B):
   427   80.801 MiB    0.000 MiB       for q in range(dim1B):
   428   80.801 MiB    0.000 MiB         for i in holes:
   429   80.801 MiB    0.000 MiB           for a in particles:
   430   80.801 MiB    0.000 MiB             eta1B[p,q] += (
   431                                         fd[i,a]  * Gammaod[idx2B[(a, p)], idx2B[(i, q)]] 
   432                                         - fd[a,i]  * Gammaod[idx2B[(i, p)], idx2B[(a, q)]] 
   433                                         - fod[i,a] * Gammad[idx2B[(a, p)], idx2B[(i, q)]] 
   434   80.801 MiB    0.000 MiB               + fod[a,i] * Gammad[idx2B[(i, p)], idx2B[(a, q)]]
   435                                       )
   436                             
   437                               # 2B - 2B
   438                               # n_a n_b nn_c + nn_a nn_b n_c = n_a n_b + (1 - n_a - n_b) * n_c
   439   82.555 MiB    1.754 MiB     GammaGamma = dot(Gammad, dot(occB_2B, Gammaod))
   440   82.555 MiB    0.000 MiB     for p in range(dim1B):
   441   82.555 MiB    0.000 MiB       for q in range(dim1B):
   442   82.555 MiB    0.000 MiB         for i in holes:
   443   82.555 MiB    0.000 MiB           eta1B[p,q] += (
   444   82.555 MiB    0.000 MiB             0.5*GammaGamma[idx2B[(i,p)], idx2B[(i,q)]] 
   445   82.555 MiB    0.000 MiB             - transpose(GammaGamma)[idx2B[(i,p)], idx2B[(i,q)]]
   446                                     )
   447                             
   448   83.070 MiB    0.516 MiB     GammaGamma = dot(Gammad, dot(occC_2B, Gammaod))
   449   83.070 MiB    0.000 MiB     for p in range(dim1B):
   450   83.070 MiB    0.000 MiB       for q in range(dim1B):
   451   83.070 MiB    0.000 MiB         for r in range(dim1B):
   452   83.070 MiB    0.000 MiB           eta1B[p,q] += (
   453   83.070 MiB    0.000 MiB             0.5*GammaGamma[idx2B[(r,p)], idx2B[(r,q)]] 
   454   83.070 MiB    0.000 MiB             + transpose(GammaGamma)[idx2B[(r,p)], idx2B[(r,q)]] 
   455                                     )
   456                             
   457                             
   458                               #############################        
   459                               # two-body flow equation  
   460   83.070 MiB    0.000 MiB     eta2B = np.zeros_like(Gamma)
   461                             
   462                               # 1B - 2B
   463   83.070 MiB    0.000 MiB     for p in range(dim1B):
   464   83.070 MiB    0.000 MiB       for q in range(dim1B):
   465   83.070 MiB    0.000 MiB         for r in range(dim1B):
   466   83.070 MiB    0.000 MiB           for s in range(dim1B):
   467   83.070 MiB    0.000 MiB             for t in range(dim1B):
   468   83.070 MiB    0.000 MiB               eta2B[idx2B[(p,q)],idx2B[(r,s)]] += (
   469                                           fd[p,t] * Gammaod[idx2B[(t,q)],idx2B[(r,s)]] 
   470                                           + fd[q,t] * Gammaod[idx2B[(p,t)],idx2B[(r,s)]] 
   471                                           - fd[t,r] * Gammaod[idx2B[(p,q)],idx2B[(t,s)]] 
   472                                           - fd[t,s] * Gammaod[idx2B[(p,q)],idx2B[(r,t)]]
   473                                           - fod[p,t] * Gammad[idx2B[(t,q)],idx2B[(r,s)]] 
   474                                           - fod[q,t] * Gammad[idx2B[(p,t)],idx2B[(r,s)]] 
   475                                           + fod[t,r] * Gammad[idx2B[(p,q)],idx2B[(t,s)]] 
   476   83.070 MiB    0.000 MiB                 + fod[t,s] * Gammad[idx2B[(p,q)],idx2B[(r,t)]]
   477                                         )
   478                             
   479                               
   480                               # 2B - 2B - particle and hole ladders
   481                               # Gammad.occB.Gammaod
   482   83.586 MiB    0.516 MiB     GammaGamma = dot(Gammad, dot(occB_2B, Gammaod))
   483                             
   484   83.586 MiB    0.000 MiB     eta2B += 0.5 * (GammaGamma - transpose(GammaGamma))
   485                             
   486                               # 2B - 2B - particle-hole chain
   487                               
   488                               # transform matrices to particle-hole representation and calculate 
   489                               # Gammad_ph.occA_ph.Gammaod_ph
   490   83.586 MiB   83.586 MiB     Gammad_ph = ph_transform_2B(Gammad, bas2B, idx2B, basph2B, idxph2B)
   491   83.586 MiB   83.586 MiB     Gammaod_ph = ph_transform_2B(Gammaod, bas2B, idx2B, basph2B, idxph2B)
   492                             
   493   84.902 MiB    1.316 MiB     GammaGamma_ph = dot(Gammad_ph, dot(occphA_2B, Gammaod_ph))
   494                             
   495                               # transform back to standard representation
   496   84.902 MiB   84.902 MiB     GammaGamma    = inverse_ph_transform_2B(GammaGamma_ph, bas2B, idx2B, basph2B, idxph2B)
   497                             
   498                               # commutator / antisymmetrization
   499   84.902 MiB    0.000 MiB     work = np.zeros_like(GammaGamma)
   500   84.902 MiB    0.000 MiB     for i1, (i,j) in enumerate(bas2B):
   501   84.902 MiB    0.000 MiB       for i2, (k,l) in enumerate(bas2B):
   502   84.902 MiB    0.000 MiB         work[i1, i2] -= (
   503                                     GammaGamma[i1, i2] 
   504                                     - GammaGamma[idx2B[(j,i)], i2] 
   505                                     - GammaGamma[i1, idx2B[(l,k)]] 
   506   84.902 MiB    0.000 MiB           + GammaGamma[idx2B[(j,i)], idx2B[(l,k)]]
   507                                   )
   508   84.902 MiB    0.000 MiB     GammaGamma = work
   509                             
   510   84.902 MiB    0.000 MiB     eta2B += GammaGamma
   511                             
   512                             
   513   84.902 MiB    0.000 MiB     return eta1B, eta2B


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   519   83.238 MiB   83.238 MiB   @profile
   520                             def flow_imsrg2(eta1B, eta2B, f, Gamma, user_data):
   521                             
   522   83.238 MiB    0.000 MiB     dim1B     = user_data["dim1B"]
   523   83.238 MiB    0.000 MiB     holes     = user_data["holes"]
   524   83.238 MiB    0.000 MiB     particles = user_data["particles"]
   525   83.238 MiB    0.000 MiB     bas2B     = user_data["bas2B"]
   526   83.238 MiB    0.000 MiB     idx2B     = user_data["idx2B"]
   527   83.238 MiB    0.000 MiB     basph2B   = user_data["basph2B"]
   528   83.238 MiB    0.000 MiB     idxph2B   = user_data["idxph2B"]
   529   83.238 MiB    0.000 MiB     occB_2B   = user_data["occB_2B"]
   530   83.238 MiB    0.000 MiB     occC_2B   = user_data["occC_2B"]
   531   83.238 MiB    0.000 MiB     occphA_2B = user_data["occphA_2B"]
   532                             
   533                               #############################        
   534                               # zero-body flow equation
   535   83.238 MiB    0.000 MiB     dE = 0.0
   536                             
   537   83.238 MiB    0.000 MiB     for i in holes:
   538   83.238 MiB    0.000 MiB       for a in particles:
   539   83.238 MiB    0.000 MiB         dE += eta1B[i,a] * f[a,i] - eta1B[a,i] * f[i,a]
   540                             
   541   83.238 MiB    0.000 MiB     for i in holes:
   542   83.238 MiB    0.000 MiB       for j in holes:
   543   83.238 MiB    0.000 MiB         for a in particles:
   544   83.238 MiB    0.000 MiB           for b in particles:
   545   83.238 MiB    0.000 MiB             dE += 0.5 * eta2B[idx2B[(i,j)], idx2B[(a,b)]] * Gamma[idx2B[(a,b)], idx2B[(i,j)]]
   546                             
   547                             
   548                               #############################        
   549                               # one-body flow equation  
   550   83.238 MiB    0.000 MiB     df  = np.zeros_like(f)
   551                             
   552                               # 1B - 1B
   553   83.238 MiB   83.238 MiB     df += commutator(eta1B, f)
   554                             
   555                               # 1B - 2B
   556   83.238 MiB    0.000 MiB     for p in range(dim1B):
   557   83.238 MiB    0.000 MiB       for q in range(dim1B):
   558   83.238 MiB    0.000 MiB         for i in holes:
   559   83.238 MiB    0.000 MiB           for a in particles:
   560   83.238 MiB    0.000 MiB             df[p,q] += (
   561                                         eta1B[i,a] * Gamma[idx2B[(a, p)], idx2B[(i, q)]] 
   562                                         - eta1B[a,i] * Gamma[idx2B[(i, p)], idx2B[(a, q)]] 
   563                                         - f[i,a] * eta2B[idx2B[(a, p)], idx2B[(i, q)]] 
   564   83.238 MiB    0.000 MiB               + f[a,i] * eta2B[idx2B[(i, p)], idx2B[(a, q)]]
   565                                       )
   566                             
   567                               # 2B - 2B
   568                               # n_a n_b nn_c + nn_a nn_b n_c = n_a n_b + (1 - n_a - n_b) * n_c
   569   83.238 MiB    0.000 MiB     etaGamma = dot(eta2B, dot(occB_2B, Gamma))
   570   83.238 MiB    0.000 MiB     for p in range(dim1B):
   571   83.238 MiB    0.000 MiB       for q in range(dim1B):
   572   83.238 MiB    0.000 MiB         for i in holes:
   573   83.238 MiB    0.000 MiB           df[p,q] += 0.5*(
   574   83.238 MiB    0.000 MiB             etaGamma[idx2B[(i,p)], idx2B[(i,q)]] 
   575   83.238 MiB    0.000 MiB             + transpose(etaGamma)[idx2B[(i,p)], idx2B[(i,q)]]
   576                                     )
   577                             
   578   83.238 MiB    0.000 MiB     etaGamma = dot(eta2B, dot(occC_2B, Gamma))
   579   83.238 MiB    0.000 MiB     for p in range(dim1B):
   580   83.238 MiB    0.000 MiB       for q in range(dim1B):
   581   83.238 MiB    0.000 MiB         for r in range(dim1B):
   582   83.238 MiB    0.000 MiB           df[p,q] += 0.5*(
   583   83.238 MiB    0.000 MiB             etaGamma[idx2B[(r,p)], idx2B[(r,q)]] 
   584   83.238 MiB    0.000 MiB             + transpose(etaGamma)[idx2B[(r,p)], idx2B[(r,q)]] 
   585                                     )
   586                             
   587                             
   588                               #############################        
   589                               # two-body flow equation  
   590   83.238 MiB    0.000 MiB     dGamma = np.zeros_like(Gamma)
   591                             
   592                               # 1B - 2B
   593   83.238 MiB    0.000 MiB     for p in range(dim1B):
   594   83.238 MiB    0.000 MiB       for q in range(dim1B):
   595   83.238 MiB    0.000 MiB         for r in range(dim1B):
   596   83.238 MiB    0.000 MiB           for s in range(dim1B):
   597   83.238 MiB    0.000 MiB             for t in range(dim1B):
   598   83.238 MiB    0.000 MiB               dGamma[idx2B[(p,q)],idx2B[(r,s)]] += (
   599                                           eta1B[p,t] * Gamma[idx2B[(t,q)],idx2B[(r,s)]] 
   600                                           + eta1B[q,t] * Gamma[idx2B[(p,t)],idx2B[(r,s)]] 
   601                                           - eta1B[t,r] * Gamma[idx2B[(p,q)],idx2B[(t,s)]] 
   602                                           - eta1B[t,s] * Gamma[idx2B[(p,q)],idx2B[(r,t)]]
   603                                           - f[p,t] * eta2B[idx2B[(t,q)],idx2B[(r,s)]] 
   604                                           - f[q,t] * eta2B[idx2B[(p,t)],idx2B[(r,s)]] 
   605                                           + f[t,r] * eta2B[idx2B[(p,q)],idx2B[(t,s)]] 
   606   83.238 MiB    0.000 MiB                 + f[t,s] * eta2B[idx2B[(p,q)],idx2B[(r,t)]]
   607                                         )
   608                             
   609                               
   610                               # 2B - 2B - particle and hole ladders
   611                               # eta2B.occB.Gamma
   612   83.492 MiB    0.254 MiB     etaGamma = dot(eta2B, dot(occB_2B, Gamma))
   613                             
   614   83.492 MiB    0.000 MiB     dGamma += 0.5 * (etaGamma + transpose(etaGamma))
   615                             
   616                               # 2B - 2B - particle-hole chain
   617                               
   618                               # transform matrices to particle-hole representation and calculate 
   619                               # eta2B_ph.occA_ph.Gamma_ph
   620   83.492 MiB   83.492 MiB     eta2B_ph = ph_transform_2B(eta2B, bas2B, idx2B, basph2B, idxph2B)
   621   83.492 MiB   83.492 MiB     Gamma_ph = ph_transform_2B(Gamma, bas2B, idx2B, basph2B, idxph2B)
   622                             
   623   84.523 MiB    1.031 MiB     etaGamma_ph = dot(eta2B_ph, dot(occphA_2B, Gamma_ph))
   624                             
   625                               # transform back to standard representation
   626   84.523 MiB   84.523 MiB     etaGamma    = inverse_ph_transform_2B(etaGamma_ph, bas2B, idx2B, basph2B, idxph2B)
   627                             
   628                               # commutator / antisymmetrization
   629   84.523 MiB    0.000 MiB     work = np.zeros_like(etaGamma)
   630   84.523 MiB    0.000 MiB     for i1, (i,j) in enumerate(bas2B):
   631   84.523 MiB    0.000 MiB       for i2, (k,l) in enumerate(bas2B):
   632   84.523 MiB    0.000 MiB         work[i1, i2] -= (
   633                                     etaGamma[i1, i2] 
   634                                     - etaGamma[idx2B[(j,i)], i2] 
   635                                     - etaGamma[i1, idx2B[(l,k)]] 
   636   84.523 MiB    0.000 MiB           + etaGamma[idx2B[(j,i)], idx2B[(l,k)]]
   637                                   )
   638   84.523 MiB    0.000 MiB     etaGamma = work
   639                             
   640   84.523 MiB    0.000 MiB     dGamma += etaGamma
   641                             
   642                             
   643   84.523 MiB    0.000 MiB     return dE, df, dGamma


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   649   83.500 MiB   83.500 MiB   @profile
   650                             def get_operator_from_y(y, dim1B, dim2B):
   651                               
   652                               # reshape the solution vector into 0B, 1B, 2B pieces
   653   83.500 MiB    0.000 MiB     ptr = 0
   654   83.500 MiB    0.000 MiB     zero_body = y[ptr]
   655                             
   656   83.500 MiB    0.000 MiB     ptr += 1
   657   83.500 MiB    0.000 MiB     one_body = reshape(y[ptr:ptr+dim1B*dim1B], (dim1B, dim1B))
   658                             
   659   83.500 MiB    0.000 MiB     ptr += dim1B*dim1B
   660   83.500 MiB    0.000 MiB     two_body = reshape(y[ptr:ptr+dim2B*dim2B], (dim2B, dim2B))
   661                             
   662   83.500 MiB    0.000 MiB     return zero_body,one_body,two_body


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   707   78.285 MiB   78.285 MiB   @profile
   708                             def pairing_hamiltonian(delta, g, user_data):
   709   78.285 MiB    0.000 MiB     bas1B = user_data["bas1B"]
   710   78.285 MiB    0.000 MiB     bas2B = user_data["bas2B"]
   711   78.285 MiB    0.000 MiB     idx2B = user_data["idx2B"]
   712                             
   713   78.285 MiB    0.000 MiB     dim = len(bas1B)
   714   78.285 MiB    0.000 MiB     H1B = np.zeros((dim,dim))
   715                             
   716   78.285 MiB    0.000 MiB     for i in bas1B:
   717   78.285 MiB    0.000 MiB       H1B[i,i] = delta*np.floor_divide(i, 2)
   718                             
   719   78.285 MiB    0.000 MiB     dim = len(bas2B)
   720   78.285 MiB    0.000 MiB     H2B = np.zeros((dim, dim))
   721                             
   722                               # spin up states have even indices, spin down the next odd index
   723   78.285 MiB    0.000 MiB     for (i, j) in bas2B:
   724   78.285 MiB    0.000 MiB       if (i % 2 == 0 and j == i+1):
   725   78.285 MiB    0.000 MiB         for (k, l) in bas2B:
   726   78.285 MiB    0.000 MiB           if (k % 2 == 0 and l == k+1):
   727   78.285 MiB    0.000 MiB             H2B[idx2B[(i,j)],idx2B[(k,l)]] = -0.5*g
   728   78.285 MiB    0.000 MiB             H2B[idx2B[(j,i)],idx2B[(k,l)]] = 0.5*g
   729   78.285 MiB    0.000 MiB             H2B[idx2B[(i,j)],idx2B[(l,k)]] = 0.5*g
   730   78.285 MiB    0.000 MiB             H2B[idx2B[(j,i)],idx2B[(l,k)]] = -0.5*g
   731                               
   732   78.285 MiB    0.000 MiB     return H1B, H2B


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   737   78.285 MiB   78.285 MiB   @profile
   738                             def normal_order(H1B, H2B, user_data):
   739   78.285 MiB    0.000 MiB     bas1B     = user_data["bas1B"]
   740   78.285 MiB    0.000 MiB     bas2B     = user_data["bas2B"]
   741   78.285 MiB    0.000 MiB     idx2B     = user_data["idx2B"]
   742   78.285 MiB    0.000 MiB     particles = user_data["particles"]
   743   78.285 MiB    0.000 MiB     holes     = user_data["holes"]
   744                             
   745                               # 0B part
   746   78.285 MiB    0.000 MiB     E = 0.0
   747   78.285 MiB    0.000 MiB     for i in holes:
   748   78.285 MiB    0.000 MiB       E += H1B[i,i]
   749                             
   750   78.285 MiB    0.000 MiB     for i in holes:
   751   78.285 MiB    0.000 MiB       for j in holes:
   752   78.285 MiB    0.000 MiB         E += 0.5*H2B[idx2B[(i,j)],idx2B[(i,j)]]  
   753                             
   754                               # 1B part
   755   78.285 MiB    0.000 MiB     f = H1B
   756   78.480 MiB    0.000 MiB     for i in bas1B:
   757   78.480 MiB    0.000 MiB       for j in bas1B:
   758   78.480 MiB    0.000 MiB         for h in holes:
   759   78.480 MiB    0.195 MiB           f[i,j] += H2B[idx2B[(i,h)],idx2B[(j,h)]]  
   760                             
   761                               # 2B part
   762   78.480 MiB    0.000 MiB     Gamma = H2B
   763                             
   764   78.480 MiB    0.000 MiB     return E, f, Gamma


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   831   76.273 MiB   76.273 MiB   @profile
   832                             def main(n_holes):
   833                               # grab delta and g from the command line
   834                               # delta      = float(argv[1])
   835                               # g          = float(argv[2])
   836   76.273 MiB    0.000 MiB     delta = 1
   837   76.273 MiB    0.000 MiB     g = 0.5
   838                               
   839   76.273 MiB    0.000 MiB     particles  = n_holes
   840                             
   841                               # setup shared data
   842   76.273 MiB    0.000 MiB     dim1B     = n_holes*2
   843                             
   844                               # this defines the reference state
   845                               # 1st state
   846   76.273 MiB    0.000 MiB     holes = np.arange(particles)
   847   76.273 MiB    0.000 MiB     particles = np.arange(particles,dim1B)
   848                             
   849                               # 2nd state
   850                               # holes     = [0,1,4,5]
   851                               # particles = [2,3,6,7]
   852                             
   853                               # 3rd state
   854                               # holes     = [0,1,6,7]
   855                               # particles = [2,3,4,5]
   856                             
   857                               # basis definitions
   858   76.273 MiB    0.000 MiB     bas1B     = list(range(dim1B))
   859   76.273 MiB   76.273 MiB     bas2B     = construct_basis_2B(holes, particles)
   860   76.273 MiB   76.273 MiB     basph2B   = construct_basis_ph2B(holes, particles)
   861                             
   862   76.273 MiB   76.273 MiB     idx2B     = construct_index_2B(bas2B)
   863   76.273 MiB   76.273 MiB     idxph2B   = construct_index_2B(basph2B)
   864                             
   865                               # occupation number matrices
   866   76.273 MiB   76.273 MiB     occ1B     = construct_occupation_1B(bas1B, holes, particles)
   867   76.738 MiB   76.738 MiB     occA_2B   = construct_occupationA_2B(bas2B, occ1B)
   868   77.254 MiB   77.254 MiB     occB_2B   = construct_occupationB_2B(bas2B, occ1B)
   869   77.770 MiB   77.770 MiB     occC_2B   = construct_occupationC_2B(bas2B, occ1B)
   870                             
   871   78.285 MiB   78.285 MiB     occphA_2B = construct_occupationA_2B(basph2B, occ1B)
   872                             
   873                               # store shared data in a dictionary, so we can avoid passing the basis
   874                               # lookups etc. as separate parameters all the time
   875                               user_data  = {
   876   78.285 MiB    0.000 MiB       "dim1B":      dim1B, 
   877   78.285 MiB    0.000 MiB       "holes":      holes,
   878   78.285 MiB    0.000 MiB       "particles":  particles,
   879   78.285 MiB    0.000 MiB       "bas1B":      bas1B,
   880   78.285 MiB    0.000 MiB       "bas2B":      bas2B,
   881   78.285 MiB    0.000 MiB       "basph2B":    basph2B,
   882   78.285 MiB    0.000 MiB       "idx2B":      idx2B,
   883   78.285 MiB    0.000 MiB       "idxph2B":    idxph2B,
   884   78.285 MiB    0.000 MiB       "occ1B":      occ1B,
   885   78.285 MiB    0.000 MiB       "occA_2B":    occA_2B,
   886   78.285 MiB    0.000 MiB       "occB_2B":    occB_2B,
   887   78.285 MiB    0.000 MiB       "occC_2B":    occC_2B,
   888   78.285 MiB    0.000 MiB       "occphA_2B":  occphA_2B,
   889                             
   890   78.285 MiB    0.000 MiB       "eta_norm":   0.0,                # variables for sharing data between ODE solver
   891   78.285 MiB    0.000 MiB       "dE":         0.0,                # and main routine
   892                             
   893                             
   894   78.285 MiB    0.000 MiB       "calc_eta":   eta_wegner,          # specify the generator (function object)
   895   78.285 MiB    0.000 MiB       "calc_rhs":   flow_imsrg2         # specify the right-hand side and truncation
   896                               }
   897                             
   898                               # set up initial Hamiltonian
   899   78.285 MiB   78.285 MiB     H1B, H2B = pairing_hamiltonian(delta, g, user_data)
   900                               
   901   78.480 MiB   78.480 MiB     E, f, Gamma = normal_order(H1B, H2B, user_data) 
   902                             
   903                               # reshape Hamiltonian into a linear array (initial ODE vector)
   904   79.254 MiB    0.773 MiB     y0   = np.append([E], np.append(reshape(f, -1), reshape(Gamma, -1)))
   905                             
   906   79.254 MiB    0.000 MiB     t = 1
   907   83.500 MiB   83.500 MiB     dy = derivative_wrapper(t, y0, user_data)
   908   83.500 MiB   83.500 MiB     dE, df, dG = get_operator_from_y(dy, dim1B, dim1B*dim1B)
   909   83.500 MiB    0.000 MiB     print(dE)


---------------------------------------------

Executing NP on n_holes=10 ---------------------------
-25.0
Wrote profile results to imsrg_pairing_bench.py.lprof
Timer unit: 1e-06 s

Total time: 0.001124 s
File: imsrg_pairing_bench.py
Function: construct_basis_2B at line 30

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    30                                           @profile
    31                                           def construct_basis_2B(holes, particles):
    32         1          2.0      2.0      0.2    basis = []
    33        11         16.0      1.5      1.4    for i in holes:
    34       110        152.0      1.4     13.5      for j in holes:
    35       100        124.0      1.2     11.0        basis.append((i, j)) # hole, hole
    36                                           
    37        11         13.0      1.2      1.2    for i in holes:
    38       110        142.0      1.3     12.6      for a in particles:
    39       100        136.0      1.4     12.1        basis.append((i, a)) # hole, particle
    40                                           
    41        11         12.0      1.1      1.1    for a in particles:
    42       110        144.0      1.3     12.8      for i in holes:
    43       100        117.0      1.2     10.4        basis.append((a, i)) # particle, hole
    44                                           
    45        11         14.0      1.3      1.2    for a in particles:
    46       110        140.0      1.3     12.5      for b in particles:
    47       100        110.0      1.1      9.8        basis.append((a, b)) # particle, particle
    48                                           
    49         1          2.0      2.0      0.2    return basis

Total time: 0.001116 s
File: imsrg_pairing_bench.py
Function: construct_basis_ph2B at line 52

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    52                                           @profile
    53                                           def construct_basis_ph2B(holes, particles):
    54         1          1.0      1.0      0.1    basis = []
    55        11         12.0      1.1      1.1    for i in holes:
    56       110        138.0      1.3     12.4      for j in holes:
    57       100        116.0      1.2     10.4        basis.append((i, j))
    58                                           
    59        11         13.0      1.2      1.2    for i in holes:
    60       110        202.0      1.8     18.1      for a in particles:
    61       100        116.0      1.2     10.4        basis.append((i, a))
    62                                           
    63        11         11.0      1.0      1.0    for a in particles:
    64       110        146.0      1.3     13.1      for i in holes:
    65       100        136.0      1.4     12.2        basis.append((a, i))
    66                                           
    67        11         12.0      1.1      1.1    for a in particles:
    68       110        116.0      1.1     10.4      for b in particles:
    69       100         97.0      1.0      8.7        basis.append((a, b))
    70                                           
    71         1          0.0      0.0      0.0    return basis

Total time: 0.001216 s
File: imsrg_pairing_bench.py
Function: construct_index_2B at line 77

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    77                                           @profile
    78                                           def construct_index_2B(bas2B):
    79         2          2.0      1.0      0.2    index = { }
    80       802        534.0      0.7     43.9    for i, state in enumerate(bas2B):
    81       800        679.0      0.8     55.8      index[state] = i
    82                                           
    83         2          1.0      0.5      0.1    return index

Total time: 1.07411 s
File: imsrg_pairing_bench.py
Function: ph_transform_2B at line 90

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    90                                           @profile
    91                                           def ph_transform_2B(Gamma, bas2B, idx2B, basph2B, idxph2B):
    92         4         20.0      5.0      0.0    dim = len(basph2B)
    93         4        474.0    118.5      0.0    Gamma_ph = np.zeros((dim, dim))
    94                                           
    95      1604        788.0      0.5      0.1    for i1, (a,b) in enumerate(basph2B):
    96    641600     291342.0      0.5     27.1      for i2, (c, d) in enumerate(basph2B):
    97    640000     781483.0      1.2     72.8        Gamma_ph[i1, i2] -= Gamma[idx2B[(a,d)], idx2B[(c,b)]]
    98                                           
    99         4          1.0      0.2      0.0    return Gamma_ph

Total time: 0.574887 s
File: imsrg_pairing_bench.py
Function: inverse_ph_transform_2B at line 101

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   101                                           @profile
   102                                           def inverse_ph_transform_2B(Gamma_ph, bas2B, idx2B, basph2B, idxph2B):
   103         2          4.0      2.0      0.0    dim = len(bas2B)
   104         2        294.0    147.0      0.1    Gamma = np.zeros((dim, dim))
   105                                           
   106       802        397.0      0.5      0.1    for i1, (a,b) in enumerate(bas2B):
   107    320800     156431.0      0.5     27.2      for i2, (c, d) in enumerate(bas2B):
   108    320000     417758.0      1.3     72.7        Gamma[i1, i2] -= Gamma_ph[idxph2B[(a,d)], idxph2B[(c,b)]]
   109                                             
   110         2          3.0      1.5      0.0    return Gamma

Total time: 0.038007 s
File: imsrg_pairing_bench.py
Function: commutator at line 115

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   115                                           @profile
   116                                           def commutator(a,b):
   117         2      38007.0  19003.5    100.0    return dot(a,b) - dot(b,a)

Total time: 4.5e-05 s
File: imsrg_pairing_bench.py
Function: construct_occupation_1B at line 150

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   150                                           @profile
   151                                           def construct_occupation_1B(bas1B, holes, particles):
   152         1          2.0      2.0      4.4    dim = len(bas1B)
   153         1         13.0     13.0     28.9    occ = np.zeros(dim)
   154                                           
   155        11         17.0      1.5     37.8    for i in holes:
   156        10         12.0      1.2     26.7      occ[i] = 1.
   157                                           
   158         1          1.0      1.0      2.2    return occ

Total time: 0.003073 s
File: imsrg_pairing_bench.py
Function: construct_occupationA_2B at line 161

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   161                                           @profile
   162                                           def construct_occupationA_2B(bas2B, occ1B):
   163         2          3.0      1.5      0.1    dim = len(bas2B)
   164         2         27.0     13.5      0.9    occ = np.zeros((dim,dim))
   165                                           
   166       802        565.0      0.7     18.4    for i1, (i,j) in enumerate(bas2B):
   167       800       2477.0      3.1     80.6      occ[i1, i1] = occ1B[i] - occ1B[j]
   168                                           
   169         2          1.0      0.5      0.0    return occ

Total time: 0.001544 s
File: imsrg_pairing_bench.py
Function: construct_occupationB_2B at line 173

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   173                                           @profile
   174                                           def construct_occupationB_2B(bas2B, occ1B):
   175         1          2.0      2.0      0.1    dim = len(bas2B)
   176         1         11.0     11.0      0.7    occ = np.zeros((dim,dim))
   177                                           
   178       401        294.0      0.7     19.0    for i1, (i,j) in enumerate(bas2B):
   179       400       1236.0      3.1     80.1      occ[i1, i1] = 1. - occ1B[i] - occ1B[j]
   180                                           
   181         1          1.0      1.0      0.1    return occ

Total time: 0.001353 s
File: imsrg_pairing_bench.py
Function: construct_occupationC_2B at line 184

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   184                                           @profile
   185                                           def construct_occupationC_2B(bas2B, occ1B):
   186         1          1.0      1.0      0.1    dim = len(bas2B)
   187         1          9.0      9.0      0.7    occ = np.zeros((dim,dim))
   188                                           
   189       401        242.0      0.6     17.9    for i1, (i,j) in enumerate(bas2B):
   190       400       1100.0      2.8     81.3      occ[i1, i1] = occ1B[i] * occ1B[j]
   191                                           
   192         1          1.0      1.0      0.1    return occ

Total time: 42.6544 s
File: imsrg_pairing_bench.py
Function: eta_wegner at line 382

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   382                                           @profile
   383                                           def eta_wegner(f, Gamma, user_data):
   384                                           
   385         1          1.0      1.0      0.0    dim1B     = user_data["dim1B"]
   386         1          1.0      1.0      0.0    holes     = user_data["holes"]
   387         1          1.0      1.0      0.0    particles = user_data["particles"]
   388         1          1.0      1.0      0.0    bas2B     = user_data["bas2B"]
   389         1          0.0      0.0      0.0    basph2B   = user_data["basph2B"]
   390         1          1.0      1.0      0.0    idx2B     = user_data["idx2B"]
   391         1          1.0      1.0      0.0    idxph2B   = user_data["idxph2B"]
   392         1          1.0      1.0      0.0    occB_2B   = user_data["occB_2B"]
   393         1          1.0      1.0      0.0    occC_2B   = user_data["occC_2B"]
   394         1          1.0      1.0      0.0    occphA_2B = user_data["occphA_2B"]
   395                                           
   396                                           
   397                                             # split Hamiltonian in diagonal and off-diagonal parts
   398         1         18.0     18.0      0.0    fd      = np.zeros_like(f)
   399         1          6.0      6.0      0.0    fod     = np.zeros_like(f)
   400         1        395.0    395.0      0.0    Gammad  = np.zeros_like(Gamma)
   401         1        450.0    450.0      0.0    Gammaod = np.zeros_like(Gamma)
   402                                           
   403        11         10.0      0.9      0.0    for a in particles:
   404       110        107.0      1.0      0.0      for i in holes:
   405       100        109.0      1.1      0.0        fod[a, i] = f[a,i]
   406       100        108.0      1.1      0.0        fod[i, a] = f[i,a]
   407         1         12.0     12.0      0.0    fd = f - fod
   408                                           
   409        11         10.0      0.9      0.0    for a in particles:
   410       110        102.0      0.9      0.0      for b in particles:
   411      1100       1008.0      0.9      0.0        for i in holes:
   412     11000      10085.0      0.9      0.0          for j in holes:
   413     10000      17205.0      1.7      0.0            Gammaod[idx2B[(a,b)], idx2B[(i,j)]] = Gamma[idx2B[(a,b)], idx2B[(i,j)]]
   414     10000      17300.0      1.7      0.0            Gammaod[idx2B[(i,j)], idx2B[(a,b)]] = Gamma[idx2B[(i,j)], idx2B[(a,b)]]
   415         1        682.0    682.0      0.0    Gammad = Gamma - Gammaod
   416                                           
   417                                           
   418                                             #############################        
   419                                             # one-body flow equation  
   420         1         28.0     28.0      0.0    eta1B  = np.zeros_like(f)
   421                                           
   422                                             # 1B - 1B
   423         1      37995.0  37995.0      0.1    eta1B += commutator(fd, fod)
   424                                           
   425                                             # 1B - 2B
   426        21         23.0      1.1      0.0    for p in range(dim1B):
   427       420        403.0      1.0      0.0      for q in range(dim1B):
   428      4400       4223.0      1.0      0.0        for i in holes:
   429     44000      41250.0      0.9      0.1          for a in particles:
   430     40000      37457.0      0.9      0.1            eta1B[p,q] += (
   431                                                       fd[i,a]  * Gammaod[idx2B[(a, p)], idx2B[(i, q)]] 
   432                                                       - fd[a,i]  * Gammaod[idx2B[(i, p)], idx2B[(a, q)]] 
   433                                                       - fod[i,a] * Gammad[idx2B[(a, p)], idx2B[(i, q)]] 
   434     40000     202196.0      5.1      0.5              + fod[a,i] * Gammad[idx2B[(i, p)], idx2B[(a, q)]]
   435                                                     )
   436                                           
   437                                             # 2B - 2B
   438                                             # n_a n_b nn_c + nn_a nn_b n_c = n_a n_b + (1 - n_a - n_b) * n_c
   439         1       6316.0   6316.0      0.0    GammaGamma = dot(Gammad, dot(occB_2B, Gammaod))
   440        21         39.0      1.9      0.0    for p in range(dim1B):
   441       420        623.0      1.5      0.0      for q in range(dim1B):
   442      4400       7632.0      1.7      0.0        for i in holes:
   443      4000       6936.0      1.7      0.0          eta1B[p,q] += (
   444      4000      11676.0      2.9      0.0            0.5*GammaGamma[idx2B[(i,p)], idx2B[(i,q)]] 
   445      4000      23288.0      5.8      0.1            - transpose(GammaGamma)[idx2B[(i,p)], idx2B[(i,q)]]
   446                                                   )
   447                                           
   448         1      10107.0  10107.0      0.0    GammaGamma = dot(Gammad, dot(occC_2B, Gammaod))
   449        21         30.0      1.4      0.0    for p in range(dim1B):
   450       420        503.0      1.2      0.0      for q in range(dim1B):
   451      8400      10278.0      1.2      0.0        for r in range(dim1B):
   452      8000      11378.0      1.4      0.0          eta1B[p,q] += (
   453      8000      21863.0      2.7      0.1            0.5*GammaGamma[idx2B[(r,p)], idx2B[(r,q)]] 
   454      8000      38560.0      4.8      0.1            + transpose(GammaGamma)[idx2B[(r,p)], idx2B[(r,q)]] 
   455                                                   )
   456                                           
   457                                           
   458                                             #############################        
   459                                             # two-body flow equation  
   460         1        194.0    194.0      0.0    eta2B = np.zeros_like(Gamma)
   461                                           
   462                                             # 1B - 2B
   463        21         20.0      1.0      0.0    for p in range(dim1B):
   464       420        388.0      0.9      0.0      for q in range(dim1B):
   465      8400       7175.0      0.9      0.0        for r in range(dim1B):
   466    168000     140538.0      0.8      0.3          for s in range(dim1B):
   467   3360000    2821666.0      0.8      6.6            for t in range(dim1B):
   468   3200000    5284688.0      1.7     12.4              eta2B[idx2B[(p,q)],idx2B[(r,s)]] += (
   469                                                         fd[p,t] * Gammaod[idx2B[(t,q)],idx2B[(r,s)]] 
   470                                                         + fd[q,t] * Gammaod[idx2B[(p,t)],idx2B[(r,s)]] 
   471                                                         - fd[t,r] * Gammaod[idx2B[(p,q)],idx2B[(t,s)]] 
   472                                                         - fd[t,s] * Gammaod[idx2B[(p,q)],idx2B[(r,t)]]
   473                                                         - fod[p,t] * Gammad[idx2B[(t,q)],idx2B[(r,s)]] 
   474                                                         - fod[q,t] * Gammad[idx2B[(p,t)],idx2B[(r,s)]] 
   475                                                         + fod[t,r] * Gammad[idx2B[(p,q)],idx2B[(t,s)]] 
   476   3200000   31986121.0     10.0     75.0                + fod[t,s] * Gammad[idx2B[(p,q)],idx2B[(r,t)]]
   477                                                       )
   478                                           
   479                                             
   480                                             # 2B - 2B - particle and hole ladders
   481                                             # Gammad.occB.Gammaod
   482         1       5427.0   5427.0      0.0    GammaGamma = dot(Gammad, dot(occB_2B, Gammaod))
   483                                           
   484         1      47854.0  47854.0      0.1    eta2B += 0.5 * (GammaGamma - transpose(GammaGamma))
   485                                           
   486                                             # 2B - 2B - particle-hole chain
   487                                             
   488                                             # transform matrices to particle-hole representation and calculate 
   489                                             # Gammad_ph.occA_ph.Gammaod_ph
   490         1     384376.0 384376.0      0.9    Gammad_ph = ph_transform_2B(Gammad, bas2B, idx2B, basph2B, idxph2B)
   491         1     359098.0 359098.0      0.8    Gammaod_ph = ph_transform_2B(Gammaod, bas2B, idx2B, basph2B, idxph2B)
   492                                           
   493         1       5376.0   5376.0      0.0    GammaGamma_ph = dot(Gammad_ph, dot(occphA_2B, Gammaod_ph))
   494                                           
   495                                             # transform back to standard representation
   496         1     406530.0 406530.0      1.0    GammaGamma    = inverse_ph_transform_2B(GammaGamma_ph, bas2B, idx2B, basph2B, idxph2B)
   497                                           
   498                                             # commutator / antisymmetrization
   499         1        200.0    200.0      0.0    work = np.zeros_like(GammaGamma)
   500       401        365.0      0.9      0.0    for i1, (i,j) in enumerate(bas2B):
   501    160400     138224.0      0.9      0.3      for i2, (k,l) in enumerate(bas2B):
   502    160000     148127.0      0.9      0.3        work[i1, i2] -= (
   503                                                   GammaGamma[i1, i2] 
   504                                                   - GammaGamma[idx2B[(j,i)], i2] 
   505                                                   - GammaGamma[i1, idx2B[(l,k)]] 
   506    160000     397235.0      2.5      0.9          + GammaGamma[idx2B[(j,i)], idx2B[(l,k)]]
   507                                                 )
   508         1          3.0      3.0      0.0    GammaGamma = work
   509                                           
   510         1        328.0    328.0      0.0    eta2B += GammaGamma
   511                                           
   512                                           
   513         1          1.0      1.0      0.0    return eta1B, eta2B

Total time: 42.7451 s
File: imsrg_pairing_bench.py
Function: flow_imsrg2 at line 519

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   519                                           @profile
   520                                           def flow_imsrg2(eta1B, eta2B, f, Gamma, user_data):
   521                                           
   522         1          2.0      2.0      0.0    dim1B     = user_data["dim1B"]
   523         1          1.0      1.0      0.0    holes     = user_data["holes"]
   524         1          1.0      1.0      0.0    particles = user_data["particles"]
   525         1          1.0      1.0      0.0    bas2B     = user_data["bas2B"]
   526         1          1.0      1.0      0.0    idx2B     = user_data["idx2B"]
   527         1          1.0      1.0      0.0    basph2B   = user_data["basph2B"]
   528         1          1.0      1.0      0.0    idxph2B   = user_data["idxph2B"]
   529         1          2.0      2.0      0.0    occB_2B   = user_data["occB_2B"]
   530         1          0.0      0.0      0.0    occC_2B   = user_data["occC_2B"]
   531         1          1.0      1.0      0.0    occphA_2B = user_data["occphA_2B"]
   532                                           
   533                                             #############################        
   534                                             # zero-body flow equation
   535         1          1.0      1.0      0.0    dE = 0.0
   536                                           
   537        11         15.0      1.4      0.0    for i in holes:
   538       110         99.0      0.9      0.0      for a in particles:
   539       100        179.0      1.8      0.0        dE += eta1B[i,a] * f[a,i] - eta1B[a,i] * f[i,a]
   540                                           
   541        11          9.0      0.8      0.0    for i in holes:
   542       110         94.0      0.9      0.0      for j in holes:
   543      1100        989.0      0.9      0.0        for a in particles:
   544     11000       9952.0      0.9      0.0          for b in particles:
   545     10000      19672.0      2.0      0.0            dE += 0.5 * eta2B[idx2B[(i,j)], idx2B[(a,b)]] * Gamma[idx2B[(a,b)], idx2B[(i,j)]]
   546                                           
   547                                           
   548                                             #############################        
   549                                             # one-body flow equation  
   550         1         40.0     40.0      0.0    df  = np.zeros_like(f)
   551                                           
   552                                             # 1B - 1B
   553         1         54.0     54.0      0.0    df += commutator(eta1B, f)
   554                                           
   555                                             # 1B - 2B
   556        21         19.0      0.9      0.0    for p in range(dim1B):
   557       420        366.0      0.9      0.0      for q in range(dim1B):
   558      4400       3895.0      0.9      0.0        for i in holes:
   559     44000      39459.0      0.9      0.1          for a in particles:
   560     40000      35987.0      0.9      0.1            df[p,q] += (
   561                                                       eta1B[i,a] * Gamma[idx2B[(a, p)], idx2B[(i, q)]] 
   562                                                       - eta1B[a,i] * Gamma[idx2B[(i, p)], idx2B[(a, q)]] 
   563                                                       - f[i,a] * eta2B[idx2B[(a, p)], idx2B[(i, q)]] 
   564     40000     189417.0      4.7      0.4              + f[a,i] * eta2B[idx2B[(i, p)], idx2B[(a, q)]]
   565                                                     )
   566                                           
   567                                             # 2B - 2B
   568                                             # n_a n_b nn_c + nn_a nn_b n_c = n_a n_b + (1 - n_a - n_b) * n_c
   569         1       4501.0   4501.0      0.0    etaGamma = dot(eta2B, dot(occB_2B, Gamma))
   570        21         35.0      1.7      0.0    for p in range(dim1B):
   571       420        611.0      1.5      0.0      for q in range(dim1B):
   572      4400       7231.0      1.6      0.0        for i in holes:
   573      4000       6679.0      1.7      0.0          df[p,q] += 0.5*(
   574      4000      10634.0      2.7      0.0            etaGamma[idx2B[(i,p)], idx2B[(i,q)]] 
   575      4000      21717.0      5.4      0.1            + transpose(etaGamma)[idx2B[(i,p)], idx2B[(i,q)]]
   576                                                   )
   577                                           
   578         1       4982.0   4982.0      0.0    etaGamma = dot(eta2B, dot(occC_2B, Gamma))
   579        21         31.0      1.5      0.0    for p in range(dim1B):
   580       420        508.0      1.2      0.0      for q in range(dim1B):
   581      8400      10308.0      1.2      0.0        for r in range(dim1B):
   582      8000      11368.0      1.4      0.0          df[p,q] += 0.5*(
   583      8000      20128.0      2.5      0.0            etaGamma[idx2B[(r,p)], idx2B[(r,q)]] 
   584      8000      37971.0      4.7      0.1            + transpose(etaGamma)[idx2B[(r,p)], idx2B[(r,q)]] 
   585                                                   )
   586                                           
   587                                           
   588                                             #############################        
   589                                             # two-body flow equation  
   590         1        190.0    190.0      0.0    dGamma = np.zeros_like(Gamma)
   591                                           
   592                                             # 1B - 2B
   593        21         19.0      0.9      0.0    for p in range(dim1B):
   594       420        372.0      0.9      0.0      for q in range(dim1B):
   595      8400       7301.0      0.9      0.0        for r in range(dim1B):
   596    168000     143779.0      0.9      0.3          for s in range(dim1B):
   597   3360000    2905301.0      0.9      6.8            for t in range(dim1B):
   598   3200000    5347693.0      1.7     12.5              dGamma[idx2B[(p,q)],idx2B[(r,s)]] += (
   599                                                         eta1B[p,t] * Gamma[idx2B[(t,q)],idx2B[(r,s)]] 
   600                                                         + eta1B[q,t] * Gamma[idx2B[(p,t)],idx2B[(r,s)]] 
   601                                                         - eta1B[t,r] * Gamma[idx2B[(p,q)],idx2B[(t,s)]] 
   602                                                         - eta1B[t,s] * Gamma[idx2B[(p,q)],idx2B[(r,t)]]
   603                                                         - f[p,t] * eta2B[idx2B[(t,q)],idx2B[(r,s)]] 
   604                                                         - f[q,t] * eta2B[idx2B[(p,t)],idx2B[(r,s)]] 
   605                                                         + f[t,r] * eta2B[idx2B[(p,q)],idx2B[(t,s)]] 
   606   3200000   31921799.0     10.0     74.7                + f[t,s] * eta2B[idx2B[(p,q)],idx2B[(r,t)]]
   607                                                       )
   608                                           
   609                                             
   610                                             # 2B - 2B - particle and hole ladders
   611                                             # eta2B.occB.Gamma
   612         1       5511.0   5511.0      0.0    etaGamma = dot(eta2B, dot(occB_2B, Gamma))
   613                                           
   614         1        924.0    924.0      0.0    dGamma += 0.5 * (etaGamma + transpose(etaGamma))
   615                                           
   616                                             # 2B - 2B - particle-hole chain
   617                                             
   618                                             # transform matrices to particle-hole representation and calculate 
   619                                             # eta2B_ph.occA_ph.Gamma_ph
   620         1     439301.0 439301.0      1.0    eta2B_ph = ph_transform_2B(eta2B, bas2B, idx2B, basph2B, idxph2B)
   621         1     395493.0 395493.0      0.9    Gamma_ph = ph_transform_2B(Gamma, bas2B, idx2B, basph2B, idxph2B)
   622                                           
   623         1       5738.0   5738.0      0.0    etaGamma_ph = dot(eta2B_ph, dot(occphA_2B, Gamma_ph))
   624                                           
   625                                             # transform back to standard representation
   626         1     435403.0 435403.0      1.0    etaGamma    = inverse_ph_transform_2B(etaGamma_ph, bas2B, idx2B, basph2B, idxph2B)
   627                                           
   628                                             # commutator / antisymmetrization
   629         1        198.0    198.0      0.0    work = np.zeros_like(etaGamma)
   630       401        378.0      0.9      0.0    for i1, (i,j) in enumerate(bas2B):
   631    160400     143009.0      0.9      0.3      for i2, (k,l) in enumerate(bas2B):
   632    160000     153964.0      1.0      0.4        work[i1, i2] -= (
   633                                                   etaGamma[i1, i2] 
   634                                                   - etaGamma[idx2B[(j,i)], i2] 
   635                                                   - etaGamma[i1, idx2B[(l,k)]] 
   636    160000     401345.0      2.5      0.9          + etaGamma[idx2B[(j,i)], idx2B[(l,k)]]
   637                                                 )
   638         1          6.0      6.0      0.0    etaGamma = work
   639                                           
   640         1        378.0    378.0      0.0    dGamma += etaGamma
   641                                           
   642                                           
   643         1          2.0      2.0      0.0    return dE, df, dGamma

Total time: 5.9e-05 s
File: imsrg_pairing_bench.py
Function: get_operator_from_y at line 649

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   649                                           @profile
   650                                           def get_operator_from_y(y, dim1B, dim2B):
   651                                             
   652                                             # reshape the solution vector into 0B, 1B, 2B pieces
   653         2          2.0      1.0      3.4    ptr = 0
   654         2          4.0      2.0      6.8    zero_body = y[ptr]
   655                                           
   656         2          1.0      0.5      1.7    ptr += 1
   657         2         40.0     20.0     67.8    one_body = reshape(y[ptr:ptr+dim1B*dim1B], (dim1B, dim1B))
   658                                           
   659         2          2.0      1.0      3.4    ptr += dim1B*dim1B
   660         2          8.0      4.0     13.6    two_body = reshape(y[ptr:ptr+dim2B*dim2B], (dim2B, dim2B))
   661                                           
   662         2          2.0      1.0      3.4    return zero_body,one_body,two_body

Total time: 0.007958 s
File: imsrg_pairing_bench.py
Function: pairing_hamiltonian at line 707

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   707                                           @profile
   708                                           def pairing_hamiltonian(delta, g, user_data):
   709         1          1.0      1.0      0.0    bas1B = user_data["bas1B"]
   710         1          1.0      1.0      0.0    bas2B = user_data["bas2B"]
   711         1          1.0      1.0      0.0    idx2B = user_data["idx2B"]
   712                                           
   713         1          1.0      1.0      0.0    dim = len(bas1B)
   714         1          4.0      4.0      0.1    H1B = np.zeros((dim,dim))
   715                                           
   716        21         19.0      0.9      0.2    for i in bas1B:
   717        20         73.0      3.6      0.9      H1B[i,i] = delta*np.floor_divide(i, 2)
   718                                           
   719         1          1.0      1.0      0.0    dim = len(bas2B)
   720         1          7.0      7.0      0.1    H2B = np.zeros((dim, dim))
   721                                           
   722                                             # spin up states have even indices, spin down the next odd index
   723       401        238.0      0.6      3.0    for (i, j) in bas2B:
   724       400        436.0      1.1      5.5      if (i % 2 == 0 and j == i+1):
   725      4010       2419.0      0.6     30.4        for (k, l) in bas2B:
   726      4000       4228.0      1.1     53.1          if (k % 2 == 0 and l == k+1):
   727       100        141.0      1.4      1.8            H2B[idx2B[(i,j)],idx2B[(k,l)]] = -0.5*g
   728       100        149.0      1.5      1.9            H2B[idx2B[(j,i)],idx2B[(k,l)]] = 0.5*g
   729       100        123.0      1.2      1.5            H2B[idx2B[(i,j)],idx2B[(l,k)]] = 0.5*g
   730       100        116.0      1.2      1.5            H2B[idx2B[(j,i)],idx2B[(l,k)]] = -0.5*g
   731                                             
   732         1          0.0      0.0      0.0    return H1B, H2B

Total time: 0.00921 s
File: imsrg_pairing_bench.py
Function: normal_order at line 737

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   737                                           @profile
   738                                           def normal_order(H1B, H2B, user_data):
   739         1          1.0      1.0      0.0    bas1B     = user_data["bas1B"]
   740         1          1.0      1.0      0.0    bas2B     = user_data["bas2B"]
   741         1          0.0      0.0      0.0    idx2B     = user_data["idx2B"]
   742         1          0.0      0.0      0.0    particles = user_data["particles"]
   743         1          0.0      0.0      0.0    holes     = user_data["holes"]
   744                                           
   745                                             # 0B part
   746         1          0.0      0.0      0.0    E = 0.0
   747        11         14.0      1.3      0.2    for i in holes:
   748        10          9.0      0.9      0.1      E += H1B[i,i]
   749                                           
   750        11          8.0      0.7      0.1    for i in holes:
   751       110         65.0      0.6      0.7      for j in holes:
   752       100        157.0      1.6      1.7        E += 0.5*H2B[idx2B[(i,j)],idx2B[(i,j)]]  
   753                                           
   754                                             # 1B part
   755         1          0.0      0.0      0.0    f = H1B
   756        21         15.0      0.7      0.2    for i in bas1B:
   757       420        211.0      0.5      2.3      for j in bas1B:
   758      4400       2703.0      0.6     29.3        for h in holes:
   759      4000       6025.0      1.5     65.4          f[i,j] += H2B[idx2B[(i,h)],idx2B[(j,h)]]  
   760                                           
   761                                             # 2B part
   762         1          1.0      1.0      0.0    Gamma = H2B
   763                                           
   764         1          0.0      0.0      0.0    return E, f, Gamma

Total time: 106.086 s
File: imsrg_pairing_bench.py
Function: main at line 831

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   831                                           @profile
   832                                           def main(n_holes):
   833                                             # grab delta and g from the command line
   834                                             # delta      = float(argv[1])
   835                                             # g          = float(argv[2])
   836         1          6.0      6.0      0.0    delta = 1
   837         1          3.0      3.0      0.0    g = 0.5
   838                                             
   839         1          3.0      3.0      0.0    particles  = n_holes
   840                                           
   841                                             # setup shared data
   842         1          3.0      3.0      0.0    dim1B     = n_holes*2
   843                                           
   844                                             # this defines the reference state
   845                                             # 1st state
   846         1         18.0     18.0      0.0    holes = np.arange(particles)
   847         1          8.0      8.0      0.0    particles = np.arange(particles,dim1B)
   848                                           
   849                                             # 2nd state
   850                                             # holes     = [0,1,4,5]
   851                                             # particles = [2,3,6,7]
   852                                           
   853                                             # 3rd state
   854                                             # holes     = [0,1,6,7]
   855                                             # particles = [2,3,4,5]
   856                                           
   857                                             # basis definitions
   858         1          8.0      8.0      0.0    bas1B     = list(range(dim1B))
   859         1       1806.0   1806.0      0.0    bas2B     = construct_basis_2B(holes, particles)
   860         1       1779.0   1779.0      0.0    basph2B   = construct_basis_ph2B(holes, particles)
   861                                           
   862         1       1067.0   1067.0      0.0    idx2B     = construct_index_2B(bas2B)
   863         1        978.0    978.0      0.0    idxph2B   = construct_index_2B(basph2B)
   864                                           
   865                                             # occupation number matrices
   866         1         70.0     70.0      0.0    occ1B     = construct_occupation_1B(bas1B, holes, particles)
   867         1       2231.0   2231.0      0.0    occA_2B   = construct_occupationA_2B(bas2B, occ1B)
   868         1       2053.0   2053.0      0.0    occB_2B   = construct_occupationB_2B(bas2B, occ1B)
   869         1       1761.0   1761.0      0.0    occC_2B   = construct_occupationC_2B(bas2B, occ1B)
   870                                           
   871         1       1742.0   1742.0      0.0    occphA_2B = construct_occupationA_2B(basph2B, occ1B)
   872                                           
   873                                             # store shared data in a dictionary, so we can avoid passing the basis
   874                                             # lookups etc. as separate parameters all the time
   875                                             user_data  = {
   876         1          2.0      2.0      0.0      "dim1B":      dim1B, 
   877         1          1.0      1.0      0.0      "holes":      holes,
   878         1          1.0      1.0      0.0      "particles":  particles,
   879         1          1.0      1.0      0.0      "bas1B":      bas1B,
   880         1          1.0      1.0      0.0      "bas2B":      bas2B,
   881         1          2.0      2.0      0.0      "basph2B":    basph2B,
   882         1          1.0      1.0      0.0      "idx2B":      idx2B,
   883         1          1.0      1.0      0.0      "idxph2B":    idxph2B,
   884         1          2.0      2.0      0.0      "occ1B":      occ1B,
   885         1          1.0      1.0      0.0      "occA_2B":    occA_2B,
   886         1          1.0      1.0      0.0      "occB_2B":    occB_2B,
   887         1          1.0      1.0      0.0      "occC_2B":    occC_2B,
   888         1          1.0      1.0      0.0      "occphA_2B":  occphA_2B,
   889                                           
   890         1          1.0      1.0      0.0      "eta_norm":   0.0,                # variables for sharing data between ODE solver
   891         1          1.0      1.0      0.0      "dE":         0.0,                # and main routine
   892                                           
   893                                           
   894         1          1.0      1.0      0.0      "calc_eta":   eta_wegner,          # specify the generator (function object)
   895         1          3.0      3.0      0.0      "calc_rhs":   flow_imsrg2         # specify the right-hand side and truncation
   896                                             }
   897                                           
   898                                             # set up initial Hamiltonian
   899         1      14585.0  14585.0      0.0    H1B, H2B = pairing_hamiltonian(delta, g, user_data)
   900                                             
   901         1      14005.0  14005.0      0.0    E, f, Gamma = normal_order(H1B, H2B, user_data) 
   902                                           
   903                                             # reshape Hamiltonian into a linear array (initial ODE vector)
   904         1       1358.0   1358.0      0.0    y0   = np.append([E], np.append(reshape(f, -1), reshape(Gamma, -1)))
   905                                           
   906         1          2.0      2.0      0.0    t = 1
   907         1  106042738.0 106042738.0    100.0    dy = derivative_wrapper(t, y0, user_data)
   908         1         40.0     40.0      0.0    dE, df, dG = get_operator_from_y(dy, dim1B, dim1B*dim1B)
   909         1         18.0     18.0      0.0    print(dE)

-25.0
Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
    30   75.211 MiB   75.211 MiB   @profile
    31                             def construct_basis_2B(holes, particles):
    32   75.211 MiB    0.000 MiB     basis = []
    33   75.211 MiB    0.000 MiB     for i in holes:
    34   75.211 MiB    0.000 MiB       for j in holes:
    35   75.211 MiB    0.000 MiB         basis.append((i, j)) # hole, hole
    36                             
    37   75.211 MiB    0.000 MiB     for i in holes:
    38   75.211 MiB    0.000 MiB       for a in particles:
    39   75.211 MiB    0.000 MiB         basis.append((i, a)) # hole, particle
    40                             
    41   75.211 MiB    0.000 MiB     for a in particles:
    42   75.211 MiB    0.000 MiB       for i in holes:
    43   75.211 MiB    0.000 MiB         basis.append((a, i)) # particle, hole
    44                             
    45   75.211 MiB    0.000 MiB     for a in particles:
    46   75.211 MiB    0.000 MiB       for b in particles:
    47   75.211 MiB    0.000 MiB         basis.append((a, b)) # particle, particle
    48                             
    49   75.211 MiB    0.000 MiB     return basis


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
    52   75.211 MiB   75.211 MiB   @profile
    53                             def construct_basis_ph2B(holes, particles):
    54   75.211 MiB    0.000 MiB     basis = []
    55   75.211 MiB    0.000 MiB     for i in holes:
    56   75.211 MiB    0.000 MiB       for j in holes:
    57   75.211 MiB    0.000 MiB         basis.append((i, j))
    58                             
    59   75.211 MiB    0.000 MiB     for i in holes:
    60   75.211 MiB    0.000 MiB       for a in particles:
    61   75.211 MiB    0.000 MiB         basis.append((i, a))
    62                             
    63   75.211 MiB    0.000 MiB     for a in particles:
    64   75.211 MiB    0.000 MiB       for i in holes:
    65   75.211 MiB    0.000 MiB         basis.append((a, i))
    66                             
    67   75.211 MiB    0.000 MiB     for a in particles:
    68   75.211 MiB    0.000 MiB       for b in particles:
    69   75.211 MiB    0.000 MiB         basis.append((a, b))
    70                             
    71   75.211 MiB    0.000 MiB     return basis


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
    77   75.211 MiB   75.211 MiB   @profile
    78                             def construct_index_2B(bas2B):
    79   75.211 MiB    0.000 MiB     index = { }
    80   75.211 MiB    0.000 MiB     for i, state in enumerate(bas2B):
    81   75.211 MiB    0.000 MiB       index[state] = i
    82                             
    83   75.211 MiB    0.000 MiB     return index


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
    90   90.246 MiB   90.246 MiB   @profile
    91                             def ph_transform_2B(Gamma, bas2B, idx2B, basph2B, idxph2B):
    92   90.246 MiB    0.000 MiB     dim = len(basph2B)
    93   90.246 MiB    0.000 MiB     Gamma_ph = np.zeros((dim, dim))
    94                             
    95   90.246 MiB    0.000 MiB     for i1, (a,b) in enumerate(basph2B):
    96   90.246 MiB    0.000 MiB       for i2, (c, d) in enumerate(basph2B):
    97   90.246 MiB    0.000 MiB         Gamma_ph[i1, i2] -= Gamma[idx2B[(a,d)], idx2B[(c,b)]]
    98                             
    99   90.246 MiB    0.000 MiB     return Gamma_ph


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   101   93.035 MiB   93.035 MiB   @profile
   102                             def inverse_ph_transform_2B(Gamma_ph, bas2B, idx2B, basph2B, idxph2B):
   103   93.035 MiB    0.000 MiB     dim = len(bas2B)
   104   93.035 MiB    0.000 MiB     Gamma = np.zeros((dim, dim))
   105                             
   106   93.035 MiB    0.000 MiB     for i1, (a,b) in enumerate(bas2B):
   107   93.035 MiB    0.000 MiB       for i2, (c, d) in enumerate(bas2B):
   108   93.035 MiB    0.000 MiB         Gamma[i1, i2] -= Gamma_ph[idxph2B[(a,d)], idxph2B[(c,b)]]
   109                               
   110   93.035 MiB    0.000 MiB     return Gamma


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   115   88.434 MiB   88.434 MiB   @profile
   116                             def commutator(a,b):
   117   88.434 MiB    0.000 MiB     return dot(a,b) - dot(b,a)


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   150   75.211 MiB   75.211 MiB   @profile
   151                             def construct_occupation_1B(bas1B, holes, particles):
   152   75.211 MiB    0.000 MiB     dim = len(bas1B)
   153   75.211 MiB    0.000 MiB     occ = np.zeros(dim)
   154                             
   155   75.211 MiB    0.000 MiB     for i in holes:
   156   75.211 MiB    0.000 MiB       occ[i] = 1.
   157                             
   158   75.211 MiB    0.000 MiB     return occ


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   161   78.773 MiB   78.773 MiB   @profile
   162                             def construct_occupationA_2B(bas2B, occ1B):
   163   78.773 MiB    0.000 MiB     dim = len(bas2B)
   164   78.773 MiB    0.000 MiB     occ = np.zeros((dim,dim))
   165                             
   166   80.062 MiB    0.000 MiB     for i1, (i,j) in enumerate(bas2B):
   167   80.062 MiB    0.258 MiB       occ[i1, i1] = occ1B[i] - occ1B[j]
   168                             
   169   80.062 MiB    0.000 MiB     return occ


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   173   76.453 MiB   76.453 MiB   @profile
   174                             def construct_occupationB_2B(bas2B, occ1B):
   175   76.453 MiB    0.000 MiB     dim = len(bas2B)
   176   76.453 MiB    0.000 MiB     occ = np.zeros((dim,dim))
   177                             
   178   77.484 MiB    0.000 MiB     for i1, (i,j) in enumerate(bas2B):
   179   77.484 MiB    0.258 MiB       occ[i1, i1] = 1. - occ1B[i] - occ1B[j]
   180                             
   181   77.484 MiB    0.000 MiB     return occ


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   184   77.484 MiB   77.484 MiB   @profile
   185                             def construct_occupationC_2B(bas2B, occ1B):
   186   77.484 MiB    0.000 MiB     dim = len(bas2B)
   187   77.484 MiB    0.000 MiB     occ = np.zeros((dim,dim))
   188                             
   189   78.773 MiB    0.000 MiB     for i1, (i,j) in enumerate(bas2B):
   190   78.773 MiB    0.258 MiB       occ[i1, i1] = occ1B[i] * occ1B[j]
   191                             
   192   78.773 MiB    0.000 MiB     return occ


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   382   81.523 MiB   81.523 MiB   @profile
   383                             def eta_wegner(f, Gamma, user_data):
   384                             
   385   81.523 MiB    0.000 MiB     dim1B     = user_data["dim1B"]
   386   81.523 MiB    0.000 MiB     holes     = user_data["holes"]
   387   81.523 MiB    0.000 MiB     particles = user_data["particles"]
   388   81.523 MiB    0.000 MiB     bas2B     = user_data["bas2B"]
   389   81.523 MiB    0.000 MiB     basph2B   = user_data["basph2B"]
   390   81.523 MiB    0.000 MiB     idx2B     = user_data["idx2B"]
   391   81.523 MiB    0.000 MiB     idxph2B   = user_data["idxph2B"]
   392   81.523 MiB    0.000 MiB     occB_2B   = user_data["occB_2B"]
   393   81.523 MiB    0.000 MiB     occC_2B   = user_data["occC_2B"]
   394   81.523 MiB    0.000 MiB     occphA_2B = user_data["occphA_2B"]
   395                             
   396                             
   397                               # split Hamiltonian in diagonal and off-diagonal parts
   398   81.523 MiB    0.000 MiB     fd      = np.zeros_like(f)
   399   81.523 MiB    0.000 MiB     fod     = np.zeros_like(f)
   400   82.551 MiB    1.027 MiB     Gammad  = np.zeros_like(Gamma)
   401   83.840 MiB    1.289 MiB     Gammaod = np.zeros_like(Gamma)
   402                             
   403   83.840 MiB    0.000 MiB     for a in particles:
   404   83.840 MiB    0.000 MiB       for i in holes:
   405   83.840 MiB    0.000 MiB         fod[a, i] = f[a,i]
   406   83.840 MiB    0.000 MiB         fod[i, a] = f[i,a]
   407   83.840 MiB    0.000 MiB     fd = f - fod
   408                             
   409   83.840 MiB    0.000 MiB     for a in particles:
   410   83.840 MiB    0.000 MiB       for b in particles:
   411   83.840 MiB    0.000 MiB         for i in holes:
   412   83.840 MiB    0.000 MiB           for j in holes:
   413   83.840 MiB    0.000 MiB             Gammaod[idx2B[(a,b)], idx2B[(i,j)]] = Gamma[idx2B[(a,b)], idx2B[(i,j)]]
   414   83.840 MiB    0.000 MiB             Gammaod[idx2B[(i,j)], idx2B[(a,b)]] = Gamma[idx2B[(i,j)], idx2B[(a,b)]]
   415   85.129 MiB    1.289 MiB     Gammad = Gamma - Gammaod
   416                             
   417                             
   418                               #############################        
   419                               # one-body flow equation  
   420   85.129 MiB    0.000 MiB     eta1B  = np.zeros_like(f)
   421                             
   422                               # 1B - 1B
   423   85.129 MiB   85.129 MiB     eta1B += commutator(fd, fod)
   424                             
   425                               # 1B - 2B
   426   85.129 MiB    0.000 MiB     for p in range(dim1B):
   427   85.129 MiB    0.000 MiB       for q in range(dim1B):
   428   85.129 MiB    0.000 MiB         for i in holes:
   429   85.129 MiB    0.000 MiB           for a in particles:
   430   85.129 MiB    0.000 MiB             eta1B[p,q] += (
   431                                         fd[i,a]  * Gammaod[idx2B[(a, p)], idx2B[(i, q)]] 
   432                                         - fd[a,i]  * Gammaod[idx2B[(i, p)], idx2B[(a, q)]] 
   433                                         - fod[i,a] * Gammad[idx2B[(a, p)], idx2B[(i, q)]] 
   434   85.129 MiB    0.000 MiB               + fod[a,i] * Gammad[idx2B[(i, p)], idx2B[(a, q)]]
   435                                       )
   436                             
   437                               # 2B - 2B
   438                               # n_a n_b nn_c + nn_a nn_b n_c = n_a n_b + (1 - n_a - n_b) * n_c
   439   87.664 MiB    2.535 MiB     GammaGamma = dot(Gammad, dot(occB_2B, Gammaod))
   440   87.664 MiB    0.000 MiB     for p in range(dim1B):
   441   87.664 MiB    0.000 MiB       for q in range(dim1B):
   442   87.664 MiB    0.000 MiB         for i in holes:
   443   87.664 MiB    0.000 MiB           eta1B[p,q] += (
   444   87.664 MiB    0.000 MiB             0.5*GammaGamma[idx2B[(i,p)], idx2B[(i,q)]] 
   445   87.664 MiB    0.000 MiB             - transpose(GammaGamma)[idx2B[(i,p)], idx2B[(i,q)]]
   446                                     )
   447                             
   448   88.953 MiB    1.289 MiB     GammaGamma = dot(Gammad, dot(occC_2B, Gammaod))
   449   88.953 MiB    0.000 MiB     for p in range(dim1B):
   450   88.953 MiB    0.000 MiB       for q in range(dim1B):
   451   88.953 MiB    0.000 MiB         for r in range(dim1B):
   452   88.953 MiB    0.000 MiB           eta1B[p,q] += (
   453   88.953 MiB    0.000 MiB             0.5*GammaGamma[idx2B[(r,p)], idx2B[(r,q)]] 
   454   88.953 MiB    0.000 MiB             + transpose(GammaGamma)[idx2B[(r,p)], idx2B[(r,q)]] 
   455                                     )
   456                             
   457                             
   458                               #############################        
   459                               # two-body flow equation  
   460   88.953 MiB    0.000 MiB     eta2B = np.zeros_like(Gamma)
   461                             
   462                               # 1B - 2B
   463   88.953 MiB    0.000 MiB     for p in range(dim1B):
   464   88.953 MiB    0.000 MiB       for q in range(dim1B):
   465   88.953 MiB    0.000 MiB         for r in range(dim1B):
   466   88.953 MiB    0.000 MiB           for s in range(dim1B):
   467   88.953 MiB    0.000 MiB             for t in range(dim1B):
   468   88.953 MiB    0.000 MiB               eta2B[idx2B[(p,q)],idx2B[(r,s)]] += (
   469                                           fd[p,t] * Gammaod[idx2B[(t,q)],idx2B[(r,s)]] 
   470                                           + fd[q,t] * Gammaod[idx2B[(p,t)],idx2B[(r,s)]] 
   471                                           - fd[t,r] * Gammaod[idx2B[(p,q)],idx2B[(t,s)]] 
   472                                           - fd[t,s] * Gammaod[idx2B[(p,q)],idx2B[(r,t)]]
   473                                           - fod[p,t] * Gammad[idx2B[(t,q)],idx2B[(r,s)]] 
   474                                           - fod[q,t] * Gammad[idx2B[(p,t)],idx2B[(r,s)]] 
   475                                           + fod[t,r] * Gammad[idx2B[(p,q)],idx2B[(t,s)]] 
   476   88.953 MiB    0.000 MiB                 + fod[t,s] * Gammad[idx2B[(p,q)],idx2B[(r,t)]]
   477                                         )
   478                             
   479                               
   480                               # 2B - 2B - particle and hole ladders
   481                               # Gammad.occB.Gammaod
   482   89.984 MiB    1.031 MiB     GammaGamma = dot(Gammad, dot(occB_2B, Gammaod))
   483                             
   484   90.246 MiB    0.262 MiB     eta2B += 0.5 * (GammaGamma - transpose(GammaGamma))
   485                             
   486                               # 2B - 2B - particle-hole chain
   487                               
   488                               # transform matrices to particle-hole representation and calculate 
   489                               # Gammad_ph.occA_ph.Gammaod_ph
   490   90.246 MiB   90.246 MiB     Gammad_ph = ph_transform_2B(Gammad, bas2B, idx2B, basph2B, idxph2B)
   491   90.246 MiB   90.246 MiB     Gammaod_ph = ph_transform_2B(Gammaod, bas2B, idx2B, basph2B, idxph2B)
   492                             
   493   93.035 MiB    2.789 MiB     GammaGamma_ph = dot(Gammad_ph, dot(occphA_2B, Gammaod_ph))
   494                             
   495                               # transform back to standard representation
   496   93.035 MiB   93.035 MiB     GammaGamma    = inverse_ph_transform_2B(GammaGamma_ph, bas2B, idx2B, basph2B, idxph2B)
   497                             
   498                               # commutator / antisymmetrization
   499   93.035 MiB    0.000 MiB     work = np.zeros_like(GammaGamma)
   500   93.035 MiB    0.000 MiB     for i1, (i,j) in enumerate(bas2B):
   501   93.035 MiB    0.000 MiB       for i2, (k,l) in enumerate(bas2B):
   502   93.035 MiB    0.000 MiB         work[i1, i2] -= (
   503                                     GammaGamma[i1, i2] 
   504                                     - GammaGamma[idx2B[(j,i)], i2] 
   505                                     - GammaGamma[i1, idx2B[(l,k)]] 
   506   93.035 MiB    0.000 MiB           + GammaGamma[idx2B[(j,i)], idx2B[(l,k)]]
   507                                   )
   508   93.035 MiB    0.000 MiB     GammaGamma = work
   509                             
   510   93.035 MiB    0.000 MiB     eta2B += GammaGamma
   511                             
   512                             
   513   93.035 MiB    0.000 MiB     return eta1B, eta2B


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   519   88.434 MiB   88.434 MiB   @profile
   520                             def flow_imsrg2(eta1B, eta2B, f, Gamma, user_data):
   521                             
   522   88.434 MiB    0.000 MiB     dim1B     = user_data["dim1B"]
   523   88.434 MiB    0.000 MiB     holes     = user_data["holes"]
   524   88.434 MiB    0.000 MiB     particles = user_data["particles"]
   525   88.434 MiB    0.000 MiB     bas2B     = user_data["bas2B"]
   526   88.434 MiB    0.000 MiB     idx2B     = user_data["idx2B"]
   527   88.434 MiB    0.000 MiB     basph2B   = user_data["basph2B"]
   528   88.434 MiB    0.000 MiB     idxph2B   = user_data["idxph2B"]
   529   88.434 MiB    0.000 MiB     occB_2B   = user_data["occB_2B"]
   530   88.434 MiB    0.000 MiB     occC_2B   = user_data["occC_2B"]
   531   88.434 MiB    0.000 MiB     occphA_2B = user_data["occphA_2B"]
   532                             
   533                               #############################        
   534                               # zero-body flow equation
   535   88.434 MiB    0.000 MiB     dE = 0.0
   536                             
   537   88.434 MiB    0.000 MiB     for i in holes:
   538   88.434 MiB    0.000 MiB       for a in particles:
   539   88.434 MiB    0.000 MiB         dE += eta1B[i,a] * f[a,i] - eta1B[a,i] * f[i,a]
   540                             
   541   88.434 MiB    0.000 MiB     for i in holes:
   542   88.434 MiB    0.000 MiB       for j in holes:
   543   88.434 MiB    0.000 MiB         for a in particles:
   544   88.434 MiB    0.000 MiB           for b in particles:
   545   88.434 MiB    0.000 MiB             dE += 0.5 * eta2B[idx2B[(i,j)], idx2B[(a,b)]] * Gamma[idx2B[(a,b)], idx2B[(i,j)]]
   546                             
   547                             
   548                               #############################        
   549                               # one-body flow equation  
   550   88.434 MiB    0.000 MiB     df  = np.zeros_like(f)
   551                             
   552                               # 1B - 1B
   553   88.434 MiB   88.434 MiB     df += commutator(eta1B, f)
   554                             
   555                               # 1B - 2B
   556   88.434 MiB    0.000 MiB     for p in range(dim1B):
   557   88.434 MiB    0.000 MiB       for q in range(dim1B):
   558   88.434 MiB    0.000 MiB         for i in holes:
   559   88.434 MiB    0.000 MiB           for a in particles:
   560   88.434 MiB    0.000 MiB             df[p,q] += (
   561                                         eta1B[i,a] * Gamma[idx2B[(a, p)], idx2B[(i, q)]] 
   562                                         - eta1B[a,i] * Gamma[idx2B[(i, p)], idx2B[(a, q)]] 
   563                                         - f[i,a] * eta2B[idx2B[(a, p)], idx2B[(i, q)]] 
   564   88.434 MiB    0.000 MiB               + f[a,i] * eta2B[idx2B[(i, p)], idx2B[(a, q)]]
   565                                       )
   566                             
   567                               # 2B - 2B
   568                               # n_a n_b nn_c + nn_a nn_b n_c = n_a n_b + (1 - n_a - n_b) * n_c
   569   88.434 MiB    0.000 MiB     etaGamma = dot(eta2B, dot(occB_2B, Gamma))
   570   88.434 MiB    0.000 MiB     for p in range(dim1B):
   571   88.434 MiB    0.000 MiB       for q in range(dim1B):
   572   88.434 MiB    0.000 MiB         for i in holes:
   573   88.434 MiB    0.000 MiB           df[p,q] += 0.5*(
   574   88.434 MiB    0.000 MiB             etaGamma[idx2B[(i,p)], idx2B[(i,q)]] 
   575   88.434 MiB    0.000 MiB             + transpose(etaGamma)[idx2B[(i,p)], idx2B[(i,q)]]
   576                                     )
   577                             
   578   88.434 MiB    0.000 MiB     etaGamma = dot(eta2B, dot(occC_2B, Gamma))
   579   88.434 MiB    0.000 MiB     for p in range(dim1B):
   580   88.434 MiB    0.000 MiB       for q in range(dim1B):
   581   88.434 MiB    0.000 MiB         for r in range(dim1B):
   582   88.434 MiB    0.000 MiB           df[p,q] += 0.5*(
   583   88.434 MiB    0.000 MiB             etaGamma[idx2B[(r,p)], idx2B[(r,q)]] 
   584   88.434 MiB    0.000 MiB             + transpose(etaGamma)[idx2B[(r,p)], idx2B[(r,q)]] 
   585                                     )
   586                             
   587                             
   588                               #############################        
   589                               # two-body flow equation  
   590   88.434 MiB    0.000 MiB     dGamma = np.zeros_like(Gamma)
   591                             
   592                               # 1B - 2B
   593   88.434 MiB    0.000 MiB     for p in range(dim1B):
   594   88.434 MiB    0.000 MiB       for q in range(dim1B):
   595   88.434 MiB    0.000 MiB         for r in range(dim1B):
   596   88.434 MiB    0.000 MiB           for s in range(dim1B):
   597   88.434 MiB    0.000 MiB             for t in range(dim1B):
   598   88.434 MiB    0.000 MiB               dGamma[idx2B[(p,q)],idx2B[(r,s)]] += (
   599                                           eta1B[p,t] * Gamma[idx2B[(t,q)],idx2B[(r,s)]] 
   600                                           + eta1B[q,t] * Gamma[idx2B[(p,t)],idx2B[(r,s)]] 
   601                                           - eta1B[t,r] * Gamma[idx2B[(p,q)],idx2B[(t,s)]] 
   602                                           - eta1B[t,s] * Gamma[idx2B[(p,q)],idx2B[(r,t)]]
   603                                           - f[p,t] * eta2B[idx2B[(t,q)],idx2B[(r,s)]] 
   604                                           - f[q,t] * eta2B[idx2B[(p,t)],idx2B[(r,s)]] 
   605                                           + f[t,r] * eta2B[idx2B[(p,q)],idx2B[(t,s)]] 
   606   88.434 MiB    0.000 MiB                 + f[t,s] * eta2B[idx2B[(p,q)],idx2B[(r,t)]]
   607                                         )
   608                             
   609                               
   610                               # 2B - 2B - particle and hole ladders
   611                               # eta2B.occB.Gamma
   612   89.461 MiB    1.027 MiB     etaGamma = dot(eta2B, dot(occB_2B, Gamma))
   613                             
   614   89.461 MiB    0.000 MiB     dGamma += 0.5 * (etaGamma + transpose(etaGamma))
   615                             
   616                               # 2B - 2B - particle-hole chain
   617                               
   618                               # transform matrices to particle-hole representation and calculate 
   619                               # eta2B_ph.occA_ph.Gamma_ph
   620   89.461 MiB   89.461 MiB     eta2B_ph = ph_transform_2B(eta2B, bas2B, idx2B, basph2B, idxph2B)
   621   89.461 MiB   89.461 MiB     Gamma_ph = ph_transform_2B(Gamma, bas2B, idx2B, basph2B, idxph2B)
   622                             
   623   91.781 MiB    2.320 MiB     etaGamma_ph = dot(eta2B_ph, dot(occphA_2B, Gamma_ph))
   624                             
   625                               # transform back to standard representation
   626   91.781 MiB   91.781 MiB     etaGamma    = inverse_ph_transform_2B(etaGamma_ph, bas2B, idx2B, basph2B, idxph2B)
   627                             
   628                               # commutator / antisymmetrization
   629   91.781 MiB    0.000 MiB     work = np.zeros_like(etaGamma)
   630   91.781 MiB    0.000 MiB     for i1, (i,j) in enumerate(bas2B):
   631   91.781 MiB    0.000 MiB       for i2, (k,l) in enumerate(bas2B):
   632   91.781 MiB    0.000 MiB         work[i1, i2] -= (
   633                                     etaGamma[i1, i2] 
   634                                     - etaGamma[idx2B[(j,i)], i2] 
   635                                     - etaGamma[i1, idx2B[(l,k)]] 
   636   91.781 MiB    0.000 MiB           + etaGamma[idx2B[(j,i)], idx2B[(l,k)]]
   637                                   )
   638   91.781 MiB    0.000 MiB     etaGamma = work
   639                             
   640   91.781 MiB    0.000 MiB     dGamma += etaGamma
   641                             
   642                             
   643   91.781 MiB    0.000 MiB     return dE, df, dGamma


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   649   89.660 MiB   89.660 MiB   @profile
   650                             def get_operator_from_y(y, dim1B, dim2B):
   651                               
   652                               # reshape the solution vector into 0B, 1B, 2B pieces
   653   89.660 MiB    0.000 MiB     ptr = 0
   654   89.660 MiB    0.000 MiB     zero_body = y[ptr]
   655                             
   656   89.660 MiB    0.000 MiB     ptr += 1
   657   89.660 MiB    0.000 MiB     one_body = reshape(y[ptr:ptr+dim1B*dim1B], (dim1B, dim1B))
   658                             
   659   89.660 MiB    0.000 MiB     ptr += dim1B*dim1B
   660   89.660 MiB    0.000 MiB     two_body = reshape(y[ptr:ptr+dim2B*dim2B], (dim2B, dim2B))
   661                             
   662   89.660 MiB    0.000 MiB     return zero_body,one_body,two_body


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   707   80.062 MiB   80.062 MiB   @profile
   708                             def pairing_hamiltonian(delta, g, user_data):
   709   80.062 MiB    0.000 MiB     bas1B = user_data["bas1B"]
   710   80.062 MiB    0.000 MiB     bas2B = user_data["bas2B"]
   711   80.062 MiB    0.000 MiB     idx2B = user_data["idx2B"]
   712                             
   713   80.062 MiB    0.000 MiB     dim = len(bas1B)
   714   80.062 MiB    0.000 MiB     H1B = np.zeros((dim,dim))
   715                             
   716   80.062 MiB    0.000 MiB     for i in bas1B:
   717   80.062 MiB    0.000 MiB       H1B[i,i] = delta*np.floor_divide(i, 2)
   718                             
   719   80.062 MiB    0.000 MiB     dim = len(bas2B)
   720   80.062 MiB    0.000 MiB     H2B = np.zeros((dim, dim))
   721                             
   722                               # spin up states have even indices, spin down the next odd index
   723   80.062 MiB    0.000 MiB     for (i, j) in bas2B:
   724   80.062 MiB    0.000 MiB       if (i % 2 == 0 and j == i+1):
   725   80.062 MiB    0.000 MiB         for (k, l) in bas2B:
   726   80.062 MiB    0.000 MiB           if (k % 2 == 0 and l == k+1):
   727   80.062 MiB    0.000 MiB             H2B[idx2B[(i,j)],idx2B[(k,l)]] = -0.5*g
   728   80.062 MiB    0.000 MiB             H2B[idx2B[(j,i)],idx2B[(k,l)]] = 0.5*g
   729   80.062 MiB    0.000 MiB             H2B[idx2B[(i,j)],idx2B[(l,k)]] = 0.5*g
   730   80.062 MiB    0.000 MiB             H2B[idx2B[(j,i)],idx2B[(l,k)]] = -0.5*g
   731                               
   732   80.062 MiB    0.000 MiB     return H1B, H2B


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   737   80.062 MiB   80.062 MiB   @profile
   738                             def normal_order(H1B, H2B, user_data):
   739   80.062 MiB    0.000 MiB     bas1B     = user_data["bas1B"]
   740   80.062 MiB    0.000 MiB     bas2B     = user_data["bas2B"]
   741   80.062 MiB    0.000 MiB     idx2B     = user_data["idx2B"]
   742   80.062 MiB    0.000 MiB     particles = user_data["particles"]
   743   80.062 MiB    0.000 MiB     holes     = user_data["holes"]
   744                             
   745                               # 0B part
   746   80.062 MiB    0.000 MiB     E = 0.0
   747   80.062 MiB    0.000 MiB     for i in holes:
   748   80.062 MiB    0.000 MiB       E += H1B[i,i]
   749                             
   750   80.297 MiB    0.000 MiB     for i in holes:
   751   80.297 MiB    0.000 MiB       for j in holes:
   752   80.297 MiB    0.234 MiB         E += 0.5*H2B[idx2B[(i,j)],idx2B[(i,j)]]  
   753                             
   754                               # 1B part
   755   80.297 MiB    0.000 MiB     f = H1B
   756   80.297 MiB    0.000 MiB     for i in bas1B:
   757   80.297 MiB    0.000 MiB       for j in bas1B:
   758   80.297 MiB    0.000 MiB         for h in holes:
   759   80.297 MiB    0.000 MiB           f[i,j] += H2B[idx2B[(i,h)],idx2B[(j,h)]]  
   760                             
   761                               # 2B part
   762   80.297 MiB    0.000 MiB     Gamma = H2B
   763                             
   764   80.297 MiB    0.000 MiB     return E, f, Gamma


Filename: imsrg_pairing_bench.py

Line #    Mem usage    Increment   Line Contents
================================================
   831   75.211 MiB   75.211 MiB   @profile
   832                             def main(n_holes):
   833                               # grab delta and g from the command line
   834                               # delta      = float(argv[1])
   835                               # g          = float(argv[2])
   836   75.211 MiB    0.000 MiB     delta = 1
   837   75.211 MiB    0.000 MiB     g = 0.5
   838                               
   839   75.211 MiB    0.000 MiB     particles  = n_holes
   840                             
   841                               # setup shared data
   842   75.211 MiB    0.000 MiB     dim1B     = n_holes*2
   843                             
   844                               # this defines the reference state
   845                               # 1st state
   846   75.211 MiB    0.000 MiB     holes = np.arange(particles)
   847   75.211 MiB    0.000 MiB     particles = np.arange(particles,dim1B)
   848                             
   849                               # 2nd state
   850                               # holes     = [0,1,4,5]
   851                               # particles = [2,3,6,7]
   852                             
   853                               # 3rd state
   854                               # holes     = [0,1,6,7]
   855                               # particles = [2,3,4,5]
   856                             
   857                               # basis definitions
   858   75.211 MiB    0.000 MiB     bas1B     = list(range(dim1B))
   859   75.211 MiB   75.211 MiB     bas2B     = construct_basis_2B(holes, particles)
   860   75.211 MiB   75.211 MiB     basph2B   = construct_basis_ph2B(holes, particles)
   861                             
   862   75.211 MiB   75.211 MiB     idx2B     = construct_index_2B(bas2B)
   863   75.211 MiB   75.211 MiB     idxph2B   = construct_index_2B(basph2B)
   864                             
   865                               # occupation number matrices
   866   75.211 MiB   75.211 MiB     occ1B     = construct_occupation_1B(bas1B, holes, particles)
   867   76.453 MiB   76.453 MiB     occA_2B   = construct_occupationA_2B(bas2B, occ1B)
   868   77.484 MiB   77.484 MiB     occB_2B   = construct_occupationB_2B(bas2B, occ1B)
   869   78.773 MiB   78.773 MiB     occC_2B   = construct_occupationC_2B(bas2B, occ1B)
   870                             
   871   80.062 MiB   80.062 MiB     occphA_2B = construct_occupationA_2B(basph2B, occ1B)
   872                             
   873                               # store shared data in a dictionary, so we can avoid passing the basis
   874                               # lookups etc. as separate parameters all the time
   875                               user_data  = {
   876   80.062 MiB    0.000 MiB       "dim1B":      dim1B, 
   877   80.062 MiB    0.000 MiB       "holes":      holes,
   878   80.062 MiB    0.000 MiB       "particles":  particles,
   879   80.062 MiB    0.000 MiB       "bas1B":      bas1B,
   880   80.062 MiB    0.000 MiB       "bas2B":      bas2B,
   881   80.062 MiB    0.000 MiB       "basph2B":    basph2B,
   882   80.062 MiB    0.000 MiB       "idx2B":      idx2B,
   883   80.062 MiB    0.000 MiB       "idxph2B":    idxph2B,
   884   80.062 MiB    0.000 MiB       "occ1B":      occ1B,
   885   80.062 MiB    0.000 MiB       "occA_2B":    occA_2B,
   886   80.062 MiB    0.000 MiB       "occB_2B":    occB_2B,
   887   80.062 MiB    0.000 MiB       "occC_2B":    occC_2B,
   888   80.062 MiB    0.000 MiB       "occphA_2B":  occphA_2B,
   889                             
   890   80.062 MiB    0.000 MiB       "eta_norm":   0.0,                # variables for sharing data between ODE solver
   891   80.062 MiB    0.000 MiB       "dE":         0.0,                # and main routine
   892                             
   893                             
   894   80.062 MiB    0.000 MiB       "calc_eta":   eta_wegner,          # specify the generator (function object)
   895   80.062 MiB    0.000 MiB       "calc_rhs":   flow_imsrg2         # specify the right-hand side and truncation
   896                               }
   897                             
   898                               # set up initial Hamiltonian
   899   80.062 MiB   80.062 MiB     H1B, H2B = pairing_hamiltonian(delta, g, user_data)
   900                               
   901   80.297 MiB   80.297 MiB     E, f, Gamma = normal_order(H1B, H2B, user_data) 
   902                             
   903                               # reshape Hamiltonian into a linear array (initial ODE vector)
   904   81.523 MiB    1.227 MiB     y0   = np.append([E], np.append(reshape(f, -1), reshape(Gamma, -1)))
   905                             
   906   81.523 MiB    0.000 MiB     t = 1
   907   89.660 MiB   89.660 MiB     dy = derivative_wrapper(t, y0, user_data)
   908   89.660 MiB   89.660 MiB     dE, df, dG = get_operator_from_y(dy, dim1B, dim1B*dim1B)
   909   89.660 MiB    0.000 MiB     print(dE)


---------------------------------------------

